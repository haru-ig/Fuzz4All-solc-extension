pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    struct ComplexStruct1 {
        address address1;
        bytes _internal1;
    }
    struct ComplexStruct2 {
        bytes _internal2;
        address address2;
    }
    ComplexStruct1 struct1;
    ComplexStruct2 struct2;
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {

    address private emptyAddress;
    constructor() public {
        emptyAddress.value(1 ether)();
    }
    function Test() public {
        uint256 y;
        for (uint i = 0; i < 1; ++i) {
            require(emptyAddress.balance == 1, "Fail - emptyAddress value");

        }
    }
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    uint[] array;
    ComplexStruct complexStruct;
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    uint[] array;
    ComplexStruct complexStruct;
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    uint[] array;
    complexStruct complexStruct;
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    uint[] internal array;
    uint internal size;
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    uint[] internal array;
    uint internal size;
    uint internal value;
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    uint[] internal array;
    uint internal size;
    uint internal value;
}

pragma solidity ^0.8.0;
contract EfficientDynamicArrayType {
    uint256 internal value;
    uint256 maxVal;
    uint internal i;
}

pragma solidity
