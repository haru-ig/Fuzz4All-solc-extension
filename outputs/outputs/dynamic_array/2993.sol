pragma solidity ^0.8.0;
contract SymbolicEquality_Semantics {
    function f() public pure returns (bool){
    return true;
    }
    function r1() public pure returns (uint) {
    return 1;
    }
    function r2() public view returns (bool){
    return false;
    }
    function r3() public view {
    bool _ = f();
    x;
    bytes memory a;
    bytes16 a2;
    bytes32 _ = r5();
    bytes20 _ = r6();
    bytes32 _ = r7();
    bytes4 _ = r9();
    bytes _ = r10();
    bytes16 _ = r14();
    bytes32 _ = r16();
    bytes _ = r16();
    bytes16 _ = r17();
    bytes32 _ = r19();
    bytes2 _ = r20();
    bytes8 _ = r25();
    bytes9 _ = r26();
    bytes10 _ = r27();
    bytes11 _ = r27();
    address _ = r28();
    address _ = r29();
    bytes32 _ = r30();
    bytes32 _ = r31();
    bytes32 r32 = r32;
    bytes255 _ = r33();
    emit E();
    assembly {
        mstore(0x1000, 1323232307300000000000000000000000000)
        }
        bytes19 _bytes20_;
        bytes23 _bytes21_;
        bytes32 _bytes22_;
        bytes p;
        address p33;
        uint p34 = 0x2000;
    }
        bool _ = r40();
    function r9() public pure {
        if (x_.length){
            bool _ = f();
            x[0x1] = p;
            address p34;
            uint p34;
            bytes4 _ = r5();
            bytes _ = r6();
            bytes16 _ = r7();
            bytes32 _ = r9();
            bytes20 _ = r10();
            bytes32 _ = r14();
            bytes2 _ = r16();
            bytes p;
            address _ = r16();
            address _ = r
