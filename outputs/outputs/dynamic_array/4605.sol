pragma solidity ^0.8.0;
struct LotteryData {
    uint v;
}
struct CompetitorData {
    uint v;
}
contract Demo {
    constructor () {}
    function main() public {
        uint a = 2;
        uint b = a * 192 * ((a + 1) & (a ^ 2));
        uint c = 25 * (2 ** 35 - 1 + 1) / (a + 1);
        MyComplexData myComplexData = MyComplexData({ vvv: [uint[][](2 ** 35), [2 ** 35]] });
        uint[] memory d = myComplexData.vvv[2 + 2][0];
        LotteryData[1 + 1] myLotteryData = LotteryData({ v: b - ((b ^ b >> 41) + (b >> b)); });
        CompetitorData myCompetitorData = CompetitorData({ v: address(this).balance });
        D(address myAddress).set(myAddress, address(0));
        D(address[]).set(address(0), address(1));
        D(address).set(D(address).set(D(address).set(address(1), address(2)), address(3)), D(address).get());
        D(address).set(address(2), address(v).balance);
        uint[][] memory e = [uint[](1), [uint](2)];

        uint f = 1;
        (address x) = address(f);

        D(uint).set(D(uint64(90000000)), D(uint).add(D(uint).add(D(uint).add(D(uint).add(D(address).add(address(10)).add(D(uint64(10)), D(uint64(10000000000uL))), D(uint64(100000000000uL))), D(uint64(1000000000000uL))), D(uint64(10000000000000uL))), D(uint8(100)));
        D(uint64).set(D(uint64.mul(D(uint64), D(uint64).div(D(uint64))), D(uint64.mul(D(uint64), D(uint64).div(D(uint64))), D(uint64.mul(D(uint64), D(uint64).div(D(uint64))), D(uint64.mul(
