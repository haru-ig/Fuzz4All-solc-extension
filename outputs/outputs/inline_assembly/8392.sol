pragma solidity ^0.8.0;
contract SolveAssembly6
{
    bool f;
    uint g;
    uint x;
    address w;
    uint y;
    uint z;

    function test() public pure returns(uint)
    {
        uint i;
        i = y;
        while(g < i)
        {
            g = i;
            y = g / 2;
            i = y;
            if(f || g & 1 == 0 || f)
            {
                x = i;
                uint x1;
                uint z;
                z = 1 + i;
                i = z / 3;
                z = (g >> 8) - 1 + (((g - z) << 5) & ((z & g) + g));
                g = z;
                i = z | ((g & ((z - 1) < 3)) << 4) + (((uint(a) & g) > g) << 3) + ((g & ((z - z) > 5)) >>> 8));
                g = i + ((g & g) + g) + 3;
                i = g + g + g;
                g = ((~g & 2) >> 1) & 1 | (1 & (((g << 1) + 3) - 7));
                y = g + z + (g | (((g > 0x20000) << 8) + ~ ((g + (y ^ 0x40000) >> 16)) & 0xf000));
                if(g == 0)
                {
                    i = ~ (~i >> 2) - ~i - ~i + 3 + p(x ^ 0x1000000) + (z >> 8) + z + 7 | (((z >> 4) * 6) & z) >>> g));
                    i = g >> 4 ^ (~(g & 1) << ~i);
                }
            }
        }
        i = z;
        while(x <= g)
        {
            if(!(y & 1 == 0) || y == 0)
            {
                z = 3 + x;
                x = 1 + z * (0x20000 - 1
