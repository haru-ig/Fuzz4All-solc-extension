pragma solidity ^0.8.0;
contract E{
    uint public x;
    constructor() public {}
    function a() public {
        x = 10;
        x = x + 3.2;
        x = 23 - x;
        x = x + 4;
        x = 3 + x;
        x = 2 * x;
    }
}
contract D {
    function foo() public pure {
        x = 0;
        uint r = 2 + 4 * x;
    }
}
contract E {
    function foo() public pure {
        uint y = 16;
        uint z = x - 3;
        uint w = 15 - 5;
        uint ky = x * 2000;
        y = 3 - 4 * y;
        z = 3 + 2 * z;
        y = 3 - 16 * y;
        y = y * 3;
        x = x - y;
        halo();
    }
}

contract E {
    uint public z;
    uint public w;
    uint public wk;

        constructor () public {
            w = 5;
        }

        function func2() public {
            uint wk = 0;
        }
        function f() public {
            x = 1;
            uint halo = 3;
            halo = w * 3;
        }
        function e() public {
            ky = wk + 1;
            ky = ky + 3;
            z = 3;
            w = w - 1;
            func2();
            z = 0;
            uint wk = 3;
            uint x = 0;
            ky = wk + 1;
            y = 16;
        }
    }

contract AA {

    uint[10] z;
    uint  w;
    uint public ky;

        constructor () public {
        w = 0;
        }
        function func2()public {
        uint y = 16;
        }
        function f() public {
            uint halo = y;
            halo = w * 3;
        }

        function e() public {
            uint i = 1;
        }
    }


    function calc()public() {
    uint i = 1;
        uint j = 1;
        uint ky;
        while (true){
            i = i + 1;
            j = j*2;
            uint halo = 3*2;
            halo = (i
