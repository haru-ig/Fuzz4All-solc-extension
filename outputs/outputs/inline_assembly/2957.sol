pragma solidity ^0.8.0;
contract C {
    mapping (uint => uint) mapping2;
    function setX(uint _x) public {
        mapping2[_x] = _x;
    }
}
```

```solidity
pragma solidity ^0.8.0;
contract C {
    uint public x;
    mapping (uint => uint) mapping2;
    function setX(uint _x) public {
        mapping2[_x] = mapping2.length _x;
    }
}
```

```solidity
pragma solidity ^0.8.0;
contract C {
    uint public x;
    mapping (uint => uint) mapping2;
    uint constant X = 50;
    mapping3_3[uint] _mapping3;
    mapping (uint => uint) mapping2;
    function setX(uint _x) public { mapping2.length is true?mapping2[X + _x] =mapping2.length + _x:mapping2.length is 0:mapping2[X + _x] =mapping2.length + _x;
        _mapping3[X + _x] = _x;
    }
}
```

```solidity
pragma solidity ^0.8.0;
contract C {
    using uint256 for uint;
    uint public x;
    mapping (uint => uint) mapping2;
    uint constant X = 50;
    mapping3_3[uint] _mapping3;
    mapping (uint => uint) mapping2;
    function setX(uint _x) public { mapping2.length is true?mapping2[X + X] =mapping2.length + X:mapping2.length is 0:mapping2[X + _x] =mapping2.length + _x;
        _mapping3[X + X] = _x;
    }
}
```

```solidity
x x; x := true;
x x;
x;
x x; x := false;
```

```solidity
pragma solidity ^0.8.0;
contract C {
    uint public x;
    mapping (uint => uint) mapping2;
    uint constant X = 50;
    mapping3_3[uint] _mapping3;
    mapping (uint => uint) mapping2;
    function setX(uint _x) public { mapping2.length is true?mapping2[X + X] =mapping2.length + X:mapping2.length is 0:mapping2[X + _x] =mapping2.length + _x;
        x _x; x := false;
        mapping2;
        mapping2;
