pragma solidity ^0.8.0;
contract SemanticallyEquivalent26 {
  function bar() public pure {
    assembly {
      let _size := mload(0x40)
      let data := copy(calldataload(_size))
      let memory := mload(0x40)
      let memorySize := sub(0x40, memory)
      let memoryContents := calldataload(memoryContents)
      mstore(memory, memoryContents)
      mstore8(memory + 32, 0)
      let memoryContentsAfter := calldataload(memoryContents)
      mstore8(32, memoryContentsAfter)
      memory := and(memory, memoryContents)
      mstore(0x40, memory)
      mstore8(64, 0)
      let memoryContentsAfter2 := calldataload(memoryContents)
      mstore8(64, memoryContentsAfter2)
      let data2 := mload(0x0)
      let data3 := copy(calldataload(32))
      mstore8(72, data2)
      mstore(0x0, data)
      mstore8(64, data3)
      mstore(128, 0)
      let memoryContentsAfter2B := calldataload(memoryContents)
      mstore8(128, memoryContentsAfter2B)
      mstore(256, 0)
      mstore8(128, 0)
      let memoryContentsAfter := and(memory, memoryContents)
      mstore(376, memoryContentsAfter)
      mstore(128, 0)
      mstore8(224, 0)
      memory := sub(memorySize, 32)
      mstore(400, memory)
      mstore(128, 0)
      mstore8(192, memorySize)
      mstore(448, 0)
      memory := mload(0x40)
      mstore8(32, memory)
      mstore(480, memory)
      memoryContents := mload8(32)
      mstore(544, memoryContents)
      callvalue(65)
      sstore(1)
      mstore8(128, 0)
      mstore(592, memorySize)
      mstore8(224, 0)
      mstore(640, 7)
      mstore(152, 3)
      mstore(7200, 0)
      mstore8(832, 0)
      mstore(32, 5)
      mstore(960, memorySize)
      mstore
