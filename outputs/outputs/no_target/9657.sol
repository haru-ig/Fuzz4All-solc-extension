pragma solidity ^0.8.0;
contract IERC20Upgradeable is IERC20 { function decimals() public view virtual override returns (uint80); }
contract MyToken { IERC20Upgradeable public token_; uint256 public balance_; constructor() { balance_ = 100; } function mint(address to, uint256 amount) public { uint256 _balance = balance_; balance_ += amount; token_.mint(to, amount); } function burn(address from, uint256 amount) public { (bool success, ) = from.call{value: amount}(""); require(success, "Failed to call burn()"); balance_ -= amount; } function balanceOf(address owner) public view returns (uint256) { return balance_; } }
contract MyChildToken is IERC20Upgradeable, MyToken, Ownable { constructor() { super(); } function safeMint(address to, uint256 amount) public onlyOwner { mint(to, amount); } function safeBurn(address from, uint256 amount) public onlyOwner { super.burn(from, amount); } }
interface IERC20UpgradeableFactory { function createInstance() external returns (address); }
contract IERC20_FactoryUpgradeable is IERC20_Factory { constructor(address token, address mint, address burn) { } factory function() public { IERC20Upgradeable token_ = IERC20(token); token_.mint(mint, 100); token_.mint(burn, 100); } constructor() public { } }
interface IERC20UpgradeableReceiver { function onERC20Received(address, address, uint256 value, bytes memory data) external returns (bool); }
contract MyChildTokenFactory is Ownable, IERC20_FactoryUpgradeable { constructor(address token, address mint, address burn) { IERC20Upgradeable token_ = IERC20(token); token_.mint(mint, 100); token_.mint(burn, 100); } constructor() public { } function createInstance() public { IERC20 token_ = IERC20(token_); IERC20Receiver receiver_ = IERC20UpgradeableReceiver(address(this)); bytes4(keccak256("onERC20Received(address,address,uint256,bytes)")); IERC20UpgradeableFactory factory_ = IERC20
