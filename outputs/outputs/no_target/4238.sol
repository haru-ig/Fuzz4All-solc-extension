pragma solidity ^0.8.0;
contract P11 {

  constructor(uint x) public {
    assert(x >= 0, "cannot use negative numbers and literals with literals");
  }

  function f(uint y) public pure returns (uint256) {
    return y - 1;
  }
}
contract P12 {
  function f(uint x) public pure returns (uint256) {
    return 1;
  }
}
contract P18 {
  function z() public pure returns (uint256) {
    return 1;
  }
}
contract P19 {
  function z() public pure returns (uint256) {
    return 1;
  }
}
contract P20 {

  constructor(uint y) public {
    assert(y > 17, "can subtract larger integers from smaller ones");
    i;
  }

  function i() public pure returns (uint) {
    return 1;
  }
}
contract P21 {
  function f() public pure returns (uint) {
    uint256 j = 1;
    uint.max;
    uint8 x;
    uint i;
    uint256 k;
    uint256 l;
    uint h;
    uint256 a;
    uint256 b;
    uint256 c;
    uint256 v;
    uint256 y;
    uint256 z;
    uint256 t;
    uint256 w;
    uint256 r;
    uint256 s;
    uint kz = 12;
    uint zg;
  }

  function g() public pure returns (uint) {
    uint4 i = 4;
    if (false)
      uint24.max;
    return i;
  }
}
contract P22 {

  function f() public pure returns (uint) {
    uint y;
    uint256 x;
    uint a;
    uint256 x0;
    uint z;
    uint t;
    uint a0;
  }
}
contract P23 {

  function f() public pure returns (uint) {
    uint256 j;
    uint z;
    uint f;
    uint g;
  }
}
contract P24 {

  function f() public pure returns (uint) {
    uint _y0;
    uint _x0;
    uint _a0;
    uint _v0;
    uint _w0;
    uint _u0;
    uint _y;
    uint _x;
    uint _a;
    uint _v;
    uint _w;
    uint _u;
    uint8 x0;
    uint8 x;
    uint8
