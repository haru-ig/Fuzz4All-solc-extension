pragma solidity ^0.8.0;
contract Test1 {
	 using SafeMath for uint256;
    constructor() public {
        uint256[] memory args = new uint256[](0);
        uint256 _max = now.add(10years);
        IERC223Token(_fromToken).approve(_toToken, 0, _max);
        IERC223Token(_fromToken).transferFrom(_operator, _toToken,_max),

        IERC223Token(_fromToken).approve(_toToken,1,_max).revert();

        IERC223Token(_fromToken).transferFrom(_operator, _toToken,_max).revert();

        uint256 _d = uint256(_max * 0.5) + 1;

        bool _ret = uint256(_max == _div) && _d == uint256(_mod) && bool(uint256(uint256(_div == uint256(now)-_max)) == uint256(uint256(uint256(_div == uint256(now)-_max)))))) && uint8_mod(_tdiv,_tmod);

        require(!(_ret), "");

         IERC223Token(_fromToken).transferFrom(_operator, _toToken,_max).revert();
	 IERC223Token(_fromToken).approve(_toToken, _max).revert();
    }
    function safeDiv (uint256) public returns (uint256) {
        return 0;
    }
    function safeAdd (uint256) public returns (uint256) {
        return 0;
    }
    function safeMod(uint256) public returns (uint256) { return 0;}
    function safeSub(uint256) public returns (uint256) { return 0;}
    function safeMul(uint256) public returns (uint256) { return 0;}
    function safeExp(uint256) public returns (uint256) { return 0;}
