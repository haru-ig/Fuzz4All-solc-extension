pragma solidity ^0.8.0;
contract Nonmutating {
    bool public _1 = false;
    constructor() public {
    }
}
contract Simple {
    uint _1;
    constructor(uint512 _1) public {
        _1 = _1 + 1;
    }
    function set_1(uint512 _1) public {
        _1 = _1 + 1;
    }
    function get_1() public view returns (uint512) {
        return _1 + 1;
    }
}
contract Simple2 {
    uint _1;
    function() external payable {
        _1 = 1;
    }
}
contract Simple3 {
    uint _1;
    modifier modif2(uint512 _1) {
        _1 = _1 + 1;
        _1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        emit Transfer(address(0x123), address(0x123), _1);
    }
    modifier modif3(uint512 _1) {
        _1 = _1 + 1;
        _1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _1 + 1;
        _1 = _
