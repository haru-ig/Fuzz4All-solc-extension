pragma solidity ^0.8.0;
contract ABC {
  function A ( uint a) public pure {
    a = a + 1;
    a += 1;
    a += 1;
    a += 1;
  }
}
contract XYZ {
  function C ( uint a) public pure {
    XYZ x;
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    x.E();
    x.F();
    x.G();
    a = uint8(a);
    a += uint8(a);
    a += uint8(a);
    a += uint8(a);
    a += uint8(a);
  }
}
contract ABCDE {
  function A (uint256 a)public pure {
    A(uint16(uint32(a)));
    A(uint17(uint36(a)));
    A(uint31(uint64(a)));
    A(uint63(uint128(a)));
    A(uint127(uint256(a)));
    a = uint8(a);
    a += uint8(a);
    a += uint8(a);
    a += uint8(a);
    a += uint8(a);
  }
}
contract ABCDEFG {
  function A (uint256 a)public pure {
    A(uint127(uint256(
