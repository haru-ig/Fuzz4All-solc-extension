pragma solidity ^0.8.0;
contract C1 {
    function f() public pure {

        uint64 x_ = uint64(Foo.barmut(1));
        uint20 y_ = uint20(uint22(Foo.barmut(2)));


        uint a_;
        uint a_ = byte(uint(Foo.bazmut(2)));
        assert(uint(a_) == 3);


        uint256 x__ = byte(uint(Foo.bazmut(2)));
        uint256 x__ = bool(uint(Foo.bazmut(2)));
        uint256 x__ = byte(uint(Foo.bazmut(2)));
        uint160 x__ = uint160(uint(Foo.bazmut(2)));


        uint x__ = int(uint(Foo.bazmut(2)));
        uint x__ = byte(uint(Foo.bazmut(2)));
        uint x__ = uint(uint(Foo.bazmut(2)));
        uint x__ = uint(uint64(uint(Foo.bazmut(2))));
        uint x__ = uint(uint(uint(Foo.bazmut(2))));
        uint256 x__ = uint256(uint(uint(Foo.barmut(2))));
        uint256 x__ = uint256(uint(uint256(uint(Foo.bazmut(2)))));
        uint256 x__ = uint256(uint256(uint256(uint(Foo.bazmut(2)))));


        int256 x__ = int8(uint8(uint(1)));
        int256 x__ = int16(int8(uint16(uint(1))));


        int x__ = int(uint128(uint(1)));
        int x__ = int128(uint128(uint128(uint(1))));


        address x__ = int256(uint256(uint(1)));
        address x__ = int256(uint(uint256(uint(1))));
    }
}
