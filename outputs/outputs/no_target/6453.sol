pragma solidity ^0.8.0;
contract E {
    f() public {
    }
}
pragma solidity ^0.7.0;
contract X{
    modifierB2 public {
        f();
    }
}
pragma solidity ^0.7.0;
contract B{
    function b() public returns(uint) {
      if(b0 == 0)
        return b1;
      if(b_ == 0)
        return b_ + b1 - b_ + b1 - b1 - b_ + b_ + b_ + b_ + b1 + b_ + b_ + b1 + b1 + b1 - b0;
      if(b_ - b_ == 0)
        return b0 + b_ + b1;
      if(b_ + b_ >= 0)
        return 0;
      return 0;
    }
constructor(uint8 b0_, uint8 b_) external{b0 = b0_; b_ = b_;}
function a() public{b0 = 4;}
}
contract C is B{
    uint8 public b_;
    uint8 public b0;
    bool public b1;
}
contract D{
    address public a_;
}
pragma solidity ^0.7.0;
contract E{
    uint8 public b_;
    uint8 public a0;
    address public a1;
    bool public b1;
}
contract X{
    modifierB2 public {
      a0;
    }
}
pragma solidity ^0.7.0;
contract X{
    modifierB2 public {
      if(f())f();
    }
    function f() public {
    }
}
pragma solidity ^0.7.0;
contract X{
    modifierB2 public {
      a0000;
    }
    uint8 a0000;
}
pragma solidity ^0.7.0;
contract B{
    function b() public returns(uint) {
      if(b0 == 0)
        return b1;
      if(b_ == 0)
        return b_ + b1 - b_ + b1 - b1 - b_ + b_ + b_ + b_ + b1 + b_ + b_ + b1 + b1 + b1 - b0;
      if(b_ - b_ == 0)
        return b0 + b_ + b1;
      if(b_ + b_ >= 0)
        return 0;
      return 0;
    }
constructor(uint8 b0_, uint8 b_) external{b0 = b0_; b_ = b_;}
function a() public{b0 = 4;}
}
contract C is B{
    uint8 public a0;
    uint8 public a1;
    uint8 public b0;
    uint8 public b1;
    uint8 public b_;
}
contract D{
    address public a_;
}
