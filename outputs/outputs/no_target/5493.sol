pragma solidity ^0.8.0;
contract O {
    uint public  x;
    constructor (uint x) {
        this.x = x;
        emit xchange(x + 1);
    }
    event xchange(uint y);
    function y(uint x) external {
        x = x * 3 / 2;
        emit xchange(x + 1);
    }
}
contract O {
    uint public y;
    function y() public {
        require(0 <= 123 && 123 <= 123, "wrong input");
        y = uint256(244) >> 8 | 123;
        assert(y == 244);
    }
    event xchange(uint y);
    function (bytes memory _data) public {


        assert(y!= 244);
        emit xchange(y);
    }
}
contract O {
    constructor() public { }
    function f() public { }
    event xchange(uint y);
    function (bytes memory _data) public {


        assert(y!= 244);
        emit xchange(y);
    }
}
contract O {
    uint public y;
    function y() public {

        y *= bytes(0).length;
        assert(uint256(1) > 5 + uint256(0), "wrong input");
    }
    event xchange(uint y);
    function (bytes memory _data) public {

        assert(y!= 244);
        emit xchange(y);
    }
}
contract O {
    constructor() public { }
    function () public payable { }
    struct xchange {
        uint public y;
    }
    mapping (uint => mapping (uint => mapping (uint => uint))) d_map;
    function x() public {
        d_map[1][2][3] = 1;
        emit xchange({y: 1});
    }
    event xchange(xchange memory y);
    function (bytes memory _data) public {

        emit xchange({y: 1});
    }
}



contract O {
    enum z { one, two, three }
    uint public x;
    event xchange(uint y);
    function y() external returns (uint8, uint20, z) {
        uint256 r;
        uint w;
        assembly {
            r := mload(0x40)
            w
