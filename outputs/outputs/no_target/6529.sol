pragma solidity ^0.8.0;
contract myContractA {
    int private x;
}
contract myContractB {
    uint8 private y;
}
contract myContractC {
    uint16 private z;
}
contract myContractD {
    uint private w;
}
contract x{
    function x() public() {
        uint x = uint(uint(x)/ x.max());
    }
}
contract y is x{
    function y() public() {
        uint p = uint(y) * uint(uint(x)) * uint(uint(y) / uint(y) / uint(x)) / uint(x) / uint(10);
        y p = y / x * 10;
        bytes memory string = bytes(p)/ x;
        string memory c;
        c = bytes2string(a);
        address a;
        a = byte2address(string);
    }
}
contract z is x{
    function z() public() {
        uint i = uint(uint(x)) + uint(uint(x) + uint(uint(x)) + uint(uint(x) + uint(uint(x)) + uint(uint(x) + uint(uint(x)))))) + uint(uint(uint(x)) + uint(uint(uint(x)) * uint(uint(x))));
    }
}
contract myContractA{
    function f() public view returns (uint) {
        return (uint(uint(x)/ x.max()));
    }
}
contract myContractB{
    function f() public view returns (uint256) {
        return (uint(x)/ uint(x)/ uint(x));
    }
}
contract myContractC{
    function f() public view returns (uint16) {
        return (uint(x)/ uint(x)/ uint(x)/ uint(x)/ uint(x)/ uint(x));
    }
}
contract myContractD{
    function f() public view only returns (uint) {
        return uint(uint(uint(x)/ x.max()));
    }
}
contract x2{
    function x() public() {
        uint x = uint(uint(uint(x)));
    }
}
contract z2 is x2{
    function z() public() {
        uint i = uint(uint(uint(x)) + uint(uint(uint(x)) + uint(uint
