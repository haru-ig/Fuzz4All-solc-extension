pragma solidity ^0.8.0;
 pragma experimental ABIEncoderV2   abstract contract I { function () external pure { } }
 contract D { string public x; }
 struct E { E e; E f; }
 contract C { bool public b; E public c; bool f; uint x; uint256 h; }

pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2   abstract contract I { function () external pure { } }
 contract D { string public x; }
 struct E { uint public a; mapping(address => uint) public b; }<fim_middle> contract D { string public x; }
 contract E164 { uint32 public a; mapping(bytes32 => uint) public b; }
 contract C { uint32 public a; E164.address b; bool c; bool d; bool e; uint f; uint64.byte8 h; }

pragma solidity ^0.8.0;
 uint max; assembly { max := 0xffffffff }
 contract E721 { uint value; function E721(uint value) { this.value = value; } fallback () { throw; } } contract F70x { enum Kind { A, B, C } event E(uint a, uint b); struct C { uint f; } function set(uint x) public { uint y; y = x; emit E(value + 1, value + 2); } function setKind(Kind kind) public { set((Kind((uint(kind + 1)) << 32) | (uint(kind) + 16) | 1)); } enum Z { X, Y, Z, T, U, V } enum Kind { X, Y, Z } struct D { uint[4] a; D(uint y) { a[0] = (y >> 0) | (y << 29); a[1] = (y >> 7) | (y << 21); a[2] = (y >> 14) | (y << 15); a[3] = (y >> 21) | (y << 4); } } function test() public { Kind kind; for (uint i = 0; i < 1000000; i++) kind = Kind(test2(kind, D(2<<32 - 1))); testKind(kind, kinds8[(uint(kind + 0) << 32) | (uint(kind + 16) | 0) << 14 + 0]); } function test2(Kind kind, D d) public pure returns (Kind kind2) {
