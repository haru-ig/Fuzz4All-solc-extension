pragma solidity ^0.8.0;
contract modifiedF {
  constructor () public {
    f(2432432);
    uint x;
    (x) = (x / 2);
  }
  uint256 f(_0) public returns(uint256) {
    while (1){
      if ((f_inner(243242) == 0 || (uint1)(f_inner(243242)!= 1 || (uint8)f_inner(243242)!= 0)) && (bool)(bool(uint8(1 / f_inner(0))))){
        uint q;
        if ((q = f_inner(243242)) == q) {
        } else {
          (uint8)f_inner(243242);
        }
        if (q & 1 == 0) {
          { return 0; }

        } else {
        }
      } else {
      }
    }
  }
  function f_inner(uint1 a) private pure returns (uint256){
   if (a == 2432432){
     return 0;
   }
   uint1 b=0;
   if ((bool)(bool((b & a)!= b & a))){
    if (a == 152232) {
      ;
    }
    return 0;
   }
   uint b=0;
   if ((b == b / 152232, ((bool)bool((b & a) == b & a)))) {
    if (!(a = b - 1).equals(a)) {
      ;
      return 1;
    }
   }
   if ((bool)(bool((b & a) == b & a))){
    return 1;
   }
   uint8 a=0;
   if (((b | a) % 2) > 0) {
      bytes memory z = new bytes(1);
      z[0] = "1";
      return b / 152232;
    }
    return 0;
  }
  function f2(uint8 a) public returns (uint1) {
    if( a % 34 > 5 ){
      uint1 y;
      if( a < 0) {
        if( a % 34 > 5 ) {
          y = 1 % 34;
        } else {
          y = 34;
        }
      } else {
        y = 1 % 34;
      }
    } else {
      uint1 y;
      if( a < 0) {
        if( a % 34 > 5 )
