pragma solidity ^0.8.0;
contract modifierA {
    function f() public pure returns(uint d){
        string a = "a";
        uint d = 2 * d;
        d = d + 1;
        return 0;
    }
    function g() public pure returns(uint e){
        uint a;
        function set(uint _a) public pure returns (uint a){
                a = _a;
                a = a / 2;
        }
    }
}
contract myContractA is modifierA
{
    function h() public view returns (uint){
        uint x;
        function func(uint _x) public view returns (uint _x) {
                func(_x);
                uint _x =1;
                _x = _x - y;
                uint _x = _x + 1;
        }
    }
}
contract noErrors
{
    uint f1;
}
contract myContract {
    noErrors noErrors1;
    noErrors.noErrors2 f2;
    modifierA mA(uint a) isM2
    {
        uint a1;
    }
    modifierA mB(bytes3 _bytes3, uint a, bool b) isM3 {
        noErrors.noErrors2 a1 = noErrors1.f2;
    }
    modifierC mC(bytes3 _bytes3, uint a, bool b) isM3 {
        uint a1;
        function func(uint _a1) private{
                a1 = _a1;
        }
    }
    modifierD mD(uint a, uint f) isM1;
    modifierE mE(uint a, uint c, uint b) isM1;
    modifierE mF (uint b, uint c) isM3();
    modifierE mG(uint a, uint d, uint c) {
        uint e;
        uint b;
        function z(uint _c){
                b = _c + 1;
        }
        func();
    }
    modifierE mH( uint a) isM2 {
        uint e;
    }
    modifier E() isM2 {
        uint e;
        uint a;
        uint b;
        uint _a;
    }
}
contract noError {
    function test (uint _a0) isM2{
    }
}
