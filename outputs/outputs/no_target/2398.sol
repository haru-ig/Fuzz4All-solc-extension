pragma solidity ^0.8.0;
library l { uint256 v1=0; uint256 v2=0; bytes b1 = ""; bytes b2 = ""; }
contract mutationv56704
{
    bytes a;
    bytes public b = new bytes(9);
    uint public c;
    uint public d = uint256x0(0);
    uint public e;
    l.v1 i;
    l.v1 public j;
    constructor(uint256 i_) public { i = l.v1(1); i = l.v1(5); i = l.v1(11); a = "hello"; c = 5; j = l.v1(10); }
    function f(uint256 j_) public pure { b[1] = "world"; b2[0] = 23; }
    function g() public pure returns (uint256 i_) { uint256 j = i; i = j + 5; i = i - 5; }
    function h() public pure { i = l.v1(2); c = 3; }
    function k() public pure { i = l.v1(4); i = l.v1(55); }
    function l() public pure { i = l.v1(6); }
    function m() public pure { address i; i = 22; for (i; i; i = l((address(this))[4])) { } }
    modifier k1() { uint256 _; _ = i; }
    function n12() public pure k1 returns (uint256) { uint256 _ = i; return _+5; }
    modifier n13() { uint256 _; _ = i; }
    function o14(uint256 l1) public pure n13 returns (uint256) { uint256 _ = l; if(l == 0) revert(); else return _; }
    function p14(uint256 l1) public pure n12 returns (uint256) { uint256 _ = l; if(l == 0) revert(); else return _; }
    function q15(uint256 l1) public pure n12 k1 returns (uint256) { uint256 _ = l; if(l == 0) revert(); else if (l == 1) then return c; else return _; }
    function r15(uint256 l1) public pure n11 returns (uint256) { uint256 _ = l; if
