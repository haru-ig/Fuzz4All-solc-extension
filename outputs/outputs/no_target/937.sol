pragma solidity ^0.8.0;
contract SemanticMutation6 {
    uint8 public x;
    function test0()
        public
        view
        returns (uint32){
        uint8 v;
        v >>= 1;
        uint32 y = x >>= v;

        uint32 z = v << x0;
        while (z!= v);
        uint32 z0 = v >> x00;
        uint32 z1 = v >> x10;
        x >>= 1;
        uint32 z2 = x0 >> x0;
        x <<= x;
        uint32 z3 = x0 << x00;

        uint32 y0 = y << 778;
        x >>= 1 << 25;
        assert (x < 1e18 < 1e9 == true && z == v);
        uint32 c = 255;
        uint32 s = uint32((1<<(c & 0x07fff)) - 1);
        uint32 y1 = s>>254+(c>>29)*(s>>28)/(s>>26);
        uint32 y2 = x>>254+(c>>31)*(s>>29)/(s>>27);
        uint32 y3 = c - 1;
        while ((y >= y2 && y <= y0) || ((y >= y1 && y < 1e18) || (y < 1e9 && y >= y3)));
        y = y << 1;
        z = x >> c && ~x;
        assert ((~(s >> 1) ^ y1) == ~z);
        x = x >> ~0x2586 && x || (~c ^ z) - s + s;
        x >> 0x2586 && c;
        assert ((x == 0x2586));
        assert(y > 1e17);
        while (y < x);
        uint32 s0 = y >> 78;
        uint32 s1 = ((x + 1) >> 3);
        uint32 s = (y + 2 + 2 * (s1 + (c >> s0) << s0))
