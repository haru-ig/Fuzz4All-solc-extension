pragma solidity ^0.8.0;
contract A {
  modifier m1() { A _a = A(this); if (a > 0) return;} }
contract B { address payable b;
    function f(uint256 a) public pure {emit log1(address(b));} function g(uint256 a) public pure {emit log2(address(b));} function h() public pure {emit log3(address(b));} modifier m2() {B _b = B(address(this)); a += 1; if (a == 1) return;} }
contract BC { A a; A _aa=A(address(this)); modifier m3() {BC _bc = BC(address(this)); a += 1; if (a == 1) return;} }
contract CA { A a; A _aa=A(address(this)); modifier m4() {CA _ca = CA(address(this)); a += 1; if (a == 1) return;} }
contract CB { A a; A _aa=A(address(this)); modifier m5() {CB _cb = CB(address(this)); a += 1; if (a == 1) return;} }
contract CCB { A a; A _aa=A(address(this)); modifier m6() { CCB _ccb = CCB(address(this)); a += 1; if (a == 1) return;} }
contract AB0 { function f(uint256 a) public pure {if (a!= 2) return;}
    function f2(uint256 a) public pure {if (a!= 2) return;} }
contract BC0 { A _aaa; modifier m0() {BC _bc = BC(address(this)); a += 1; if (a == 1) return;} }
contract AC { uint256 a; modifier m7() {AC _ac = AC(address(this)); a += 1; if (a == 1) return;} }
contract AD { A d; A _dd=A(address(this)); modifier m8() {AD _ad = AD(
