pragma solidity ^0.8.0;
contract Memory {}
contract Convert {}
contract Array {}
contract Multiprecision {}
contract Math {}
contract Array_ {
    uint[] p;
    function check_if_non_empty(address _addr) public {

    }
    function push_back_int(uint _i) public {
        p.push(_i);
    }
    function get_min_int() public {

    }
    function set_int_to_address(uint _i, address _addr) public {

    }
    function set_address_to_int(address _addr, uint _i) public {

    }
}
contract Convert_ {
    function to_address(uint _num) public pure returns (address) {

    }
}
contract Array {
    uint[0] p;
    function get_length() public constant returns (uint) {

    }
    function check_if_non_empty(uint _index) public constant returns (bool) {

    }
    function set_array(uint[] storage _addr) public{

    }
    function push_back_int(uint _i) public {
        p.push(_i);
    }
    function get_min_int() public {

    }
    function set_int_to_address(uint _i, address _addr) public {

    }
    function set_address_to_int(address _addr, uint _i) public {

    }
}
contract Multiprecision_ {
    uint[0] p;
    function add(uint x, uint y) public returns(int){

    }
    function mul(uint x, uint y) public returns(int) {

    }
    function div(uint x, uint y) public returns(int) {

    }
    function compare(uint x, uint y) public returns(int){

    }
}
