pragma solidity ^0.8.0;
contract G {
    function P(int32 d) public pure returns (int32) {
        uint256 a = uint8(4) % uint8((uint8(4) & -uint(uint256(uint8(8))) + uint8(8))));
        uint256 b = uint8(-3) - 1;
        int8 c = 224 % int8(uint8(42));
        uint256 d = int256(1) / 0x401;
        uint256 e;
        while (!int(int8(uint8(4))));
        bool f;
        uint a;
        if (true) {
            assembly {
                let c := a0
            }
        } else {
            assembly {
                c := a0
            }
        }
        uint8 g = bytes32(0x08) % uint8(1);
        uint8 h = bytes8(0xaa3f) + 1;
    }
    function Q(mapping(uint => uint8) y) public pure returns (uint8) {
        uint y = uint8(4) & 1;
        uint8 x = 1;
        uint8 b = 2;
        uint8 m;
        int8 c = true? -1 : 225;
        uint d = (bytes32(bytes8(0x0327) - 1) + uint(bytes8(0xbe)) * 0x4000) + (bytes32((bytes16(0x4111) % 0xbc00) + 0x1440) % bytes2);
        uint f;
        uint42 j = (bytes8(0x05) + uint(8)) % 1;
        uint8 m = (bytes32(bytes8(0x06) % bytes32) + uint8(1)) % 1 + bytes8(0x07) % 0x01;
        uint42 h;
        uint b = (bytes8(18) + uint8(s16(0x020)) * 0x4100) % 0xffa0000000000000000000000000000000000000000000000000001;
        uint8 p = bytes(bytes32(0x08) - 0x001) % (bytes8(0x0a) ^ 0x005);
        uint8 e = bytes(bytes() + 4) % bytes(20);
        {
            uint8 f;
            uint c;
            if (uint8(g)) {
                uint8 m;
                f8 = 1;
            } else {
                while (5) {}
            }
            uint48 q = uint.div(uint4
