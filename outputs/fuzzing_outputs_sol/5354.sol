pragma solidity ^0.8.0;
contract caller{
        mapmap x;
        uint y;
        address z;
        struct foo{
            address a;
            address b;
            uint c;
        }
        function h() public payable {
                z.transfer(msg.value);
                mapmap.f.value(0)(x,bytes1(3),"foo");
        }

        function foo(foo memory foo){
                foo.a;
                foo.b.transfer(msg.value);
        }

        receive() payable payable public {
                mapmap.g.value(0)( x,foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(foo(x,bytes1(5),"foo"))),bytes1(8),bytes1(9),"foo"))),bytes1(13),bytes1(14),"foo"))),bytes1(17),bytes1(18),"foo"))),bytes1(21),bytes1(22),"foo"))),bytes1(25),bytes1(26),"foo"))),bytes1(29),bytes1(30),"foo"));
        }

        function fallback() external payable {
        uint8 a = 25;
        struct foo{
            address a;
            address b;
            uint c;
        }
        foo memory f;
        address a;
        address b;
        a.delegatecall{value:msg.value}(abi.encodeWithSignature("f()",f));
        mapmap.h();
        }
}
