pragma solidity ^0.8.0;
contract SemanticEquivalentN2
{
  uint b;
  uint a;
  uint224 c;
  struct S1
  {
    uint field_b;
    uint field_a;
  }
  struct S2
  {
    uint field_b;
    uint256 field_a;
  }
  function __k2(
    uint a,
    bool b,
    uint256 c
  )
    public
    returns(
      uint8,
      uint16,
      uint64,
      uint128
    )
  {
    uint8 result = 1;
    uint16 result_2 = 2;
    uint64 result_3 = 3;
    uint128 result_4 = 4;
    while (true) {
      uint i2;
      uint8 j3;
      uint16 k3;
      uint64 l3;
      uint128 m3;
      uint128 m2;
      uint result_5;
      uint224 n3;
      uint224 o2;
      if (
        a > a
      ) {
        m2 = 0;
        i2 = 0;
        m3 = c;
        m2 = (a - 0) - 0;
        m1 = (m1 + 0);
      }
      for (uint8 2 = 0; 2 <= 4; 2 = 3 * 2) {
        ++result_5;
      }
    }
    do
    {
      uint128 v;
      uint x2;
      uint v2;
      uint x3;
      uint v3;
      if (a > a) {
        v2 = c;
      }
      else {
        v3 = v;
      }
    } while (true);
    while (a > a)
    {
      uint i2;
      uint224 n3;
      uint224 o2;
      if (a > b) {
        m3 = i;
        m3 = h;
        for (uint16 2 = 0; 2 <= 1; 2 = 3 * 2) {
          uint v4;
          uint v5;
          uint x5;
          uint x4;
          uint y3;
          uint x2;
          uint x7;
          uint v6;
          uint x6;
          uint x8;
          uint v7;
          uint v8;
          uint v9;
          uint v10;
          if (b > b) {
            v8 = i2;
            v9 = (m2 * 1) - x2;
            for (uint224 2 = 0; 2 <= 1; 2 = 3 * 2) {
              uint a1;
              uint a2;
              if (a > b) {
                a1 = i2 / (a + b);
                a2 = 0;
