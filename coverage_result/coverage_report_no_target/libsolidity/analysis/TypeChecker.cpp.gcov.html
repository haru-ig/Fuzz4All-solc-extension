<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - final_coverage.info - libsolidity/analysis/TypeChecker.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">libsolidity/analysis</a> - TypeChecker.cpp<span style="font-size: 80%;"> (source / <a href="TypeChecker.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">final_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1453</td>
            <td class="headerCovTableEntry">2301</td>
            <td class="headerCovTableEntryLo">63.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2025-01-30 08:02:31</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">60</td>
            <td class="headerCovTableEntry">69</td>
            <td class="headerCovTableEntryMed">87.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<a name="2"><span class="lineNum">       2 </span>            :         This file is part of solidity.</a>
<a name="3"><span class="lineNum">       3 </span>            : </a>
<a name="4"><span class="lineNum">       4 </span>            :         solidity is free software: you can redistribute it and/or modify</a>
<a name="5"><span class="lineNum">       5 </span>            :         it under the terms of the GNU General Public License as published by</a>
<a name="6"><span class="lineNum">       6 </span>            :         the Free Software Foundation, either version 3 of the License, or</a>
<a name="7"><span class="lineNum">       7 </span>            :         (at your option) any later version.</a>
<a name="8"><span class="lineNum">       8 </span>            : </a>
<a name="9"><span class="lineNum">       9 </span>            :         solidity is distributed in the hope that it will be useful,</a>
<a name="10"><span class="lineNum">      10 </span>            :         but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="11"><span class="lineNum">      11 </span>            :         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="12"><span class="lineNum">      12 </span>            :         GNU General Public License for more details.</a>
<a name="13"><span class="lineNum">      13 </span>            : </a>
<a name="14"><span class="lineNum">      14 </span>            :         You should have received a copy of the GNU General Public License</a>
<a name="15"><span class="lineNum">      15 </span>            :         along with solidity.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="16"><span class="lineNum">      16 </span>            : */</a>
<a name="17"><span class="lineNum">      17 </span>            : // SPDX-License-Identifier: GPL-3.0</a>
<a name="18"><span class="lineNum">      18 </span>            : /**</a>
<a name="19"><span class="lineNum">      19 </span>            :  * @author Christian &lt;c@ethdev.com&gt;</a>
<a name="20"><span class="lineNum">      20 </span>            :  * @date 2015</a>
<a name="21"><span class="lineNum">      21 </span>            :  * Type analyzer and checker.</a>
<a name="22"><span class="lineNum">      22 </span>            :  */</a>
<a name="23"><span class="lineNum">      23 </span>            : </a>
<a name="24"><span class="lineNum">      24 </span>            : #include &lt;libsolidity/analysis/TypeChecker.h&gt;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &lt;libsolidity/ast/AST.h&gt;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &lt;libsolidity/ast/ASTUtils.h&gt;</a>
<a name="27"><span class="lineNum">      27 </span>            : #include &lt;libsolidity/ast/UserDefinableOperators.h&gt;</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &lt;libsolidity/ast/TypeProvider.h&gt;</a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span>            : #include &lt;libyul/AsmAnalysis.h&gt;</a>
<a name="31"><span class="lineNum">      31 </span>            : #include &lt;libyul/AsmAnalysisInfo.h&gt;</a>
<a name="32"><span class="lineNum">      32 </span>            : #include &lt;libyul/AST.h&gt;</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : #include &lt;liblangutil/ErrorReporter.h&gt;</a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            : #include &lt;libsolutil/Algorithms.h&gt;</a>
<a name="37"><span class="lineNum">      37 </span>            : #include &lt;libsolutil/StringUtils.h&gt;</a>
<a name="38"><span class="lineNum">      38 </span>            : #include &lt;libsolutil/Views.h&gt;</a>
<a name="39"><span class="lineNum">      39 </span>            : #include &lt;libsolutil/Visitor.h&gt;</a>
<a name="40"><span class="lineNum">      40 </span>            : </a>
<a name="41"><span class="lineNum">      41 </span>            : #include &lt;boost/algorithm/string/join.hpp&gt;</a>
<a name="42"><span class="lineNum">      42 </span>            : #include &lt;boost/algorithm/string/predicate.hpp&gt;</a>
<a name="43"><span class="lineNum">      43 </span>            : </a>
<a name="44"><span class="lineNum">      44 </span>            : #include &lt;fmt/format.h&gt;</a>
<a name="45"><span class="lineNum">      45 </span>            : </a>
<a name="46"><span class="lineNum">      46 </span>            : #include &lt;range/v3/algorithm/count_if.hpp&gt;</a>
<a name="47"><span class="lineNum">      47 </span>            : #include &lt;range/v3/view/drop_exactly.hpp&gt;</a>
<a name="48"><span class="lineNum">      48 </span>            : #include &lt;range/v3/view/enumerate.hpp&gt;</a>
<a name="49"><span class="lineNum">      49 </span>            : #include &lt;range/v3/view/zip.hpp&gt;</a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : #include &lt;memory&gt;</a>
<a name="52"><span class="lineNum">      52 </span>            : #include &lt;vector&gt;</a>
<a name="53"><span class="lineNum">      53 </span>            : </a>
<a name="54"><span class="lineNum">      54 </span>            : using namespace solidity;</a>
<a name="55"><span class="lineNum">      55 </span>            : using namespace solidity::util;</a>
<a name="56"><span class="lineNum">      56 </span>            : using namespace solidity::langutil;</a>
<a name="57"><span class="lineNum">      57 </span>            : using namespace solidity::frontend;</a>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<a name="59"><span class="lineNum">      59 </span><span class="lineCov">         38 : bool TypeChecker::typeSupportedByOldABIEncoder(Type const&amp; _type, bool _isLibraryCall)</span></a>
<a name="60"><span class="lineNum">      60 </span>            : {</a>
<a name="61"><span class="lineNum">      61 </span><span class="lineCov">         38 :         if (_isLibraryCall &amp;&amp; _type.dataStoredIn(DataLocation::Storage))</span></a>
<a name="62"><span class="lineNum">      62 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="63"><span class="lineNum">      63 </span><span class="lineCov">         38 :         if (_type.category() == Type::Category::Struct)</span></a>
<a name="64"><span class="lineNum">      64 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="65"><span class="lineNum">      65 </span><span class="lineCov">         38 :         if (_type.category() == Type::Category::Array)</span></a>
<a name="66"><span class="lineNum">      66 </span>            :         {</a>
<a name="67"><span class="lineNum">      67 </span><span class="lineCov">          5 :                 auto const&amp; arrayType = dynamic_cast&lt;ArrayType const&amp;&gt;(_type);</span></a>
<a name="68"><span class="lineNum">      68 </span><span class="lineCov">          5 :                 auto base = arrayType.baseType();</span></a>
<a name="69"><span class="lineNum">      69 </span><span class="lineCov">          5 :                 if (!typeSupportedByOldABIEncoder(*base, _isLibraryCall) || (base-&gt;category() == Type::Category::Array &amp;&amp; base-&gt;isDynamicallySized()))</span></a>
<a name="70"><span class="lineNum">      70 </span><span class="lineNoCov">          0 :                         return false;</span></a>
<a name="71"><span class="lineNum">      71 </span>            :         }</a>
<a name="72"><span class="lineNum">      72 </span><span class="lineCov">         38 :         return true;</span></a>
<a name="73"><span class="lineNum">      73 </span>            : }</a>
<a name="74"><span class="lineNum">      74 </span>            : </a>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">       5415 : bool TypeChecker::checkTypeRequirements(SourceUnit const&amp; _source)</span></a>
<a name="76"><span class="lineNum">      76 </span>            : {</a>
<a name="77"><span class="lineNum">      77 </span><span class="lineCov">       5415 :         m_currentSourceUnit = &amp;_source;</span></a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">       5415 :         _source.accept(*this);</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">       5196 :         m_currentSourceUnit = nullptr;</span></a>
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">       5196 :         return !Error::containsErrors(m_errorReporter.errors());</span></a>
<a name="81"><span class="lineNum">      81 </span>            : }</a>
<a name="82"><span class="lineNum">      82 </span>            : </a>
<a name="83"><span class="lineNum">      83 </span><span class="lineCov">       7971 : bool TypeChecker::visit(ContractDefinition const&amp; _contract)</span></a>
<a name="84"><span class="lineNum">      84 </span>            : {</a>
<a name="85"><span class="lineNum">      85 </span><span class="lineCov">       7971 :         m_currentContract = &amp;_contract;</span></a>
<a name="86"><span class="lineNum">      86 </span>            : </a>
<a name="87"><span class="lineNum">      87 </span><span class="lineCov">       7971 :         ASTNode::listAccept(_contract.baseContracts(), *this);</span></a>
<a name="88"><span class="lineNum">      88 </span>            : </a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">      24728 :         for (auto const&amp; n: _contract.subNodes())</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineCov">      16976 :                 n-&gt;accept(*this);</span></a>
<a name="91"><span class="lineNum">      91 </span>            : </a>
<a name="92"><span class="lineNum">      92 </span><span class="lineCov">       7752 :         m_currentContract = nullptr;</span></a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">       7752 :         return false;</span></a>
<a name="95"><span class="lineNum">      95 </span>            : }</a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">          4 : TypePointers TypeChecker::typeCheckABIDecodeAndRetrieveReturnType(FunctionCall const&amp; _functionCall, bool _abiEncoderV2)</span></a>
<a name="98"><span class="lineNum">      98 </span>            : {</a>
<a name="99"><span class="lineNum">      99 </span><span class="lineCov">          8 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; arguments = _functionCall.arguments();</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineCov">          4 :         if (arguments.size() != 2)</span></a>
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="102"><span class="lineNum">     102 </span>            :                         5782_error,</a>
<a name="103"><span class="lineNum">     103 </span><span class="lineNoCov">          0 :                         _functionCall.location(),</span></a>
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 :                         &quot;This function takes two arguments, but &quot; +</span></a>
<a name="105"><span class="lineNum">     105 </span><span class="lineNoCov">          0 :                         toString(arguments.size()) +</span></a>
<a name="106"><span class="lineNum">     106 </span>            :                         &quot; were provided.&quot;</a>
<a name="107"><span class="lineNum">     107 </span>            :                 );</a>
<a name="108"><span class="lineNum">     108 </span>            : </a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">          4 :         if (arguments.size() &gt;= 1)</span></a>
<a name="110"><span class="lineNum">     110 </span><span class="lineCov">          4 :                 if (</span></a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">          8 :                         !type(*arguments.front())-&gt;isImplicitlyConvertibleTo(*TypeProvider::bytesMemory()) &amp;&amp;</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineCov">          4 :                         !type(*arguments.front())-&gt;isImplicitlyConvertibleTo(*TypeProvider::bytesCalldata())</span></a>
<a name="113"><span class="lineNum">     113 </span>            :                 )</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="115"><span class="lineNum">     115 </span>            :                                 1956_error,</a>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 :                                 arguments.front()-&gt;location(),</span></a>
<a name="117"><span class="lineNum">     117 </span>            :                                 &quot;The first argument to \&quot;abi.decode\&quot; must be implicitly convertible to &quot;</a>
<a name="118"><span class="lineNum">     118 </span><span class="lineNoCov">          0 :                                 &quot;bytes memory or bytes calldata, but is of type &quot; +</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :                                 type(*arguments.front())-&gt;humanReadableName() +</span></a>
<a name="120"><span class="lineNum">     120 </span>            :                                 &quot;.&quot;</a>
<a name="121"><span class="lineNum">     121 </span>            :                         );</a>
<a name="122"><span class="lineNum">     122 </span>            : </a>
<a name="123"><span class="lineNum">     123 </span><span class="lineCov">          4 :         if (arguments.size() &lt; 2)</span></a>
<a name="124"><span class="lineNum">     124 </span><span class="lineNoCov">          0 :                 return {};</span></a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            :         // The following is a rather syntactic restriction, but we check it here anyway:</a>
<a name="127"><span class="lineNum">     127 </span>            :         // The second argument has to be a tuple expression containing type names.</a>
<a name="128"><span class="lineNum">     128 </span><span class="lineCov">          4 :         TupleExpression const* tupleExpression = dynamic_cast&lt;TupleExpression const*&gt;(arguments[1].get());</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineCov">          4 :         if (!tupleExpression)</span></a>
<a name="130"><span class="lineNum">     130 </span>            :         {</a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="132"><span class="lineNum">     132 </span>            :                         6444_error,</a>
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :                         arguments[1]-&gt;location(),</span></a>
<a name="134"><span class="lineNum">     134 </span>            :                         &quot;The second argument to \&quot;abi.decode\&quot; has to be a tuple of types.&quot;</a>
<a name="135"><span class="lineNum">     135 </span>            :                 );</a>
<a name="136"><span class="lineNum">     136 </span><span class="lineNoCov">          0 :                 return {};</span></a>
<a name="137"><span class="lineNum">     137 </span>            :         }</a>
<a name="138"><span class="lineNum">     138 </span>            : </a>
<a name="139"><span class="lineNum">     139 </span><span class="lineCov">          8 :         TypePointers components;</span></a>
<a name="140"><span class="lineNum">     140 </span><span class="lineCov">         13 :         for (auto const&amp; typeArgument: tupleExpression-&gt;components())</span></a>
<a name="141"><span class="lineNum">     141 </span>            :         {</a>
<a name="142"><span class="lineNum">     142 </span><span class="lineCov">          9 :                 solAssert(typeArgument, &quot;&quot;);</span></a>
<a name="143"><span class="lineNum">     143 </span><span class="lineCov">          9 :                 if (TypeType const* argTypeType = dynamic_cast&lt;TypeType const*&gt;(type(*typeArgument)))</span></a>
<a name="144"><span class="lineNum">     144 </span>            :                 {</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">          9 :                         Type const* actualType = argTypeType-&gt;actualType();</span></a>
<a name="146"><span class="lineNum">     146 </span><span class="lineCov">          9 :                         solAssert(actualType, &quot;&quot;);</span></a>
<a name="147"><span class="lineNum">     147 </span>            :                         // We force memory because the parser currently cannot handle</a>
<a name="148"><span class="lineNum">     148 </span>            :                         // data locations. Furthermore, storage can be a little dangerous and</a>
<a name="149"><span class="lineNum">     149 </span>            :                         // calldata is not really implemented anyway.</a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">          9 :                         actualType = TypeProvider::withLocationIfReference(DataLocation::Memory, actualType);</span></a>
<a name="151"><span class="lineNum">     151 </span>            :                         // We force address payable for address types.</a>
<a name="152"><span class="lineNum">     152 </span><span class="lineCov">          9 :                         if (actualType-&gt;category() == Type::Category::Address)</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :                                 actualType = TypeProvider::payableAddress();</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineCov">          9 :                         solAssert(</span></a>
<a name="155"><span class="lineNum">     155 </span>            :                                 !actualType-&gt;dataStoredIn(DataLocation::CallData) &amp;&amp;</a>
<a name="156"><span class="lineNum">     156 </span>            :                                 !actualType-&gt;dataStoredIn(DataLocation::Storage),</a>
<a name="157"><span class="lineNum">     157 </span>            :                                 &quot;&quot;</a>
<a name="158"><span class="lineNum">     158 </span>            :                         );</a>
<a name="159"><span class="lineNum">     159 </span><span class="lineCov">          9 :                         if (!actualType-&gt;fullEncodingType(false, _abiEncoderV2, false))</span></a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="161"><span class="lineNum">     161 </span>            :                                         9611_error,</a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :                                         typeArgument-&gt;location(),</span></a>
<a name="163"><span class="lineNum">     163 </span><span class="lineNoCov">          0 :                                         &quot;Decoding type &quot; + actualType-&gt;humanReadableName() + &quot; not supported.&quot;</span></a>
<a name="164"><span class="lineNum">     164 </span>            :                                 );</a>
<a name="165"><span class="lineNum">     165 </span>            : </a>
<a name="166"><span class="lineNum">     166 </span><span class="lineCov">          9 :                         if (auto referenceType = dynamic_cast&lt;ReferenceType const*&gt;(actualType))</span></a>
<a name="167"><span class="lineNum">     167 </span>            :                         {</a>
<a name="168"><span class="lineNum">     168 </span><span class="lineNoCov">          0 :                                 auto result = referenceType-&gt;validForLocation(referenceType-&gt;location());</span></a>
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :                                 if (!result)</span></a>
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="171"><span class="lineNum">     171 </span>            :                                                 6118_error,</a>
<a name="172"><span class="lineNum">     172 </span><span class="lineNoCov">          0 :                                                 typeArgument-&gt;location(),</span></a>
<a name="173"><span class="lineNum">     173 </span>            :                                                 result.message()</a>
<a name="174"><span class="lineNum">     174 </span>            :                                         );</a>
<a name="175"><span class="lineNum">     175 </span>            :                         }</a>
<a name="176"><span class="lineNum">     176 </span>            : </a>
<a name="177"><span class="lineNum">     177 </span><span class="lineCov">          9 :                         components.push_back(actualType);</span></a>
<a name="178"><span class="lineNum">     178 </span>            :                 }</a>
<a name="179"><span class="lineNum">     179 </span>            :                 else</a>
<a name="180"><span class="lineNum">     180 </span>            :                 {</a>
<a name="181"><span class="lineNum">     181 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(1039_error, typeArgument-&gt;location(), &quot;Argument has to be a type name.&quot;);</span></a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 :                         components.push_back(TypeProvider::emptyTuple());</span></a>
<a name="183"><span class="lineNum">     183 </span>            :                 }</a>
<a name="184"><span class="lineNum">     184 </span>            :         }</a>
<a name="185"><span class="lineNum">     185 </span><span class="lineCov">          4 :         return components;</span></a>
<a name="186"><span class="lineNum">     186 </span>            : }</a>
<a name="187"><span class="lineNum">     187 </span>            : </a>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">         27 : TypePointers TypeChecker::typeCheckMetaTypeFunctionAndRetrieveReturnType(FunctionCall const&amp; _functionCall)</span></a>
<a name="189"><span class="lineNum">     189 </span>            : {</a>
<a name="190"><span class="lineNum">     190 </span><span class="lineCov">         29 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; arguments = _functionCall.arguments();</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineCov">         27 :         if (arguments.size() != 1)</span></a>
<a name="192"><span class="lineNum">     192 </span><span class="lineNoCov">          0 :                 m_errorReporter.fatalTypeError(</span></a>
<a name="193"><span class="lineNum">     193 </span>            :                         8885_error,</a>
<a name="194"><span class="lineNum">     194 </span><span class="lineNoCov">          0 :                         _functionCall.location(),</span></a>
<a name="195"><span class="lineNum">     195 </span><span class="lineNoCov">          0 :                         &quot;This function takes one argument, but &quot; +</span></a>
<a name="196"><span class="lineNum">     196 </span><span class="lineNoCov">          0 :                         toString(arguments.size()) +</span></a>
<a name="197"><span class="lineNum">     197 </span>            :                         &quot; were provided.&quot;</a>
<a name="198"><span class="lineNum">     198 </span>            :                 );</a>
<a name="199"><span class="lineNum">     199 </span><span class="lineCov">         27 :         Type const* firstArgType = type(*arguments.front());</span></a>
<a name="200"><span class="lineNum">     200 </span>            : </a>
<a name="201"><span class="lineNum">     201 </span><span class="lineCov">         27 :         bool wrongType = false;</span></a>
<a name="202"><span class="lineNum">     202 </span><span class="lineCov">         27 :         if (firstArgType-&gt;category() == Type::Category::TypeType)</span></a>
<a name="203"><span class="lineNum">     203 </span>            :         {</a>
<a name="204"><span class="lineNum">     204 </span><span class="lineCov">         26 :                 TypeType const* typeTypePtr = dynamic_cast&lt;TypeType const*&gt;(firstArgType);</span></a>
<a name="205"><span class="lineNum">     205 </span><span class="lineCov">         26 :                 Type::Category typeCategory = typeTypePtr-&gt;actualType()-&gt;category();</span></a>
<a name="206"><span class="lineNum">     206 </span><span class="lineCov">         26 :                 if (auto const* contractType = dynamic_cast&lt;ContractType const*&gt;(typeTypePtr-&gt;actualType()))</span></a>
<a name="207"><span class="lineNum">     207 </span><span class="lineNoCov">          0 :                         wrongType = contractType-&gt;isSuper();</span></a>
<a name="208"><span class="lineNum">     208 </span><span class="lineCov">         26 :                 else if (</span></a>
<a name="209"><span class="lineNum">     209 </span><span class="lineCov">          1 :                         typeCategory != Type::Category::Integer &amp;&amp;</span></a>
<a name="210"><span class="lineNum">     210 </span>            :                         typeCategory != Type::Category::Enum</a>
<a name="211"><span class="lineNum">     211 </span>            :                 )</a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">          1 :                         wrongType = true;</span></a>
<a name="213"><span class="lineNum">     213 </span>            :         }</a>
<a name="214"><span class="lineNum">     214 </span>            :         else</a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">          1 :                 wrongType = true;</span></a>
<a name="216"><span class="lineNum">     216 </span>            : </a>
<a name="217"><span class="lineNum">     217 </span><span class="lineCov">         27 :         if (wrongType)</span></a>
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">          2 :                 m_errorReporter.fatalTypeError(</span></a>
<a name="219"><span class="lineNum">     219 </span>            :                         4259_error,</a>
<a name="220"><span class="lineNum">     220 </span><span class="lineCov">          2 :                         arguments.front()-&gt;location(),</span></a>
<a name="221"><span class="lineNum">     221 </span>            :                         &quot;Invalid type for argument in the function call. &quot;</a>
<a name="222"><span class="lineNum">     222 </span><span class="lineCov">          6 :                         &quot;An enum type, contract type or an integer type is required, but &quot; +</span></a>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">         12 :                         type(*arguments.front())-&gt;humanReadableName() + &quot; provided.&quot;</span></a>
<a name="224"><span class="lineNum">     224 </span>            :                 );</a>
<a name="225"><span class="lineNum">     225 </span>            : </a>
<a name="226"><span class="lineNum">     226 </span><span class="lineCov">         50 :         return {TypeProvider::meta(dynamic_cast&lt;TypeType const&amp;&gt;(*firstArgType).actualType())};</span></a>
<a name="227"><span class="lineNum">     227 </span>            : }</a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span><span class="lineNoCov">          0 : bool TypeChecker::visit(ImportDirective const&amp;)</span></a>
<a name="230"><span class="lineNum">     230 </span>            : {</a>
<a name="231"><span class="lineNum">     231 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="232"><span class="lineNum">     232 </span>            : }</a>
<a name="233"><span class="lineNum">     233 </span>            : </a>
<a name="234"><span class="lineNum">     234 </span><span class="lineCov">        330 : void TypeChecker::endVisit(InheritanceSpecifier const&amp; _inheritance)</span></a>
<a name="235"><span class="lineNum">     235 </span>            : {</a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">        330 :         auto base = dynamic_cast&lt;ContractDefinition const*&gt;(&amp;dereference(_inheritance.name()));</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">        330 :         solAssert(base, &quot;Base contract not available.&quot;);</span></a>
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">        330 :         solAssert(m_currentContract, &quot;&quot;);</span></a>
<a name="239"><span class="lineNum">     239 </span>            : </a>
<a name="240"><span class="lineNum">     240 </span><span class="lineCov">        330 :         if (m_currentContract-&gt;isInterface() &amp;&amp; !base-&gt;isInterface())</span></a>
<a name="241"><span class="lineNum">     241 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(6536_error, _inheritance.location(), &quot;Interfaces can only inherit from other interfaces.&quot;);</span></a>
<a name="242"><span class="lineNum">     242 </span>            : </a>
<a name="243"><span class="lineNum">     243 </span><span class="lineCov">        330 :         auto const&amp; arguments = _inheritance.arguments();</span></a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">        660 :         TypePointers parameterTypes;</span></a>
<a name="245"><span class="lineNum">     245 </span><span class="lineCov">        330 :         if (!base-&gt;isInterface())</span></a>
<a name="246"><span class="lineNum">     246 </span>            :                 // Interfaces do not have constructors, so there are zero parameters.</a>
<a name="247"><span class="lineNum">     247 </span><span class="lineCov">        313 :                 parameterTypes = ContractType(*base).newExpressionType()-&gt;parameterTypes();</span></a>
<a name="248"><span class="lineNum">     248 </span>            : </a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">        330 :         if (arguments)</span></a>
<a name="250"><span class="lineNum">     250 </span>            :         {</a>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :                 if (parameterTypes.size() != arguments-&gt;size())</span></a>
<a name="252"><span class="lineNum">     252 </span>            :                 {</a>
<a name="253"><span class="lineNum">     253 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="254"><span class="lineNum">     254 </span>            :                                 7927_error,</a>
<a name="255"><span class="lineNum">     255 </span><span class="lineNoCov">          0 :                                 _inheritance.location(),</span></a>
<a name="256"><span class="lineNum">     256 </span><span class="lineNoCov">          0 :                                 &quot;Wrong argument count for constructor call: &quot; +</span></a>
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 :                                 toString(arguments-&gt;size()) +</span></a>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :                                 &quot; arguments given but expected &quot; +</span></a>
<a name="259"><span class="lineNum">     259 </span><span class="lineNoCov">          0 :                                 toString(parameterTypes.size()) +</span></a>
<a name="260"><span class="lineNum">     260 </span><span class="lineNoCov">          0 :                                 (arguments-&gt;size() == 0 ? &quot;. Remove parentheses if you do not want to provide arguments here.&quot; : &quot;&quot;)</span></a>
<a name="261"><span class="lineNum">     261 </span>            :                         );</a>
<a name="262"><span class="lineNum">     262 </span>            :                 }</a>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :                 for (size_t i = 0; i &lt; std::min(arguments-&gt;size(), parameterTypes.size()); ++i)</span></a>
<a name="264"><span class="lineNum">     264 </span>            :                 {</a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 :                         BoolResult result = type(*(*arguments)[i])-&gt;isImplicitlyConvertibleTo(*parameterTypes[i]);</span></a>
<a name="266"><span class="lineNum">     266 </span><span class="lineNoCov">          0 :                         if (!result)</span></a>
<a name="267"><span class="lineNum">     267 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="268"><span class="lineNum">     268 </span>            :                                         9827_error,</a>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 :                                         (*arguments)[i]-&gt;location(),</span></a>
<a name="270"><span class="lineNum">     270 </span>            :                                         &quot;Invalid type for argument in constructor call. &quot;</a>
<a name="271"><span class="lineNum">     271 </span><span class="lineNoCov">          0 :                                         &quot;Invalid implicit conversion from &quot; +</span></a>
<a name="272"><span class="lineNum">     272 </span><span class="lineNoCov">          0 :                                         type(*(*arguments)[i])-&gt;humanReadableName() +</span></a>
<a name="273"><span class="lineNum">     273 </span><span class="lineNoCov">          0 :                                         &quot; to &quot; +</span></a>
<a name="274"><span class="lineNum">     274 </span><span class="lineNoCov">          0 :                                         parameterTypes[i]-&gt;humanReadableName() +</span></a>
<a name="275"><span class="lineNum">     275 </span>            :                                         &quot; requested.&quot;,</a>
<a name="276"><span class="lineNum">     276 </span><span class="lineNoCov">          0 :                                         result.message()</span></a>
<a name="277"><span class="lineNum">     277 </span>            :                                 );</a>
<a name="278"><span class="lineNum">     278 </span>            :                 }</a>
<a name="279"><span class="lineNum">     279 </span>            :         }</a>
<a name="280"><span class="lineNum">     280 </span><span class="lineCov">        330 : }</span></a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span><span class="lineCov">        182 : void TypeChecker::endVisit(ModifierDefinition const&amp; _modifier)</span></a>
<a name="283"><span class="lineNum">     283 </span>            : {</a>
<a name="284"><span class="lineNum">     284 </span><span class="lineCov">        182 :         if (auto const* contractDef = dynamic_cast&lt;ContractDefinition const*&gt;(_modifier.scope()))</span></a>
<a name="285"><span class="lineNum">     285 </span>            :         {</a>
<a name="286"><span class="lineNum">     286 </span><span class="lineCov">        182 :                 if (_modifier.virtualSemantics() &amp;&amp; contractDef-&gt;isLibrary())</span></a>
<a name="287"><span class="lineNum">     287 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="288"><span class="lineNum">     288 </span>            :                                 3275_error,</a>
<a name="289"><span class="lineNum">     289 </span><span class="lineNoCov">          0 :                                 _modifier.location(),</span></a>
<a name="290"><span class="lineNum">     290 </span>            :                                 &quot;Modifiers in a library cannot be virtual.&quot;</a>
<a name="291"><span class="lineNum">     291 </span>            :                         );</a>
<a name="292"><span class="lineNum">     292 </span>            : </a>
<a name="293"><span class="lineNum">     293 </span><span class="lineCov">        182 :                 if (contractDef-&gt;isInterface())</span></a>
<a name="294"><span class="lineNum">     294 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="295"><span class="lineNum">     295 </span>            :                                 6408_error,</a>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :                                 _modifier.location(),</span></a>
<a name="297"><span class="lineNum">     297 </span>            :                                 &quot;Modifiers cannot be defined or declared in interfaces.&quot;</a>
<a name="298"><span class="lineNum">     298 </span>            :                         );</a>
<a name="299"><span class="lineNum">     299 </span>            :         }</a>
<a name="300"><span class="lineNum">     300 </span>            : </a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">        182 :         if (!_modifier.isImplemented() &amp;&amp; !_modifier.virtualSemantics())</span></a>
<a name="302"><span class="lineNum">     302 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(8063_error, _modifier.location(), &quot;Modifiers without implementation must be marked virtual.&quot;);</span></a>
<a name="303"><span class="lineNum">     303 </span><span class="lineCov">        182 : }</span></a>
<a name="304"><span class="lineNum">     304 </span>            : </a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">       8964 : bool TypeChecker::visit(FunctionDefinition const&amp; _function)</span></a>
<a name="306"><span class="lineNum">     306 </span>            : {</a>
<a name="307"><span class="lineNum">     307 </span><span class="lineCov">       8964 :         if (_function.markedVirtual())</span></a>
<a name="308"><span class="lineNum">     308 </span>            :         {</a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">         69 :                 if (_function.isFree())</span></a>
<a name="310"><span class="lineNum">     310 </span><span class="lineNoCov">          0 :                         m_errorReporter.syntaxError(4493_error, _function.location(), &quot;Free functions cannot be virtual.&quot;);</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">         69 :                 else if (_function.isConstructor())</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(7001_error, _function.location(), &quot;Constructors cannot be virtual.&quot;);</span></a>
<a name="313"><span class="lineNum">     313 </span><span class="lineCov">         69 :                 else if (_function.annotation().contract-&gt;isInterface())</span></a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">         12 :                         m_errorReporter.warning(5815_error, _function.location(), &quot;Interface functions are implicitly \&quot;virtual\&quot;&quot;);</span></a>
<a name="315"><span class="lineNum">     315 </span><span class="lineCov">         57 :                 else if (_function.visibility() == Visibility::Private)</span></a>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(3942_error, _function.location(), &quot;\&quot;virtual\&quot; and \&quot;private\&quot; cannot be used together.&quot;);</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineCov">         57 :                 else if (_function.libraryFunction())</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">          4 :                         m_errorReporter.typeError(7801_error, _function.location(), &quot;Library functions cannot be \&quot;virtual\&quot;.&quot;);</span></a>
<a name="319"><span class="lineNum">     319 </span>            :         }</a>
<a name="320"><span class="lineNum">     320 </span><span class="lineCov">       8964 :         if (_function.overrides() &amp;&amp; _function.isFree())</span></a>
<a name="321"><span class="lineNum">     321 </span><span class="lineNoCov">          0 :                 m_errorReporter.syntaxError(1750_error, _function.location(), &quot;Free functions cannot override.&quot;);</span></a>
<a name="322"><span class="lineNum">     322 </span>            : </a>
<a name="323"><span class="lineNum">     323 </span><span class="lineCov">       8964 :         if (!_function.modifiers().empty() &amp;&amp; _function.isFree())</span></a>
<a name="324"><span class="lineNum">     324 </span><span class="lineNoCov">          0 :                 m_errorReporter.syntaxError(5811_error, _function.location(), &quot;Free functions cannot have modifiers.&quot;);</span></a>
<a name="325"><span class="lineNum">     325 </span>            : </a>
<a name="326"><span class="lineNum">     326 </span><span class="lineCov">       8964 :         if (_function.isPayable())</span></a>
<a name="327"><span class="lineNum">     327 </span>            :         {</a>
<a name="328"><span class="lineNum">     328 </span><span class="lineCov">        131 :                 if (_function.libraryFunction())</span></a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(7708_error, _function.location(), &quot;Library functions cannot be payable.&quot;);</span></a>
<a name="330"><span class="lineNum">     330 </span><span class="lineCov">        131 :                 else if (_function.isFree())</span></a>
<a name="331"><span class="lineNum">     331 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(9559_error, _function.location(), &quot;Free functions cannot be payable.&quot;);</span></a>
<a name="332"><span class="lineNum">     332 </span><span class="lineCov">        131 :                 else if (_function.isOrdinary() &amp;&amp; !_function.isPartOfExternalInterface())</span></a>
<a name="333"><span class="lineNum">     333 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(5587_error, _function.location(), &quot;\&quot;internal\&quot; and \&quot;private\&quot; functions cannot be payable.&quot;);</span></a>
<a name="334"><span class="lineNum">     334 </span>            :         }</a>
<a name="335"><span class="lineNum">     335 </span>            : </a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">      17928 :         std::vector&lt;VariableDeclaration const*&gt; internalParametersInConstructor;</span></a>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<a name="338"><span class="lineNum">     338 </span><span class="lineCov">       9433 :         auto checkArgumentAndReturnParameter = [&amp;](VariableDeclaration const&amp; _var) {</span></a>
<a name="339"><span class="lineNum">     339 </span><span class="lineCov">       9433 :                 if (type(_var)-&gt;containsNestedMapping())</span></a>
<a name="340"><span class="lineNum">     340 </span><span class="lineNoCov">          0 :                         if (_var.referenceLocation() == VariableDeclaration::Location::Storage)</span></a>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :                                 solAssert(</span></a>
<a name="342"><span class="lineNum">     342 </span>            :                                         _function.libraryFunction() || _function.isConstructor() || !_function.isPublic(),</a>
<a name="343"><span class="lineNum">     343 </span>            :                                         &quot;Mapping types for parameters or return variables &quot;</a>
<a name="344"><span class="lineNum">     344 </span>            :                                         &quot;can only be used in internal or library functions.&quot;</a>
<a name="345"><span class="lineNum">     345 </span>            :                                 );</a>
<a name="346"><span class="lineNum">     346 </span>            :                 bool functionIsExternallyVisible =</a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">      12001 :                         (!_function.isConstructor() &amp;&amp; _function.isPublic()) ||</span></a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">       2568 :                         (_function.isConstructor() &amp;&amp; !m_currentContract-&gt;abstract());</span></a>
<a name="349"><span class="lineNum">     349 </span><span class="lineCov">       9433 :                 if (</span></a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">      10174 :                         _function.isConstructor() &amp;&amp;</span></a>
<a name="351"><span class="lineNum">     351 </span><span class="lineCov">      10174 :                         _var.referenceLocation() == VariableDeclaration::Location::Storage &amp;&amp;</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineNoCov">          0 :                         !m_currentContract-&gt;abstract()</span></a>
<a name="353"><span class="lineNum">     353 </span>            :                 )</a>
<a name="354"><span class="lineNum">     354 </span><span class="lineNoCov">          0 :                         m_errorReporter.fatalTypeError(</span></a>
<a name="355"><span class="lineNum">     355 </span>            :                                 3644_error,</a>
<a name="356"><span class="lineNum">     356 </span><span class="lineNoCov">          0 :                                 _var.location(),</span></a>
<a name="357"><span class="lineNum">     357 </span>            :                                 &quot;This parameter has a type that can only be used internally. &quot;</a>
<a name="358"><span class="lineNum">     358 </span>            :                                 &quot;You can make the contract abstract to avoid this problem.&quot;</a>
<a name="359"><span class="lineNum">     359 </span>            :                         );</a>
<a name="360"><span class="lineNum">     360 </span><span class="lineCov">       9433 :                 else if (functionIsExternallyVisible)</span></a>
<a name="361"><span class="lineNum">     361 </span>            :                 {</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">      16692 :                         auto iType = type(_var)-&gt;interfaceType(_function.libraryFunction());</span></a>
<a name="363"><span class="lineNum">     363 </span>            : </a>
<a name="364"><span class="lineNum">     364 </span><span class="lineCov">       8346 :                         if (!iType)</span></a>
<a name="365"><span class="lineNum">     365 </span>            :                         {</a>
<a name="366"><span class="lineNum">     366 </span><span class="lineNoCov">          0 :                                 std::string message = iType.message();</span></a>
<a name="367"><span class="lineNum">     367 </span><span class="lineNoCov">          0 :                                 solAssert(!message.empty(), &quot;Expected detailed error message!&quot;);</span></a>
<a name="368"><span class="lineNum">     368 </span><span class="lineNoCov">          0 :                                 if (_function.isConstructor())</span></a>
<a name="369"><span class="lineNum">     369 </span><span class="lineNoCov">          0 :                                         message += &quot; You can make the contract abstract to avoid this problem.&quot;;</span></a>
<a name="370"><span class="lineNum">     370 </span><span class="lineNoCov">          0 :                                 m_errorReporter.fatalTypeError(4103_error, _var.location(), message);</span></a>
<a name="371"><span class="lineNum">     371 </span>            :                         }</a>
<a name="372"><span class="lineNum">     372 </span><span class="lineCov">       8346 :                         else if (</span></a>
<a name="373"><span class="lineNum">     373 </span><span class="lineCov">       8346 :                                 !useABICoderV2() &amp;&amp;</span></a>
<a name="374"><span class="lineNum">     374 </span><span class="lineNoCov">          0 :                                 !typeSupportedByOldABIEncoder(*type(_var), _function.libraryFunction())</span></a>
<a name="375"><span class="lineNum">     375 </span>            :                         )</a>
<a name="376"><span class="lineNum">     376 </span>            :                         {</a>
<a name="377"><span class="lineNum">     377 </span>            :                                 std::string message =</a>
<a name="378"><span class="lineNum">     378 </span>            :                                         &quot;This type is only supported in ABI coder v2. &quot;</a>
<a name="379"><span class="lineNum">     379 </span><span class="lineNoCov">          0 :                                         &quot;Use \&quot;pragma abicoder v2;\&quot; to enable the feature.&quot;;</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineNoCov">          0 :                                 if (_function.isConstructor())</span></a>
<a name="381"><span class="lineNum">     381 </span>            :                                         message +=</a>
<a name="382"><span class="lineNum">     382 </span>            :                                                 &quot; Alternatively, make the contract abstract and supply the &quot;</a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :                                                 &quot;constructor arguments from a derived contract.&quot;;</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="385"><span class="lineNum">     385 </span>            :                                         4957_error,</a>
<a name="386"><span class="lineNum">     386 </span><span class="lineNoCov">          0 :                                         _var.location(),</span></a>
<a name="387"><span class="lineNum">     387 </span>            :                                         message</a>
<a name="388"><span class="lineNum">     388 </span>            :                                 );</a>
<a name="389"><span class="lineNum">     389 </span>            :                         }</a>
<a name="390"><span class="lineNum">     390 </span>            :                 }</a>
<a name="391"><span class="lineNum">     391 </span><span class="lineCov">       9433 :         };</span></a>
<a name="392"><span class="lineNum">     392 </span><span class="lineCov">      14669 :         for (ASTPointer&lt;VariableDeclaration&gt; const&amp; var: _function.parameters())</span></a>
<a name="393"><span class="lineNum">     393 </span>            :         {</a>
<a name="394"><span class="lineNum">     394 </span><span class="lineCov">       5705 :                 checkArgumentAndReturnParameter(*var);</span></a>
<a name="395"><span class="lineNum">     395 </span><span class="lineCov">       5705 :                 var-&gt;accept(*this);</span></a>
<a name="396"><span class="lineNum">     396 </span>            :         }</a>
<a name="397"><span class="lineNum">     397 </span><span class="lineCov">      12692 :         for (ASTPointer&lt;VariableDeclaration&gt; const&amp; var: _function.returnParameters())</span></a>
<a name="398"><span class="lineNum">     398 </span>            :         {</a>
<a name="399"><span class="lineNum">     399 </span><span class="lineCov">       3728 :                 checkArgumentAndReturnParameter(*var);</span></a>
<a name="400"><span class="lineNum">     400 </span><span class="lineCov">       3728 :                 var-&gt;accept(*this);</span></a>
<a name="401"><span class="lineNum">     401 </span>            :         }</a>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<a name="403"><span class="lineNum">     403 </span><span class="lineCov">       9167 :         std::set&lt;Declaration const*&gt; modifiers;</span></a>
<a name="404"><span class="lineNum">     404 </span><span class="lineCov">       9084 :         for (ASTPointer&lt;ModifierInvocation&gt; const&amp; modifier: _function.modifiers())</span></a>
<a name="405"><span class="lineNum">     405 </span>            :         {</a>
<a name="406"><span class="lineNum">     406 </span><span class="lineCov">        240 :                 std::vector&lt;ContractDefinition const*&gt; baseContracts;</span></a>
<a name="407"><span class="lineNum">     407 </span><span class="lineCov">        120 :                 if (auto contract = dynamic_cast&lt;ContractDefinition const*&gt;(_function.scope()))</span></a>
<a name="408"><span class="lineNum">     408 </span>            :                 {</a>
<a name="409"><span class="lineNum">     409 </span><span class="lineCov">        120 :                         baseContracts = contract-&gt;annotation().linearizedBaseContracts;</span></a>
<a name="410"><span class="lineNum">     410 </span>            :                         // Delete first base which is just the main contract itself</a>
<a name="411"><span class="lineNum">     411 </span><span class="lineCov">        120 :                         baseContracts.erase(baseContracts.begin());</span></a>
<a name="412"><span class="lineNum">     412 </span>            :                 }</a>
<a name="413"><span class="lineNum">     413 </span>            : </a>
<a name="414"><span class="lineNum">     414 </span><span class="lineCov">        120 :                 visitManually(</span></a>
<a name="415"><span class="lineNum">     415 </span><span class="lineCov">        120 :                         *modifier,</span></a>
<a name="416"><span class="lineNum">     416 </span><span class="lineCov">        240 :                         _function.isConstructor() ? baseContracts : std::vector&lt;ContractDefinition const*&gt;()</span></a>
<a name="417"><span class="lineNum">     417 </span>            :                 );</a>
<a name="418"><span class="lineNum">     418 </span><span class="lineCov">        120 :                 Declaration const* decl = &amp;dereference(modifier-&gt;name());</span></a>
<a name="419"><span class="lineNum">     419 </span><span class="lineCov">        120 :                 if (modifiers.count(decl))</span></a>
<a name="420"><span class="lineNum">     420 </span>            :                 {</a>
<a name="421"><span class="lineNum">     421 </span><span class="lineCov">         22 :                         if (dynamic_cast&lt;ContractDefinition const*&gt;(decl))</span></a>
<a name="422"><span class="lineNum">     422 </span><span class="lineNoCov">          0 :                                 m_errorReporter.declarationError(1697_error, modifier-&gt;location(), &quot;Base constructor already provided.&quot;);</span></a>
<a name="423"><span class="lineNum">     423 </span>            :                 }</a>
<a name="424"><span class="lineNum">     424 </span>            :                 else</a>
<a name="425"><span class="lineNum">     425 </span><span class="lineCov">         98 :                         modifiers.insert(decl);</span></a>
<a name="426"><span class="lineNum">     426 </span>            :         }</a>
<a name="427"><span class="lineNum">     427 </span>            : </a>
<a name="428"><span class="lineNum">     428 </span><span class="lineCov">       8964 :         solAssert(_function.isFree() == !m_currentContract, &quot;&quot;);</span></a>
<a name="429"><span class="lineNum">     429 </span><span class="lineCov">       8964 :         if (!m_currentContract)</span></a>
<a name="430"><span class="lineNum">     430 </span>            :         {</a>
<a name="431"><span class="lineNum">     431 </span><span class="lineCov">         17 :                 solAssert(!_function.isConstructor(), &quot;&quot;);</span></a>
<a name="432"><span class="lineNum">     432 </span><span class="lineCov">         17 :                 solAssert(!_function.isFallback(), &quot;&quot;);</span></a>
<a name="433"><span class="lineNum">     433 </span><span class="lineCov">         17 :                 solAssert(!_function.isReceive(), &quot;&quot;);</span></a>
<a name="434"><span class="lineNum">     434 </span>            :         }</a>
<a name="435"><span class="lineNum">     435 </span><span class="lineCov">       8947 :         else if (m_currentContract-&gt;isInterface())</span></a>
<a name="436"><span class="lineNum">     436 </span>            :         {</a>
<a name="437"><span class="lineNum">     437 </span><span class="lineCov">        522 :                 if (_function.isImplemented())</span></a>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">          7 :                         m_errorReporter.typeError(4726_error, _function.location(), &quot;Functions in interfaces cannot have an implementation.&quot;);</span></a>
<a name="439"><span class="lineNum">     439 </span>            : </a>
<a name="440"><span class="lineNum">     440 </span><span class="lineCov">        522 :                 if (_function.isConstructor())</span></a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">          4 :                         m_errorReporter.typeError(6482_error, _function.location(), &quot;Constructor cannot be defined in interfaces.&quot;);</span></a>
<a name="442"><span class="lineNum">     442 </span><span class="lineCov">        518 :                 else if (_function.visibility() != Visibility::External)</span></a>
<a name="443"><span class="lineNum">     443 </span><span class="lineCov">         76 :                         m_errorReporter.typeError(1560_error, _function.location(), &quot;Functions in interfaces must be declared external.&quot;);</span></a>
<a name="444"><span class="lineNum">     444 </span>            :         }</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">       8425 :         else if (m_currentContract-&gt;contractKind() == ContractKind::Library)</span></a>
<a name="446"><span class="lineNum">     446 </span><span class="lineCov">        326 :                 if (_function.isConstructor())</span></a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">          5 :                         m_errorReporter.typeError(7634_error, _function.location(), &quot;Constructor cannot be defined in libraries.&quot;);</span></a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span><span class="lineCov">       8964 :         if (_function.isImplemented())</span></a>
<a name="450"><span class="lineNum">     450 </span><span class="lineCov">       8340 :                 _function.body().accept(*this);</span></a>
<a name="451"><span class="lineNum">     451 </span><span class="lineCov">        624 :         else if (_function.isConstructor())</span></a>
<a name="452"><span class="lineNum">     452 </span><span class="lineCov">          3 :                 m_errorReporter.typeError(5700_error, _function.location(), &quot;Constructor must be implemented if declared.&quot;);</span></a>
<a name="453"><span class="lineNum">     453 </span><span class="lineCov">        621 :         else if (_function.libraryFunction())</span></a>
<a name="454"><span class="lineNum">     454 </span><span class="lineCov">         10 :                 m_errorReporter.typeError(9231_error, _function.location(), &quot;Library functions must be implemented if declared.&quot;);</span></a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">        611 :         else if (!_function.virtualSemantics())</span></a>
<a name="456"><span class="lineNum">     456 </span>            :         {</a>
<a name="457"><span class="lineNum">     457 </span><span class="lineCov">         95 :                 if (_function.isFree())</span></a>
<a name="458"><span class="lineNum">     458 </span><span class="lineNoCov">          0 :                         solAssert(m_errorReporter.hasErrors(), &quot;&quot;);</span></a>
<a name="459"><span class="lineNum">     459 </span>            :                 else</a>
<a name="460"><span class="lineNum">     460 </span><span class="lineCov">         95 :                         m_errorReporter.typeError(5424_error, _function.location(), &quot;Functions without implementation must be marked virtual.&quot;);</span></a>
<a name="461"><span class="lineNum">     461 </span>            :         }</a>
<a name="462"><span class="lineNum">     462 </span>            : </a>
<a name="463"><span class="lineNum">     463 </span>            : </a>
<a name="464"><span class="lineNum">     464 </span><span class="lineCov">       8761 :         if (_function.isFallback())</span></a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">         15 :                 typeCheckFallbackFunction(_function);</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineCov">       8746 :         else if (_function.isConstructor())</span></a>
<a name="467"><span class="lineNum">     467 </span><span class="lineCov">       1431 :                 typeCheckConstructor(_function);</span></a>
<a name="468"><span class="lineNum">     468 </span>            : </a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">      17522 :         return false;</span></a>
<a name="470"><span class="lineNum">     470 </span>            : }</a>
<a name="471"><span class="lineNum">     471 </span>            : </a>
<a name="472"><span class="lineNum">     472 </span><span class="lineCov">      20934 : bool TypeChecker::visit(VariableDeclaration const&amp; _variable)</span></a>
<a name="473"><span class="lineNum">     473 </span>            : {</a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">      20934 :         _variable.typeName().accept(*this);</span></a>
<a name="475"><span class="lineNum">     475 </span>            : </a>
<a name="476"><span class="lineNum">     476 </span>            :         // type is filled either by ReferencesResolver directly from the type name or by</a>
<a name="477"><span class="lineNum">     477 </span>            :         // TypeChecker at the VariableDeclarationStatement level.</a>
<a name="478"><span class="lineNum">     478 </span><span class="lineCov">      20934 :         Type const* varType = _variable.annotation().type;</span></a>
<a name="479"><span class="lineNum">     479 </span><span class="lineCov">      20934 :         solAssert(!!varType, &quot;Variable type not provided.&quot;);</span></a>
<a name="480"><span class="lineNum">     480 </span>            : </a>
<a name="481"><span class="lineNum">     481 </span><span class="lineCov">      20934 :         if (_variable.value())</span></a>
<a name="482"><span class="lineNum">     482 </span>            :         {</a>
<a name="483"><span class="lineNum">     483 </span><span class="lineCov">       2220 :                 if (_variable.isStateVariable() &amp;&amp; varType-&gt;containsNestedMapping())</span></a>
<a name="484"><span class="lineNum">     484 </span>            :                 {</a>
<a name="485"><span class="lineNum">     485 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="486"><span class="lineNum">     486 </span>            :                                 6280_error,</a>
<a name="487"><span class="lineNum">     487 </span><span class="lineNoCov">          0 :                                 _variable.location(),</span></a>
<a name="488"><span class="lineNum">     488 </span>            :                                 &quot;Types in storage containing (nested) mappings cannot be assigned to.&quot;</a>
<a name="489"><span class="lineNum">     489 </span>            :                         );</a>
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 :                         _variable.value()-&gt;accept(*this);</span></a>
<a name="491"><span class="lineNum">     491 </span>            :                 }</a>
<a name="492"><span class="lineNum">     492 </span>            :                 else</a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">       2220 :                         expectType(*_variable.value(), *varType);</span></a>
<a name="494"><span class="lineNum">     494 </span>            :         }</a>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">      20928 :         if (_variable.isConstant())</span></a>
<a name="496"><span class="lineNum">     496 </span>            :         {</a>
<a name="497"><span class="lineNum">     497 </span><span class="lineCov">       1591 :                 if (!_variable.value())</span></a>
<a name="498"><span class="lineNum">     498 </span><span class="lineCov">         42 :                         m_errorReporter.typeError(4266_error, _variable.location(), &quot;Uninitialized \&quot;constant\&quot; variable.&quot;);</span></a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">       1549 :                 else if (!*_variable.value()-&gt;annotation().isPure)</span></a>
<a name="500"><span class="lineNum">     500 </span><span class="lineCov">          8 :                         m_errorReporter.typeError(</span></a>
<a name="501"><span class="lineNum">     501 </span>            :                                 8349_error,</a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">          4 :                                 _variable.value()-&gt;location(),</span></a>
<a name="503"><span class="lineNum">     503 </span>            :                                 &quot;Initial value for constant variable has to be compile-time constant.&quot;</a>
<a name="504"><span class="lineNum">     504 </span>            :                         );</a>
<a name="505"><span class="lineNum">     505 </span>            :         }</a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">      19337 :         else if (_variable.immutable())</span></a>
<a name="507"><span class="lineNum">     507 </span>            :         {</a>
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">        185 :                 if (!_variable.type()-&gt;isValueType())</span></a>
<a name="509"><span class="lineNum">     509 </span><span class="lineCov">         10 :                         m_errorReporter.typeError(6377_error, _variable.location(), &quot;Immutable variables cannot have a non-value type.&quot;);</span></a>
<a name="510"><span class="lineNum">     510 </span><span class="lineCov">        185 :                 if (</span></a>
<a name="511"><span class="lineNum">     511 </span><span class="lineCov">        185 :                         auto const* functionType = dynamic_cast&lt;FunctionType const*&gt;(_variable.type());</span></a>
<a name="512"><span class="lineNum">     512 </span><span class="lineCov">        185 :                         functionType &amp;&amp; functionType-&gt;kind() == FunctionType::Kind::External</span></a>
<a name="513"><span class="lineNum">     513 </span>            :                 )</a>
<a name="514"><span class="lineNum">     514 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(3366_error, _variable.location(), &quot;Immutable variables of external function type are not yet supported.&quot;);</span></a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">        185 :                 solAssert(_variable.type()-&gt;sizeOnStack() == 1 || m_errorReporter.hasErrors(), &quot;&quot;);</span></a>
<a name="516"><span class="lineNum">     516 </span>            :         }</a>
<a name="517"><span class="lineNum">     517 </span>            : </a>
<a name="518"><span class="lineNum">     518 </span><span class="lineCov">      20928 :         if (!_variable.isStateVariable())</span></a>
<a name="519"><span class="lineNum">     519 </span>            :         {</a>
<a name="520"><span class="lineNum">     520 </span><span class="lineCov">      13463 :                 if (</span></a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">      26903 :                         _variable.referenceLocation() == VariableDeclaration::Location::CallData ||</span></a>
<a name="522"><span class="lineNum">     522 </span><span class="lineCov">      13440 :                         _variable.referenceLocation() == VariableDeclaration::Location::Memory</span></a>
<a name="523"><span class="lineNum">     523 </span>            :                 )</a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">       1042 :                         if (varType-&gt;containsNestedMapping())</span></a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">          1 :                                 m_errorReporter.fatalTypeError(</span></a>
<a name="526"><span class="lineNum">     526 </span>            :                                         4061_error,</a>
<a name="527"><span class="lineNum">     527 </span><span class="lineCov">          1 :                                         _variable.location(),</span></a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">          5 :                                         &quot;Type &quot; + varType-&gt;humanReadableName() + &quot; is only valid in storage because it contains a (nested) mapping.&quot;</span></a>
<a name="529"><span class="lineNum">     529 </span>            :                                 );</a>
<a name="530"><span class="lineNum">     530 </span>            :         }</a>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">       7465 :         else if (_variable.visibility() &gt;= Visibility::Public)</span></a>
<a name="532"><span class="lineNum">     532 </span>            :         {</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">       6260 :                 FunctionType getter(_variable);</span></a>
<a name="534"><span class="lineNum">     534 </span><span class="lineCov">       3130 :                 if (!useABICoderV2())</span></a>
<a name="535"><span class="lineNum">     535 </span>            :                 {</a>
<a name="536"><span class="lineNum">     536 </span><span class="lineNoCov">          0 :                         std::vector&lt;std::string&gt; unsupportedTypes;</span></a>
<a name="537"><span class="lineNum">     537 </span><span class="lineNoCov">          0 :                         for (auto const&amp; param: getter.parameterTypes() + getter.returnParameterTypes())</span></a>
<a name="538"><span class="lineNum">     538 </span><span class="lineNoCov">          0 :                                 if (!typeSupportedByOldABIEncoder(*param, false /* isLibrary */))</span></a>
<a name="539"><span class="lineNum">     539 </span><span class="lineNoCov">          0 :                                         unsupportedTypes.emplace_back(param-&gt;humanReadableName());</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineNoCov">          0 :                         if (!unsupportedTypes.empty())</span></a>
<a name="541"><span class="lineNum">     541 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="542"><span class="lineNum">     542 </span>            :                                         2763_error,</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineNoCov">          0 :                                         _variable.location(),</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineNoCov">          0 :                                         &quot;The following types are only supported for getters in ABI coder v2: &quot; +</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineNoCov">          0 :                                         joinHumanReadable(unsupportedTypes) +</span></a>
<a name="546"><span class="lineNum">     546 </span>            :                                         &quot;. Either remove \&quot;public\&quot; or use \&quot;pragma abicoder v2;\&quot; to enable the feature.&quot;</a>
<a name="547"><span class="lineNum">     547 </span>            :                                 );</a>
<a name="548"><span class="lineNum">     548 </span>            :                 }</a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">       3130 :                 if (!getter.interfaceFunctionType())</span></a>
<a name="550"><span class="lineNum">     550 </span>            :                 {</a>
<a name="551"><span class="lineNum">     551 </span><span class="lineNoCov">          0 :                         solAssert(getter.returnParameterNames().size() == getter.returnParameterTypes().size());</span></a>
<a name="552"><span class="lineNum">     552 </span><span class="lineNoCov">          0 :                         solAssert(getter.parameterNames().size() == getter.parameterTypes().size());</span></a>
<a name="553"><span class="lineNum">     553 </span><span class="lineNoCov">          0 :                         if (getter.returnParameterTypes().empty() &amp;&amp; getter.parameterTypes().empty())</span></a>
<a name="554"><span class="lineNum">     554 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(5359_error, _variable.location(), &quot;The struct has all its members omitted, therefore the getter cannot return any values.&quot;);</span></a>
<a name="555"><span class="lineNum">     555 </span>            :                         else</a>
<a name="556"><span class="lineNum">     556 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(6744_error, _variable.location(), &quot;Internal or recursive type is not allowed for public state variables.&quot;);</span></a>
<a name="557"><span class="lineNum">     557 </span>            :                 }</a>
<a name="558"><span class="lineNum">     558 </span>            :         }</a>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<a name="560"><span class="lineNum">     560 </span><span class="lineCov">      20927 :         bool isStructMemberDeclaration = dynamic_cast&lt;StructDefinition const*&gt;(_variable.scope()) != nullptr;</span></a>
<a name="561"><span class="lineNum">     561 </span><span class="lineCov">      20927 :         if (isStructMemberDeclaration)</span></a>
<a name="562"><span class="lineNum">     562 </span><span class="lineCov">        215 :                 return false;</span></a>
<a name="563"><span class="lineNum">     563 </span>            : </a>
<a name="564"><span class="lineNum">     564 </span><span class="lineCov">      20712 :         if (auto referenceType = dynamic_cast&lt;ReferenceType const*&gt;(varType))</span></a>
<a name="565"><span class="lineNum">     565 </span>            :         {</a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">       1437 :                 BoolResult result = referenceType-&gt;validForLocation(referenceType-&gt;location());</span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">       1437 :                 if (result)</span></a>
<a name="568"><span class="lineNum">     568 </span>            :                 {</a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">       1437 :                         bool isLibraryStorageParameter = (_variable.isLibraryFunctionParameter() &amp;&amp; referenceType-&gt;location() == DataLocation::Storage);</span></a>
<a name="570"><span class="lineNum">     570 </span>            :                         // We skip the calldata check for abstract contract constructors.</a>
<a name="571"><span class="lineNum">     571 </span><span class="lineCov">       1437 :                         bool isAbstractConstructorParam = _variable.isConstructorParameter() &amp;&amp; m_currentContract &amp;&amp; m_currentContract-&gt;abstract();</span></a>
<a name="572"><span class="lineNum">     572 </span>            :                         bool callDataCheckRequired =</a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">       2874 :                                 !isAbstractConstructorParam &amp;&amp;</span></a>
<a name="574"><span class="lineNum">     574 </span><span class="lineCov">       1948 :                                 (_variable.isConstructorParameter() || _variable.isPublicCallableParameter()) &amp;&amp;</span></a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">        511 :                                 !isLibraryStorageParameter;</span></a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">       1437 :                         if (callDataCheckRequired)</span></a>
<a name="577"><span class="lineNum">     577 </span>            :                         {</a>
<a name="578"><span class="lineNum">     578 </span><span class="lineCov">        511 :                                 if (!referenceType-&gt;interfaceType(false))</span></a>
<a name="579"><span class="lineNum">     579 </span><span class="lineNoCov">          0 :                                         solAssert(m_errorReporter.hasErrors(), &quot;&quot;);</span></a>
<a name="580"><span class="lineNum">     580 </span>            :                                 else</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">        511 :                                         result = referenceType-&gt;validForLocation(DataLocation::CallData);</span></a>
<a name="582"><span class="lineNum">     582 </span>            :                         }</a>
<a name="583"><span class="lineNum">     583 </span>            :                 }</a>
<a name="584"><span class="lineNum">     584 </span><span class="lineCov">       1437 :                 if (!result)</span></a>
<a name="585"><span class="lineNum">     585 </span>            :                 {</a>
<a name="586"><span class="lineNum">     586 </span><span class="lineNoCov">          0 :                         solAssert(!result.message().empty(), &quot;Expected detailed error message&quot;);</span></a>
<a name="587"><span class="lineNum">     587 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(1534_error, _variable.location(), result.message());</span></a>
<a name="588"><span class="lineNum">     588 </span><span class="lineNoCov">          0 :                         return false;</span></a>
<a name="589"><span class="lineNum">     589 </span>            :                 }</a>
<a name="590"><span class="lineNum">     590 </span>            :         }</a>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<a name="592"><span class="lineNum">     592 </span><span class="lineCov">      20712 :         return false;</span></a>
<a name="593"><span class="lineNum">     593 </span>            : }</a>
<a name="594"><span class="lineNum">     594 </span>            : </a>
<a name="595"><span class="lineNum">     595 </span><span class="lineCov">        109 : void TypeChecker::endVisit(StructDefinition const&amp; _struct)</span></a>
<a name="596"><span class="lineNum">     596 </span>            : {</a>
<a name="597"><span class="lineNum">     597 </span><span class="lineCov">        324 :         for (auto const&amp; member: _struct.members())</span></a>
<a name="598"><span class="lineNum">     598 </span><span class="lineCov">        215 :                 solAssert(</span></a>
<a name="599"><span class="lineNum">     599 </span>            :                         member-&gt;annotation().type &amp;&amp;</a>
<a name="600"><span class="lineNum">     600 </span>            :                         member-&gt;annotation().type-&gt;canBeStored(),</a>
<a name="601"><span class="lineNum">     601 </span>            :                         &quot;Type cannot be used in struct.&quot;</a>
<a name="602"><span class="lineNum">     602 </span>            :                 );</a>
<a name="603"><span class="lineNum">     603 </span><span class="lineCov">        109 : }</span></a>
<a name="604"><span class="lineNum">     604 </span>            : </a>
<a name="605"><span class="lineNum">     605 </span><span class="lineCov">        120 : void TypeChecker::visitManually(</span></a>
<a name="606"><span class="lineNum">     606 </span>            :         ModifierInvocation const&amp; _modifier,</a>
<a name="607"><span class="lineNum">     607 </span>            :         std::vector&lt;ContractDefinition const*&gt; const&amp; _bases</a>
<a name="608"><span class="lineNum">     608 </span>            : )</a>
<a name="609"><span class="lineNum">     609 </span>            : {</a>
<a name="610"><span class="lineNum">     610 </span>            :         std::vector&lt;ASTPointer&lt;Expression&gt;&gt; const&amp; arguments =</a>
<a name="611"><span class="lineNum">     611 </span><span class="lineCov">        120 :                 _modifier.arguments() ? *_modifier.arguments() : std::vector&lt;ASTPointer&lt;Expression&gt;&gt;();</span></a>
<a name="612"><span class="lineNum">     612 </span><span class="lineCov">        183 :         for (ASTPointer&lt;Expression&gt; const&amp; argument: arguments)</span></a>
<a name="613"><span class="lineNum">     613 </span><span class="lineCov">         63 :                 argument-&gt;accept(*this);</span></a>
<a name="614"><span class="lineNum">     614 </span>            : </a>
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">        120 :         _modifier.name().accept(*this);</span></a>
<a name="616"><span class="lineNum">     616 </span>            : </a>
<a name="617"><span class="lineNum">     617 </span><span class="lineCov">        120 :         auto const* declaration = &amp;dereference(_modifier.name());</span></a>
<a name="618"><span class="lineNum">     618 </span><span class="lineCov">        120 :         std::vector&lt;ASTPointer&lt;VariableDeclaration&gt;&gt; emptyParameterList;</span></a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">        120 :         std::vector&lt;ASTPointer&lt;VariableDeclaration&gt;&gt; const* parameters = nullptr;</span></a>
<a name="620"><span class="lineNum">     620 </span><span class="lineCov">        120 :         if (auto modifierDecl = dynamic_cast&lt;ModifierDefinition const*&gt;(declaration))</span></a>
<a name="621"><span class="lineNum">     621 </span>            :         {</a>
<a name="622"><span class="lineNum">     622 </span><span class="lineCov">        112 :                 parameters = &amp;modifierDecl-&gt;parameters();</span></a>
<a name="623"><span class="lineNum">     623 </span><span class="lineCov">        112 :                 if (auto const* modifierContract = dynamic_cast&lt;ContractDefinition const*&gt;(modifierDecl-&gt;scope()))</span></a>
<a name="624"><span class="lineNum">     624 </span><span class="lineCov">        112 :                         if (m_currentContract)</span></a>
<a name="625"><span class="lineNum">     625 </span>            :                         {</a>
<a name="626"><span class="lineNum">     626 </span><span class="lineCov">        112 :                                 if (!util::contains(m_currentContract-&gt;annotation().linearizedBaseContracts, modifierContract))</span></a>
<a name="627"><span class="lineNum">     627 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="628"><span class="lineNum">     628 </span>            :                                                 9428_error,</a>
<a name="629"><span class="lineNum">     629 </span><span class="lineNoCov">          0 :                                                 _modifier.location(),</span></a>
<a name="630"><span class="lineNum">     630 </span>            :                                                 &quot;Can only use modifiers defined in the current contract or in base contracts.&quot;</a>
<a name="631"><span class="lineNum">     631 </span>            :                                         );</a>
<a name="632"><span class="lineNum">     632 </span>            :                         }</a>
<a name="633"><span class="lineNum">     633 </span><span class="lineCov">        112 :                 if (</span></a>
<a name="634"><span class="lineNum">     634 </span><span class="lineCov">        112 :                         *_modifier.name().annotation().requiredLookup == VirtualLookup::Static &amp;&amp;</span></a>
<a name="635"><span class="lineNum">     635 </span><span class="lineNoCov">          0 :                         !modifierDecl-&gt;isImplemented()</span></a>
<a name="636"><span class="lineNum">     636 </span>            :                 )</a>
<a name="637"><span class="lineNum">     637 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="638"><span class="lineNum">     638 </span>            :                                 1835_error,</a>
<a name="639"><span class="lineNum">     639 </span><span class="lineNoCov">          0 :                                 _modifier.location(),</span></a>
<a name="640"><span class="lineNum">     640 </span>            :                                 &quot;Cannot call unimplemented modifier. The modifier has no implementation in the referenced contract. Refer to it by its unqualified name if you want to call the implementation from the most derived contract.&quot;</a>
<a name="641"><span class="lineNum">     641 </span>            :                         );</a>
<a name="642"><span class="lineNum">     642 </span>            :         }</a>
<a name="643"><span class="lineNum">     643 </span>            :         else</a>
<a name="644"><span class="lineNum">     644 </span>            :                 // check parameters for Base constructors</a>
<a name="645"><span class="lineNum">     645 </span><span class="lineCov">          8 :                 for (ContractDefinition const* base: _bases)</span></a>
<a name="646"><span class="lineNum">     646 </span><span class="lineCov">          1 :                         if (declaration == base)</span></a>
<a name="647"><span class="lineNum">     647 </span>            :                         {</a>
<a name="648"><span class="lineNum">     648 </span><span class="lineCov">          1 :                                 if (auto referencedConstructor = base-&gt;constructor())</span></a>
<a name="649"><span class="lineNum">     649 </span><span class="lineNoCov">          0 :                                         parameters = &amp;referencedConstructor-&gt;parameters();</span></a>
<a name="650"><span class="lineNum">     650 </span>            :                                 else</a>
<a name="651"><span class="lineNum">     651 </span><span class="lineCov">          1 :                                         parameters = &amp;emptyParameterList;</span></a>
<a name="652"><span class="lineNum">     652 </span><span class="lineCov">          1 :                                 break;</span></a>
<a name="653"><span class="lineNum">     653 </span>            :                         }</a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">        120 :         if (!parameters)</span></a>
<a name="655"><span class="lineNum">     655 </span>            :         {</a>
<a name="656"><span class="lineNum">     656 </span><span class="lineCov">          7 :                 m_errorReporter.typeError(4659_error, _modifier.location(), &quot;Referenced declaration is neither modifier nor base class.&quot;);</span></a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">          7 :                 return;</span></a>
<a name="658"><span class="lineNum">     658 </span>            :         }</a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">        113 :         if (parameters-&gt;size() != arguments.size())</span></a>
<a name="660"><span class="lineNum">     660 </span>            :         {</a>
<a name="661"><span class="lineNum">     661 </span><span class="lineCov">          2 :                 m_errorReporter.typeError(</span></a>
<a name="662"><span class="lineNum">     662 </span>            :                         2973_error,</a>
<a name="663"><span class="lineNum">     663 </span><span class="lineCov">          2 :                         _modifier.location(),</span></a>
<a name="664"><span class="lineNum">     664 </span><span class="lineCov">          2 :                         &quot;Wrong argument count for modifier invocation: &quot; +</span></a>
<a name="665"><span class="lineNum">     665 </span><span class="lineCov">          6 :                         toString(arguments.size()) +</span></a>
<a name="666"><span class="lineNum">     666 </span><span class="lineCov">          4 :                         &quot; arguments given but expected &quot; +</span></a>
<a name="667"><span class="lineNum">     667 </span><span class="lineCov">          8 :                         toString(parameters-&gt;size()) +</span></a>
<a name="668"><span class="lineNum">     668 </span>            :                         &quot;.&quot;</a>
<a name="669"><span class="lineNum">     669 </span>            :                 );</a>
<a name="670"><span class="lineNum">     670 </span><span class="lineCov">          2 :                 return;</span></a>
<a name="671"><span class="lineNum">     671 </span>            :         }</a>
<a name="672"><span class="lineNum">     672 </span><span class="lineCov">        167 :         for (size_t i = 0; i &lt; arguments.size(); ++i)</span></a>
<a name="673"><span class="lineNum">     673 </span>            :         {</a>
<a name="674"><span class="lineNum">     674 </span><span class="lineCov">        112 :                 BoolResult result = type(*arguments[i])-&gt;isImplicitlyConvertibleTo(*type(*(*parameters)[i]));</span></a>
<a name="675"><span class="lineNum">     675 </span><span class="lineCov">         56 :                 if (!result)</span></a>
<a name="676"><span class="lineNum">     676 </span><span class="lineCov">          2 :                         m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="677"><span class="lineNum">     677 </span>            :                                 4649_error,</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">          2 :                                 arguments[i]-&gt;location(),</span></a>
<a name="679"><span class="lineNum">     679 </span>            :                                 &quot;Invalid type for argument in modifier invocation. &quot;</a>
<a name="680"><span class="lineNum">     680 </span><span class="lineCov">          2 :                                 &quot;Invalid implicit conversion from &quot; +</span></a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">          6 :                                 type(*arguments[i])-&gt;humanReadableName() +</span></a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">          4 :                                 &quot; to &quot; +</span></a>
<a name="683"><span class="lineNum">     683 </span><span class="lineCov">          8 :                                 type(*(*parameters)[i])-&gt;humanReadableName() +</span></a>
<a name="684"><span class="lineNum">     684 </span>            :                                 &quot; requested.&quot;,</a>
<a name="685"><span class="lineNum">     685 </span><span class="lineCov">          2 :                                 result.message()</span></a>
<a name="686"><span class="lineNum">     686 </span>            :                         );</a>
<a name="687"><span class="lineNum">     687 </span>            :         }</a>
<a name="688"><span class="lineNum">     688 </span>            : }</a>
<a name="689"><span class="lineNum">     689 </span>            : </a>
<a name="690"><span class="lineNum">     690 </span><span class="lineCov">        283 : bool TypeChecker::visit(EventDefinition const&amp; _eventDef)</span></a>
<a name="691"><span class="lineNum">     691 </span>            : {</a>
<a name="692"><span class="lineNum">     692 </span><span class="lineCov">        283 :         solAssert(_eventDef.visibility() &gt; Visibility::Internal, &quot;&quot;);</span></a>
<a name="693"><span class="lineNum">     693 </span><span class="lineCov">        283 :         checkErrorAndEventParameters(_eventDef);</span></a>
<a name="694"><span class="lineNum">     694 </span>            : </a>
<a name="695"><span class="lineNum">     695 </span><span class="lineCov">        283 :         auto numIndexed = ranges::count_if(</span></a>
<a name="696"><span class="lineNum">     696 </span>            :                 _eventDef.parameters(),</a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">        415 :                 [](ASTPointer&lt;VariableDeclaration&gt; const&amp; var) { return var-&gt;isIndexed(); }</span></a>
<a name="698"><span class="lineNum">     698 </span>            :         );</a>
<a name="699"><span class="lineNum">     699 </span><span class="lineCov">        283 :         if (_eventDef.isAnonymous() &amp;&amp; numIndexed &gt; 4)</span></a>
<a name="700"><span class="lineNum">     700 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(8598_error, _eventDef.location(), &quot;More than 4 indexed arguments for anonymous event.&quot;);</span></a>
<a name="701"><span class="lineNum">     701 </span><span class="lineCov">        283 :         else if (!_eventDef.isAnonymous() &amp;&amp; numIndexed &gt; 3)</span></a>
<a name="702"><span class="lineNum">     702 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(7249_error, _eventDef.location(), &quot;More than 3 indexed arguments for event.&quot;);</span></a>
<a name="703"><span class="lineNum">     703 </span><span class="lineCov">        283 :         return true;</span></a>
<a name="704"><span class="lineNum">     704 </span>            : }</a>
<a name="705"><span class="lineNum">     705 </span>            : </a>
<a name="706"><span class="lineNum">     706 </span><span class="lineNoCov">          0 : bool TypeChecker::visit(ErrorDefinition const&amp; _errorDef)</span></a>
<a name="707"><span class="lineNum">     707 </span>            : {</a>
<a name="708"><span class="lineNum">     708 </span><span class="lineNoCov">          0 :         solAssert(_errorDef.visibility() &gt; Visibility::Internal, &quot;&quot;);</span></a>
<a name="709"><span class="lineNum">     709 </span><span class="lineNoCov">          0 :         checkErrorAndEventParameters(_errorDef);</span></a>
<a name="710"><span class="lineNum">     710 </span><span class="lineNoCov">          0 :         return true;</span></a>
<a name="711"><span class="lineNum">     711 </span>            : }</a>
<a name="712"><span class="lineNum">     712 </span>            : </a>
<a name="713"><span class="lineNum">     713 </span><span class="lineNoCov">          0 : void TypeChecker::endVisit(FunctionTypeName const&amp; _funType)</span></a>
<a name="714"><span class="lineNum">     714 </span>            : {</a>
<a name="715"><span class="lineNum">     715 </span><span class="lineNoCov">          0 :         FunctionType const&amp; fun = dynamic_cast&lt;FunctionType const&amp;&gt;(*_funType.annotation().type);</span></a>
<a name="716"><span class="lineNum">     716 </span><span class="lineNoCov">          0 :         if (fun.kind() == FunctionType::Kind::External)</span></a>
<a name="717"><span class="lineNum">     717 </span>            :         {</a>
<a name="718"><span class="lineNum">     718 </span><span class="lineNoCov">          0 :                 for (auto const&amp; t: _funType.parameterTypes() + _funType.returnParameterTypes())</span></a>
<a name="719"><span class="lineNum">     719 </span>            :                 {</a>
<a name="720"><span class="lineNum">     720 </span><span class="lineNoCov">          0 :                         solAssert(t-&gt;annotation().type, &quot;Type not set for parameter.&quot;);</span></a>
<a name="721"><span class="lineNum">     721 </span><span class="lineNoCov">          0 :                         if (!t-&gt;annotation().type-&gt;interfaceType(false).get())</span></a>
<a name="722"><span class="lineNum">     722 </span><span class="lineNoCov">          0 :                                 m_errorReporter.fatalTypeError(2582_error, t-&gt;location(), &quot;Internal type cannot be used for external function type.&quot;);</span></a>
<a name="723"><span class="lineNum">     723 </span>            :                 }</a>
<a name="724"><span class="lineNum">     724 </span><span class="lineNoCov">          0 :                 solAssert(fun.interfaceType(false), &quot;External function type uses internal types.&quot;);</span></a>
<a name="725"><span class="lineNum">     725 </span>            :         }</a>
<a name="726"><span class="lineNum">     726 </span><span class="lineNoCov">          0 : }</span></a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span><span class="lineCov">        102 : bool TypeChecker::visit(InlineAssembly const&amp; _inlineAssembly)</span></a>
<a name="729"><span class="lineNum">     729 </span>            : {</a>
<a name="730"><span class="lineNum">     730 </span><span class="lineCov">        102 :         bool lvalueAccessToMemoryVariable = false;</span></a>
<a name="731"><span class="lineNum">     731 </span>            :         // External references have already been resolved in a prior stage and stored in the annotation.</a>
<a name="732"><span class="lineNum">     732 </span>            :         // We run the resolve step again regardless.</a>
<a name="733"><span class="lineNum">     733 </span><span class="lineCov">        249 :         yul::ExternalIdentifierAccess::Resolver identifierAccess = [&amp;](</span></a>
<a name="734"><span class="lineNum">     734 </span>            :                 yul::Identifier const&amp; _identifier,</a>
<a name="735"><span class="lineNum">     735 </span>            :                 yul::IdentifierContext _context,</a>
<a name="736"><span class="lineNum">     736 </span>            :                 bool</a>
<a name="737"><span class="lineNum">     737 </span>            :         ) -&gt; bool</a>
<a name="738"><span class="lineNum">     738 </span>            :         {</a>
<a name="739"><span class="lineNum">     739 </span><span class="lineCov">        249 :                 if (_context == yul::IdentifierContext::NonExternal)</span></a>
<a name="740"><span class="lineNum">     740 </span>            :                 {</a>
<a name="741"><span class="lineNum">     741 </span>            :                         // Hack until we can disallow any shadowing: If we found an internal reference,</a>
<a name="742"><span class="lineNum">     742 </span>            :                         // clear the external references, so that codegen does not use it.</a>
<a name="743"><span class="lineNum">     743 </span><span class="lineCov">         27 :                         _inlineAssembly.annotation().externalReferences.erase(&amp; _identifier);</span></a>
<a name="744"><span class="lineNum">     744 </span><span class="lineCov">         27 :                         return false;</span></a>
<a name="745"><span class="lineNum">     745 </span>            :                 }</a>
<a name="746"><span class="lineNum">     746 </span><span class="lineCov">        222 :                 auto ref = _inlineAssembly.annotation().externalReferences.find(&amp;_identifier);</span></a>
<a name="747"><span class="lineNum">     747 </span><span class="lineCov">        222 :                 if (ref == _inlineAssembly.annotation().externalReferences.end())</span></a>
<a name="748"><span class="lineNum">     748 </span><span class="lineCov">         44 :                         return false;</span></a>
<a name="749"><span class="lineNum">     749 </span><span class="lineCov">        178 :                 InlineAssemblyAnnotation::ExternalIdentifierInfo&amp; identifierInfo = ref-&gt;second;</span></a>
<a name="750"><span class="lineNum">     750 </span><span class="lineCov">        178 :                 Declaration const* declaration = identifierInfo.declaration;</span></a>
<a name="751"><span class="lineNum">     751 </span><span class="lineCov">        178 :                 solAssert(!!declaration, &quot;&quot;);</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineCov">        178 :                 if (auto var = dynamic_cast&lt;VariableDeclaration const*&gt;(declaration))</span></a>
<a name="753"><span class="lineNum">     753 </span>            :                 {</a>
<a name="754"><span class="lineNum">     754 </span><span class="lineCov">        178 :                         solAssert(var-&gt;type(), &quot;Expected variable type!&quot;);</span></a>
<a name="755"><span class="lineNum">     755 </span><span class="lineCov">        178 :                         if (_context == yul::IdentifierContext::LValue &amp;&amp; var-&gt;type()-&gt;dataStoredIn(DataLocation::Memory))</span></a>
<a name="756"><span class="lineNum">     756 </span><span class="lineCov">          4 :                                 lvalueAccessToMemoryVariable = true;</span></a>
<a name="757"><span class="lineNum">     757 </span><span class="lineCov">        178 :                         if (var-&gt;immutable())</span></a>
<a name="758"><span class="lineNum">     758 </span>            :                         {</a>
<a name="759"><span class="lineNum">     759 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(3773_error, nativeLocationOf(_identifier), &quot;Assembly access to immutable variables is not supported.&quot;);</span></a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :                                 return false;</span></a>
<a name="761"><span class="lineNum">     761 </span>            :                         }</a>
<a name="762"><span class="lineNum">     762 </span><span class="lineCov">        178 :                         if (var-&gt;isConstant())</span></a>
<a name="763"><span class="lineNum">     763 </span>            :                         {</a>
<a name="764"><span class="lineNum">     764 </span><span class="lineCov">          4 :                                 if (isConstantVariableRecursive(*var))</span></a>
<a name="765"><span class="lineNum">     765 </span>            :                                 {</a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="767"><span class="lineNum">     767 </span>            :                                                 3558_error,</a>
<a name="768"><span class="lineNum">     768 </span><span class="lineNoCov">          0 :                                                 nativeLocationOf(_identifier),</span></a>
<a name="769"><span class="lineNum">     769 </span>            :                                                 &quot;Constant variable is circular.&quot;</a>
<a name="770"><span class="lineNum">     770 </span>            :                                         );</a>
<a name="771"><span class="lineNum">     771 </span><span class="lineNoCov">          0 :                                         return false;</span></a>
<a name="772"><span class="lineNum">     772 </span>            :                                 }</a>
<a name="773"><span class="lineNum">     773 </span>            : </a>
<a name="774"><span class="lineNum">     774 </span><span class="lineCov">          4 :                                 var = rootConstVariableDeclaration(*var);</span></a>
<a name="775"><span class="lineNum">     775 </span>            : </a>
<a name="776"><span class="lineNum">     776 </span><span class="lineCov">          4 :                                 if (var &amp;&amp; !var-&gt;value())</span></a>
<a name="777"><span class="lineNum">     777 </span>            :                                 {</a>
<a name="778"><span class="lineNum">     778 </span><span class="lineCov">          3 :                                         m_errorReporter.typeError(3224_error, nativeLocationOf(_identifier), &quot;Constant has no value.&quot;);</span></a>
<a name="779"><span class="lineNum">     779 </span><span class="lineCov">          3 :                                         return false;</span></a>
<a name="780"><span class="lineNum">     780 </span>            :                                 }</a>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">          1 :                                 else if (_context == yul::IdentifierContext::LValue)</span></a>
<a name="782"><span class="lineNum">     782 </span>            :                                 {</a>
<a name="783"><span class="lineNum">     783 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(6252_error, nativeLocationOf(_identifier), &quot;Constant variables cannot be assigned to.&quot;);</span></a>
<a name="784"><span class="lineNum">     784 </span><span class="lineNoCov">          0 :                                         return false;</span></a>
<a name="785"><span class="lineNum">     785 </span>            :                                 }</a>
<a name="786"><span class="lineNum">     786 </span><span class="lineCov">          1 :                                 else if (identifierInfo.suffix == &quot;slot&quot; || identifierInfo.suffix == &quot;offset&quot;)</span></a>
<a name="787"><span class="lineNum">     787 </span>            :                                 {</a>
<a name="788"><span class="lineNum">     788 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(6617_error, nativeLocationOf(_identifier), &quot;The suffixes .offset and .slot can only be used on non-constant storage or transient storage variables.&quot;);</span></a>
<a name="789"><span class="lineNum">     789 </span><span class="lineNoCov">          0 :                                         return false;</span></a>
<a name="790"><span class="lineNum">     790 </span>            :                                 }</a>
<a name="791"><span class="lineNum">     791 </span><span class="lineCov">          1 :                                 else if (var &amp;&amp; var-&gt;value() &amp;&amp; !var-&gt;value()-&gt;annotation().type &amp;&amp; !dynamic_cast&lt;Literal const*&gt;(var-&gt;value().get()))</span></a>
<a name="792"><span class="lineNum">     792 </span>            :                                 {</a>
<a name="793"><span class="lineNum">     793 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="794"><span class="lineNum">     794 </span>            :                                                 2249_error,</a>
<a name="795"><span class="lineNum">     795 </span><span class="lineNoCov">          0 :                                                 nativeLocationOf(_identifier),</span></a>
<a name="796"><span class="lineNum">     796 </span>            :                                                 &quot;Constant variables with non-literal values cannot be forward referenced from inline assembly.&quot;</a>
<a name="797"><span class="lineNum">     797 </span>            :                                         );</a>
<a name="798"><span class="lineNum">     798 </span><span class="lineNoCov">          0 :                                         return false;</span></a>
<a name="799"><span class="lineNum">     799 </span>            :                                 }</a>
<a name="800"><span class="lineNum">     800 </span><span class="lineCov">          2 :                                 else if (!var || !type(*var)-&gt;isValueType() || (</span></a>
<a name="801"><span class="lineNum">     801 </span><span class="lineCov">          1 :                                         !dynamic_cast&lt;Literal const*&gt;(var-&gt;value().get()) &amp;&amp;</span></a>
<a name="802"><span class="lineNum">     802 </span><span class="lineNoCov">          0 :                                         type(*var-&gt;value())-&gt;category() != Type::Category::RationalNumber</span></a>
<a name="803"><span class="lineNum">     803 </span>            :                                 ))</a>
<a name="804"><span class="lineNum">     804 </span>            :                                 {</a>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(7615_error, nativeLocationOf(_identifier), &quot;Only direct number constants and references to such constants are supported by inline assembly.&quot;);</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :                                         return false;</span></a>
<a name="807"><span class="lineNum">     807 </span>            :                                 }</a>
<a name="808"><span class="lineNum">     808 </span>            :                         }</a>
<a name="809"><span class="lineNum">     809 </span>            : </a>
<a name="810"><span class="lineNum">     810 </span><span class="lineCov">        175 :                         solAssert(!dynamic_cast&lt;FixedPointType const*&gt;(var-&gt;type()), &quot;FixedPointType not implemented.&quot;);</span></a>
<a name="811"><span class="lineNum">     811 </span>            : </a>
<a name="812"><span class="lineNum">     812 </span><span class="lineCov">        175 :                         if (!identifierInfo.suffix.empty())</span></a>
<a name="813"><span class="lineNum">     813 </span>            :                         {</a>
<a name="814"><span class="lineNum">     814 </span><span class="lineNoCov">          0 :                                 std::string const&amp; suffix = identifierInfo.suffix;</span></a>
<a name="815"><span class="lineNum">     815 </span><span class="lineNoCov">          0 :                                 solAssert((std::set&lt;std::string&gt;{&quot;offset&quot;, &quot;slot&quot;, &quot;length&quot;, &quot;selector&quot;, &quot;address&quot;}).count(suffix), &quot;&quot;);</span></a>
<a name="816"><span class="lineNum">     816 </span><span class="lineNoCov">          0 :                                 if (!var-&gt;isConstant() &amp;&amp; (var-&gt;isStateVariable() || var-&gt;type()-&gt;dataStoredIn(DataLocation::Storage)))</span></a>
<a name="817"><span class="lineNum">     817 </span>            :                                 {</a>
<a name="818"><span class="lineNum">     818 </span><span class="lineNoCov">          0 :                                         if (suffix != &quot;slot&quot; &amp;&amp; suffix != &quot;offset&quot;)</span></a>
<a name="819"><span class="lineNum">     819 </span>            :                                         {</a>
<a name="820"><span class="lineNum">     820 </span><span class="lineNoCov">          0 :                                                 m_errorReporter.typeError(4656_error, nativeLocationOf(_identifier), &quot;State variables only support \&quot;.slot\&quot; and \&quot;.offset\&quot;.&quot;);</span></a>
<a name="821"><span class="lineNum">     821 </span><span class="lineNoCov">          0 :                                                 return false;</span></a>
<a name="822"><span class="lineNum">     822 </span>            :                                         }</a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :                                         else if (_context == yul::IdentifierContext::LValue)</span></a>
<a name="824"><span class="lineNum">     824 </span>            :                                         {</a>
<a name="825"><span class="lineNum">     825 </span><span class="lineNoCov">          0 :                                                 if (var-&gt;isStateVariable())</span></a>
<a name="826"><span class="lineNum">     826 </span>            :                                                 {</a>
<a name="827"><span class="lineNum">     827 </span><span class="lineNoCov">          0 :                                                         m_errorReporter.typeError(4713_error, nativeLocationOf(_identifier), &quot;State variables cannot be assigned to - you have to use \&quot;sstore()\&quot; or \&quot;tstore()\&quot;.&quot;);</span></a>
<a name="828"><span class="lineNum">     828 </span><span class="lineNoCov">          0 :                                                         return false;</span></a>
<a name="829"><span class="lineNum">     829 </span>            :                                                 }</a>
<a name="830"><span class="lineNum">     830 </span><span class="lineNoCov">          0 :                                                 else if (suffix != &quot;slot&quot;)</span></a>
<a name="831"><span class="lineNum">     831 </span>            :                                                 {</a>
<a name="832"><span class="lineNum">     832 </span><span class="lineNoCov">          0 :                                                         m_errorReporter.typeError(9739_error, nativeLocationOf(_identifier), &quot;Only .slot can be assigned to.&quot;);</span></a>
<a name="833"><span class="lineNum">     833 </span><span class="lineNoCov">          0 :                                                         return false;</span></a>
<a name="834"><span class="lineNum">     834 </span>            :                                                 }</a>
<a name="835"><span class="lineNum">     835 </span>            :                                         }</a>
<a name="836"><span class="lineNum">     836 </span>            :                                 }</a>
<a name="837"><span class="lineNum">     837 </span><span class="lineNoCov">          0 :                                 else if (</span></a>
<a name="838"><span class="lineNum">     838 </span><span class="lineNoCov">          0 :                                         auto const* arrayType = dynamic_cast&lt;ArrayType const*&gt;(var-&gt;type());</span></a>
<a name="839"><span class="lineNum">     839 </span><span class="lineNoCov">          0 :                                         arrayType &amp;&amp; arrayType-&gt;isDynamicallySized() &amp;&amp; arrayType-&gt;dataStoredIn(DataLocation::CallData)</span></a>
<a name="840"><span class="lineNum">     840 </span>            :                                 )</a>
<a name="841"><span class="lineNum">     841 </span>            :                                 {</a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :                                         if (suffix != &quot;offset&quot; &amp;&amp; suffix != &quot;length&quot;)</span></a>
<a name="843"><span class="lineNum">     843 </span>            :                                         {</a>
<a name="844"><span class="lineNum">     844 </span><span class="lineNoCov">          0 :                                                 m_errorReporter.typeError(1536_error, nativeLocationOf(_identifier), &quot;Calldata variables only support \&quot;.offset\&quot; and \&quot;.length\&quot;.&quot;);</span></a>
<a name="845"><span class="lineNum">     845 </span><span class="lineNoCov">          0 :                                                 return false;</span></a>
<a name="846"><span class="lineNum">     846 </span>            :                                         }</a>
<a name="847"><span class="lineNum">     847 </span>            :                                 }</a>
<a name="848"><span class="lineNum">     848 </span><span class="lineNoCov">          0 :                                 else if (auto const* fpType = dynamic_cast&lt;FunctionTypePointer&gt;(var-&gt;type()))</span></a>
<a name="849"><span class="lineNum">     849 </span>            :                                 {</a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :                                         if (suffix != &quot;selector&quot; &amp;&amp; suffix != &quot;address&quot;)</span></a>
<a name="851"><span class="lineNum">     851 </span>            :                                         {</a>
<a name="852"><span class="lineNum">     852 </span><span class="lineNoCov">          0 :                                                 m_errorReporter.typeError(9272_error, nativeLocationOf(_identifier), &quot;Variables of type function pointer only support \&quot;.selector\&quot; and \&quot;.address\&quot;.&quot;);</span></a>
<a name="853"><span class="lineNum">     853 </span><span class="lineNoCov">          0 :                                                 return false;</span></a>
<a name="854"><span class="lineNum">     854 </span>            :                                         }</a>
<a name="855"><span class="lineNum">     855 </span><span class="lineNoCov">          0 :                                         if (fpType-&gt;kind() != FunctionType::Kind::External)</span></a>
<a name="856"><span class="lineNum">     856 </span>            :                                         {</a>
<a name="857"><span class="lineNum">     857 </span><span class="lineNoCov">          0 :                                                 m_errorReporter.typeError(8533_error, nativeLocationOf(_identifier), &quot;Only Variables of type external function pointer support \&quot;.selector\&quot; and \&quot;.address\&quot;.&quot;);</span></a>
<a name="858"><span class="lineNum">     858 </span><span class="lineNoCov">          0 :                                                 return false;</span></a>
<a name="859"><span class="lineNum">     859 </span>            :                                         }</a>
<a name="860"><span class="lineNum">     860 </span>            :                                 }</a>
<a name="861"><span class="lineNum">     861 </span>            :                                 else</a>
<a name="862"><span class="lineNum">     862 </span>            :                                 {</a>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(3622_error, nativeLocationOf(_identifier), &quot;The suffix \&quot;.&quot; + suffix + &quot;\&quot; is not supported by this variable or type.&quot;);</span></a>
<a name="864"><span class="lineNum">     864 </span><span class="lineNoCov">          0 :                                         return false;</span></a>
<a name="865"><span class="lineNum">     865 </span>            :                                 }</a>
<a name="866"><span class="lineNum">     866 </span>            :                         }</a>
<a name="867"><span class="lineNum">     867 </span><span class="lineCov">        175 :                         else if (!var-&gt;isConstant() &amp;&amp; var-&gt;isStateVariable())</span></a>
<a name="868"><span class="lineNum">     868 </span>            :                         {</a>
<a name="869"><span class="lineNum">     869 </span><span class="lineCov">         30 :                                 m_errorReporter.typeError(</span></a>
<a name="870"><span class="lineNum">     870 </span>            :                                         1408_error,</a>
<a name="871"><span class="lineNum">     871 </span><span class="lineCov">         20 :                                         nativeLocationOf(_identifier),</span></a>
<a name="872"><span class="lineNum">     872 </span>            :                                         &quot;Only local variables are supported. To access state variables, use the \&quot;.slot\&quot; and \&quot;.offset\&quot; suffixes.&quot;</a>
<a name="873"><span class="lineNum">     873 </span>            :                                 );</a>
<a name="874"><span class="lineNum">     874 </span><span class="lineCov">         10 :                                 return false;</span></a>
<a name="875"><span class="lineNum">     875 </span>            :                         }</a>
<a name="876"><span class="lineNum">     876 </span><span class="lineCov">        165 :                         else if (var-&gt;type()-&gt;dataStoredIn(DataLocation::Storage))</span></a>
<a name="877"><span class="lineNum">     877 </span>            :                         {</a>
<a name="878"><span class="lineNum">     878 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(9068_error, nativeLocationOf(_identifier), &quot;You have to use the \&quot;.slot\&quot; or \&quot;.offset\&quot; suffix to access storage reference variables.&quot;);</span></a>
<a name="879"><span class="lineNum">     879 </span><span class="lineNoCov">          0 :                                 return false;</span></a>
<a name="880"><span class="lineNum">     880 </span>            :                         }</a>
<a name="881"><span class="lineNum">     881 </span><span class="lineCov">        165 :                         else if (var-&gt;type()-&gt;sizeOnStack() != 1)</span></a>
<a name="882"><span class="lineNum">     882 </span>            :                         {</a>
<a name="883"><span class="lineNum">     883 </span><span class="lineNoCov">          0 :                                 if (</span></a>
<a name="884"><span class="lineNum">     884 </span><span class="lineNoCov">          0 :                                         auto const* arrayType = dynamic_cast&lt;ArrayType const*&gt;(var-&gt;type());</span></a>
<a name="885"><span class="lineNum">     885 </span><span class="lineNoCov">          0 :                                         arrayType &amp;&amp; arrayType-&gt;isDynamicallySized() &amp;&amp; arrayType-&gt;dataStoredIn(DataLocation::CallData)</span></a>
<a name="886"><span class="lineNum">     886 </span>            :                                 )</a>
<a name="887"><span class="lineNum">     887 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(1397_error, nativeLocationOf(_identifier), &quot;Call data elements cannot be accessed directly. Use \&quot;.offset\&quot; and \&quot;.length\&quot; to access the calldata offset and length of this array and then use \&quot;calldatacopy\&quot;.&quot;);</span></a>
<a name="888"><span class="lineNum">     888 </span>            :                                 else</a>
<a name="889"><span class="lineNum">     889 </span>            :                                 {</a>
<a name="890"><span class="lineNum">     890 </span><span class="lineNoCov">          0 :                                         solAssert(!var-&gt;type()-&gt;dataStoredIn(DataLocation::CallData), &quot;&quot;);</span></a>
<a name="891"><span class="lineNum">     891 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(9857_error, nativeLocationOf(_identifier), &quot;Only types that use one stack slot are supported.&quot;);</span></a>
<a name="892"><span class="lineNum">     892 </span>            :                                 }</a>
<a name="893"><span class="lineNum">     893 </span><span class="lineNoCov">          0 :                                 return false;</span></a>
<a name="894"><span class="lineNum">     894 </span>            :                         }</a>
<a name="895"><span class="lineNum">     895 </span>            :                 }</a>
<a name="896"><span class="lineNum">     896 </span><span class="lineNoCov">          0 :                 else if (!identifierInfo.suffix.empty())</span></a>
<a name="897"><span class="lineNum">     897 </span>            :                 {</a>
<a name="898"><span class="lineNum">     898 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(7944_error, nativeLocationOf(_identifier), &quot;The suffixes \&quot;.offset\&quot;, \&quot;.slot\&quot; and \&quot;.length\&quot; can only be used with variables.&quot;);</span></a>
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 :                         return false;</span></a>
<a name="900"><span class="lineNum">     900 </span>            :                 }</a>
<a name="901"><span class="lineNum">     901 </span><span class="lineNoCov">          0 :                 else if (_context == yul::IdentifierContext::LValue)</span></a>
<a name="902"><span class="lineNum">     902 </span>            :                 {</a>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 :                         if (dynamic_cast&lt;MagicVariableDeclaration const*&gt;(declaration))</span></a>
<a name="904"><span class="lineNum">     904 </span><span class="lineNoCov">          0 :                                 return false;</span></a>
<a name="905"><span class="lineNum">     905 </span>            : </a>
<a name="906"><span class="lineNum">     906 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(1990_error, nativeLocationOf(_identifier), &quot;Only local variables can be assigned to in inline assembly.&quot;);</span></a>
<a name="907"><span class="lineNum">     907 </span><span class="lineNoCov">          0 :                         return false;</span></a>
<a name="908"><span class="lineNum">     908 </span>            :                 }</a>
<a name="909"><span class="lineNum">     909 </span>            : </a>
<a name="910"><span class="lineNum">     910 </span><span class="lineCov">        165 :                 if (_context == yul::IdentifierContext::RValue)</span></a>
<a name="911"><span class="lineNum">     911 </span>            :                 {</a>
<a name="912"><span class="lineNum">     912 </span><span class="lineCov">         82 :                         solAssert(!!declaration-&gt;type(), &quot;Type of declaration required but not yet determined.&quot;);</span></a>
<a name="913"><span class="lineNum">     913 </span><span class="lineCov">         82 :                         if (dynamic_cast&lt;FunctionDefinition const*&gt;(declaration))</span></a>
<a name="914"><span class="lineNum">     914 </span>            :                         {</a>
<a name="915"><span class="lineNum">     915 </span><span class="lineNoCov">          0 :                                 m_errorReporter.declarationError(2025_error, nativeLocationOf(_identifier), &quot;Access to functions is not allowed in inline assembly.&quot;);</span></a>
<a name="916"><span class="lineNum">     916 </span><span class="lineNoCov">          0 :                                 return false;</span></a>
<a name="917"><span class="lineNum">     917 </span>            :                         }</a>
<a name="918"><span class="lineNum">     918 </span><span class="lineCov">         82 :                         else if (dynamic_cast&lt;VariableDeclaration const*&gt;(declaration))</span></a>
<a name="919"><span class="lineNum">     919 </span>            :                         {</a>
<a name="920"><span class="lineNum">     920 </span>            :                         }</a>
<a name="921"><span class="lineNum">     921 </span><span class="lineNoCov">          0 :                         else if (auto contract = dynamic_cast&lt;ContractDefinition const*&gt;(declaration))</span></a>
<a name="922"><span class="lineNum">     922 </span>            :                         {</a>
<a name="923"><span class="lineNum">     923 </span><span class="lineNoCov">          0 :                                 if (!contract-&gt;isLibrary())</span></a>
<a name="924"><span class="lineNum">     924 </span>            :                                 {</a>
<a name="925"><span class="lineNum">     925 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(4977_error, nativeLocationOf(_identifier), &quot;Expected a library.&quot;);</span></a>
<a name="926"><span class="lineNum">     926 </span><span class="lineNoCov">          0 :                                         return false;</span></a>
<a name="927"><span class="lineNum">     927 </span>            :                                 }</a>
<a name="928"><span class="lineNum">     928 </span>            :                         }</a>
<a name="929"><span class="lineNum">     929 </span>            :                         else</a>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 :                                 return false;</span></a>
<a name="931"><span class="lineNum">     931 </span>            :                 }</a>
<a name="932"><span class="lineNum">     932 </span><span class="lineCov">        165 :                 identifierInfo.valueSize = 1;</span></a>
<a name="933"><span class="lineNum">     933 </span><span class="lineCov">        165 :                 return true;</span></a>
<a name="934"><span class="lineNum">     934 </span><span class="lineCov">        204 :         };</span></a>
<a name="935"><span class="lineNum">     935 </span><span class="lineCov">        102 :         solAssert(!_inlineAssembly.annotation().analysisInfo, &quot;&quot;);</span></a>
<a name="936"><span class="lineNum">     936 </span><span class="lineCov">        102 :         _inlineAssembly.annotation().analysisInfo = std::make_shared&lt;yul::AsmAnalysisInfo&gt;();</span></a>
<a name="937"><span class="lineNum">     937 </span>            :         yul::AsmAnalyzer analyzer(</a>
<a name="938"><span class="lineNum">     938 </span><span class="lineCov">        102 :                 *_inlineAssembly.annotation().analysisInfo,</span></a>
<a name="939"><span class="lineNum">     939 </span>            :                 m_errorReporter,</a>
<a name="940"><span class="lineNum">     940 </span>            :                 _inlineAssembly.dialect(),</a>
<a name="941"><span class="lineNum">     941 </span>            :                 identifierAccess</a>
<a name="942"><span class="lineNum">     942 </span><span class="lineCov">        306 :         );</span></a>
<a name="943"><span class="lineNum">     943 </span><span class="lineCov">        102 :         if (!analyzer.analyze(_inlineAssembly.operations().root()))</span></a>
<a name="944"><span class="lineNum">     944 </span><span class="lineCov">         30 :                 solAssert(m_errorReporter.hasErrors());</span></a>
<a name="945"><span class="lineNum">     945 </span><span class="lineCov">        204 :         _inlineAssembly.annotation().hasMemoryEffects =</span></a>
<a name="946"><span class="lineNum">     946 </span><span class="lineCov">        200 :                 lvalueAccessToMemoryVariable ||</span></a>
<a name="947"><span class="lineNum">     947 </span><span class="lineCov">        200 :                 (analyzer.sideEffects().memory != yul::SideEffects::None);</span></a>
<a name="948"><span class="lineNum">     948 </span><span class="lineCov">        204 :         return false;</span></a>
<a name="949"><span class="lineNum">     949 </span>            : }</a>
<a name="950"><span class="lineNum">     950 </span>            : </a>
<a name="951"><span class="lineNum">     951 </span><span class="lineCov">        726 : bool TypeChecker::visit(IfStatement const&amp; _ifStatement)</span></a>
<a name="952"><span class="lineNum">     952 </span>            : {</a>
<a name="953"><span class="lineNum">     953 </span><span class="lineCov">        726 :         expectType(_ifStatement.condition(), *TypeProvider::boolean());</span></a>
<a name="954"><span class="lineNum">     954 </span><span class="lineCov">        721 :         _ifStatement.trueStatement().accept(*this);</span></a>
<a name="955"><span class="lineNum">     955 </span><span class="lineCov">        715 :         if (_ifStatement.falseStatement())</span></a>
<a name="956"><span class="lineNum">     956 </span><span class="lineCov">        255 :                 _ifStatement.falseStatement()-&gt;accept(*this);</span></a>
<a name="957"><span class="lineNum">     957 </span><span class="lineCov">        711 :         return false;</span></a>
<a name="958"><span class="lineNum">     958 </span>            : }</a>
<a name="959"><span class="lineNum">     959 </span>            : </a>
<a name="960"><span class="lineNum">     960 </span><span class="lineNoCov">          0 : void TypeChecker::endVisit(TryStatement const&amp; _tryStatement)</span></a>
<a name="961"><span class="lineNum">     961 </span>            : {</a>
<a name="962"><span class="lineNum">     962 </span><span class="lineNoCov">          0 :         FunctionCall const* externalCall = dynamic_cast&lt;FunctionCall const*&gt;(&amp;_tryStatement.externalCall());</span></a>
<a name="963"><span class="lineNum">     963 </span><span class="lineNoCov">          0 :         if (!externalCall || *externalCall-&gt;annotation().kind != FunctionCallKind::FunctionCall)</span></a>
<a name="964"><span class="lineNum">     964 </span>            :         {</a>
<a name="965"><span class="lineNum">     965 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="966"><span class="lineNum">     966 </span>            :                         5347_error,</a>
<a name="967"><span class="lineNum">     967 </span><span class="lineNoCov">          0 :                         _tryStatement.externalCall().location(),</span></a>
<a name="968"><span class="lineNum">     968 </span>            :                         &quot;Try can only be used with external function calls and contract creation calls.&quot;</a>
<a name="969"><span class="lineNum">     969 </span>            :                 );</a>
<a name="970"><span class="lineNum">     970 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="971"><span class="lineNum">     971 </span>            :         }</a>
<a name="972"><span class="lineNum">     972 </span>            : </a>
<a name="973"><span class="lineNum">     973 </span><span class="lineNoCov">          0 :         FunctionType const&amp; functionType = dynamic_cast&lt;FunctionType const&amp;&gt;(*externalCall-&gt;expression().annotation().type);</span></a>
<a name="974"><span class="lineNum">     974 </span><span class="lineNoCov">          0 :         if (</span></a>
<a name="975"><span class="lineNum">     975 </span><span class="lineNoCov">          0 :                 functionType.kind() != FunctionType::Kind::External &amp;&amp;</span></a>
<a name="976"><span class="lineNum">     976 </span><span class="lineNoCov">          0 :                 functionType.kind() != FunctionType::Kind::Creation &amp;&amp;</span></a>
<a name="977"><span class="lineNum">     977 </span><span class="lineNoCov">          0 :                 functionType.kind() != FunctionType::Kind::DelegateCall</span></a>
<a name="978"><span class="lineNum">     978 </span>            :         )</a>
<a name="979"><span class="lineNum">     979 </span>            :         {</a>
<a name="980"><span class="lineNum">     980 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="981"><span class="lineNum">     981 </span>            :                         2536_error,</a>
<a name="982"><span class="lineNum">     982 </span><span class="lineNoCov">          0 :                         _tryStatement.externalCall().location(),</span></a>
<a name="983"><span class="lineNum">     983 </span>            :                         &quot;Try can only be used with external function calls and contract creation calls.&quot;</a>
<a name="984"><span class="lineNum">     984 </span>            :                 );</a>
<a name="985"><span class="lineNum">     985 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="986"><span class="lineNum">     986 </span>            :         }</a>
<a name="987"><span class="lineNum">     987 </span>            : </a>
<a name="988"><span class="lineNum">     988 </span><span class="lineNoCov">          0 :         externalCall-&gt;annotation().tryCall = true;</span></a>
<a name="989"><span class="lineNum">     989 </span>            : </a>
<a name="990"><span class="lineNum">     990 </span><span class="lineNoCov">          0 :         solAssert(_tryStatement.clauses().size() &gt;= 2, &quot;&quot;);</span></a>
<a name="991"><span class="lineNum">     991 </span><span class="lineNoCov">          0 :         solAssert(_tryStatement.clauses().front(), &quot;&quot;);</span></a>
<a name="992"><span class="lineNum">     992 </span>            : </a>
<a name="993"><span class="lineNum">     993 </span><span class="lineNoCov">          0 :         TryCatchClause const&amp; successClause = *_tryStatement.clauses().front();</span></a>
<a name="994"><span class="lineNum">     994 </span><span class="lineNoCov">          0 :         if (successClause.parameters())</span></a>
<a name="995"><span class="lineNum">     995 </span>            :         {</a>
<a name="996"><span class="lineNum">     996 </span>            :                 TypePointers returnTypes =</a>
<a name="997"><span class="lineNum">     997 </span><span class="lineNoCov">          0 :                         m_evmVersion.supportsReturndata() ?</span></a>
<a name="998"><span class="lineNum">     998 </span><span class="lineNoCov">          0 :                         functionType.returnParameterTypes() :</span></a>
<a name="999"><span class="lineNum">     999 </span><span class="lineNoCov">          0 :                         functionType.returnParameterTypesWithoutDynamicTypes();</span></a>
<a name="1000"><span class="lineNum">    1000 </span>            :                 std::vector&lt;ASTPointer&lt;VariableDeclaration&gt;&gt; const&amp; parameters =</a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineNoCov">          0 :                         successClause.parameters()-&gt;parameters();</span></a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineNoCov">          0 :                 if (returnTypes.size() != parameters.size())</span></a>
<a name="1003"><span class="lineNum">    1003 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="1004"><span class="lineNum">    1004 </span>            :                                 2800_error,</a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                                 successClause.location(),</span></a>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineNoCov">          0 :                                 &quot;Function returns &quot; +</span></a>
<a name="1007"><span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                                 std::to_string(functionType.returnParameterTypes().size()) +</span></a>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                                 &quot; values, but returns clause has &quot; +</span></a>
<a name="1009"><span class="lineNum">    1009 </span><span class="lineNoCov">          0 :                                 std::to_string(parameters.size()) +</span></a>
<a name="1010"><span class="lineNum">    1010 </span>            :                                 &quot; variables.&quot;</a>
<a name="1011"><span class="lineNum">    1011 </span>            :                         );</a>
<a name="1012"><span class="lineNum">    1012 </span><span class="lineNoCov">          0 :                 for (auto&amp;&amp; [parameter, returnType]: ranges::views::zip(parameters, returnTypes))</span></a>
<a name="1013"><span class="lineNum">    1013 </span>            :                 {</a>
<a name="1014"><span class="lineNum">    1014 </span><span class="lineNoCov">          0 :                         solAssert(returnType, &quot;&quot;);</span></a>
<a name="1015"><span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                         if (parameter &amp;&amp; *parameter-&gt;annotation().type != *returnType)</span></a>
<a name="1016"><span class="lineNum">    1016 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="1017"><span class="lineNum">    1017 </span>            :                                         6509_error,</a>
<a name="1018"><span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                                         parameter-&gt;location(),</span></a>
<a name="1019"><span class="lineNum">    1019 </span><span class="lineNoCov">          0 :                                         &quot;Invalid type, expected &quot; +</span></a>
<a name="1020"><span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                                         returnType-&gt;humanReadableName() +</span></a>
<a name="1021"><span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                                         &quot; but got &quot; +</span></a>
<a name="1022"><span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                                         parameter-&gt;annotation().type-&gt;humanReadableName() +</span></a>
<a name="1023"><span class="lineNum">    1023 </span>            :                                         &quot;.&quot;</a>
<a name="1024"><span class="lineNum">    1024 </span>            :                                 );</a>
<a name="1025"><span class="lineNum">    1025 </span>            :                 }</a>
<a name="1026"><span class="lineNum">    1026 </span>            :         }</a>
<a name="1027"><span class="lineNum">    1027 </span>            : </a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineNoCov">          0 :         TryCatchClause const* panicClause = nullptr;</span></a>
<a name="1029"><span class="lineNum">    1029 </span><span class="lineNoCov">          0 :         TryCatchClause const* errorClause = nullptr;</span></a>
<a name="1030"><span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         TryCatchClause const* lowLevelClause = nullptr;</span></a>
<a name="1031"><span class="lineNum">    1031 </span><span class="lineNoCov">          0 :         for (auto const&amp; clause: _tryStatement.clauses() | ranges::views::drop_exactly(1) | views::dereferenceChecked)</span></a>
<a name="1032"><span class="lineNum">    1032 </span>            :         {</a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                 if (clause.errorName() == &quot;&quot;)</span></a>
<a name="1034"><span class="lineNum">    1034 </span>            :                 {</a>
<a name="1035"><span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                         if (lowLevelClause)</span></a>
<a name="1036"><span class="lineNum">    1036 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="1037"><span class="lineNum">    1037 </span>            :                                         5320_error,</a>
<a name="1038"><span class="lineNum">    1038 </span><span class="lineNoCov">          0 :                                         clause.location(),</span></a>
<a name="1039"><span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                                         SecondarySourceLocation{}.append(&quot;The first clause is here:&quot;, lowLevelClause-&gt;location()),</span></a>
<a name="1040"><span class="lineNum">    1040 </span>            :                                         &quot;This try statement already has a low-level catch clause.&quot;</a>
<a name="1041"><span class="lineNum">    1041 </span>            :                                 );</a>
<a name="1042"><span class="lineNum">    1042 </span><span class="lineNoCov">          0 :                         lowLevelClause = &amp;clause;</span></a>
<a name="1043"><span class="lineNum">    1043 </span><span class="lineNoCov">          0 :                         if (clause.parameters() &amp;&amp; !clause.parameters()-&gt;parameters().empty())</span></a>
<a name="1044"><span class="lineNum">    1044 </span>            :                         {</a>
<a name="1045"><span class="lineNum">    1045 </span><span class="lineNoCov">          0 :                                 if (</span></a>
<a name="1046"><span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                                         clause.parameters()-&gt;parameters().size() != 1 ||</span></a>
<a name="1047"><span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                                         *clause.parameters()-&gt;parameters().front()-&gt;type() != *TypeProvider::bytesMemory()</span></a>
<a name="1048"><span class="lineNum">    1048 </span>            :                                 )</a>
<a name="1049"><span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(6231_error, clause.location(), &quot;Expected `catch (bytes memory ...) { ... }` or `catch { ... }`.&quot;);</span></a>
<a name="1050"><span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                                 if (!m_evmVersion.supportsReturndata())</span></a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="1052"><span class="lineNum">    1052 </span>            :                                                 9908_error,</a>
<a name="1053"><span class="lineNum">    1053 </span><span class="lineNoCov">          0 :                                                 clause.location(),</span></a>
<a name="1054"><span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                                                 &quot;This catch clause type cannot be used on the selected EVM version (&quot; +</span></a>
<a name="1055"><span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                                                 m_evmVersion.name() +</span></a>
<a name="1056"><span class="lineNum">    1056 </span>            :                                                 &quot;). You need at least a Byzantium-compatible EVM or use `catch { ... }`.&quot;</a>
<a name="1057"><span class="lineNum">    1057 </span>            :                                         );</a>
<a name="1058"><span class="lineNum">    1058 </span>            :                         }</a>
<a name="1059"><span class="lineNum">    1059 </span>            :                 }</a>
<a name="1060"><span class="lineNum">    1060 </span><span class="lineNoCov">          0 :                 else if (clause.errorName() == &quot;Error&quot; || clause.errorName() == &quot;Panic&quot;)</span></a>
<a name="1061"><span class="lineNum">    1061 </span>            :                 {</a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineNoCov">          0 :                         if (!m_evmVersion.supportsReturndata())</span></a>
<a name="1063"><span class="lineNum">    1063 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="1064"><span class="lineNum">    1064 </span>            :                                         1812_error,</a>
<a name="1065"><span class="lineNum">    1065 </span><span class="lineNoCov">          0 :                                         clause.location(),</span></a>
<a name="1066"><span class="lineNum">    1066 </span><span class="lineNoCov">          0 :                                         &quot;This catch clause type cannot be used on the selected EVM version (&quot; +</span></a>
<a name="1067"><span class="lineNum">    1067 </span><span class="lineNoCov">          0 :                                         m_evmVersion.name() +</span></a>
<a name="1068"><span class="lineNum">    1068 </span>            :                                         &quot;). You need at least a Byzantium-compatible EVM or use `catch { ... }`.&quot;</a>
<a name="1069"><span class="lineNum">    1069 </span>            :                                 );</a>
<a name="1070"><span class="lineNum">    1070 </span>            : </a>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                         if (clause.errorName() == &quot;Error&quot;)</span></a>
<a name="1072"><span class="lineNum">    1072 </span>            :                         {</a>
<a name="1073"><span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                                 if (errorClause)</span></a>
<a name="1074"><span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="1075"><span class="lineNum">    1075 </span>            :                                                 1036_error,</a>
<a name="1076"><span class="lineNum">    1076 </span><span class="lineNoCov">          0 :                                                 clause.location(),</span></a>
<a name="1077"><span class="lineNum">    1077 </span><span class="lineNoCov">          0 :                                                 SecondarySourceLocation{}.append(&quot;The first clause is here:&quot;, errorClause-&gt;location()),</span></a>
<a name="1078"><span class="lineNum">    1078 </span>            :                                                 &quot;This try statement already has an \&quot;Error\&quot; catch clause.&quot;</a>
<a name="1079"><span class="lineNum">    1079 </span>            :                                         );</a>
<a name="1080"><span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                                 errorClause = &amp;clause;</span></a>
<a name="1081"><span class="lineNum">    1081 </span><span class="lineNoCov">          0 :                                 if (</span></a>
<a name="1082"><span class="lineNum">    1082 </span><span class="lineNoCov">          0 :                                         !clause.parameters() ||</span></a>
<a name="1083"><span class="lineNum">    1083 </span><span class="lineNoCov">          0 :                                         clause.parameters()-&gt;parameters().size() != 1 ||</span></a>
<a name="1084"><span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                                         *clause.parameters()-&gt;parameters().front()-&gt;type() != *TypeProvider::stringMemory()</span></a>
<a name="1085"><span class="lineNum">    1085 </span>            :                                 )</a>
<a name="1086"><span class="lineNum">    1086 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(2943_error, clause.location(), &quot;Expected `catch Error(string memory ...) { ... }`.&quot;);</span></a>
<a name="1087"><span class="lineNum">    1087 </span>            :                         }</a>
<a name="1088"><span class="lineNum">    1088 </span>            :                         else</a>
<a name="1089"><span class="lineNum">    1089 </span>            :                         {</a>
<a name="1090"><span class="lineNum">    1090 </span><span class="lineNoCov">          0 :                                 if (panicClause)</span></a>
<a name="1091"><span class="lineNum">    1091 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="1092"><span class="lineNum">    1092 </span>            :                                                 6732_error,</a>
<a name="1093"><span class="lineNum">    1093 </span><span class="lineNoCov">          0 :                                                 clause.location(),</span></a>
<a name="1094"><span class="lineNum">    1094 </span><span class="lineNoCov">          0 :                                                 SecondarySourceLocation{}.append(&quot;The first clause is here:&quot;, panicClause-&gt;location()),</span></a>
<a name="1095"><span class="lineNum">    1095 </span>            :                                                 &quot;This try statement already has a \&quot;Panic\&quot; catch clause.&quot;</a>
<a name="1096"><span class="lineNum">    1096 </span>            :                                         );</a>
<a name="1097"><span class="lineNum">    1097 </span><span class="lineNoCov">          0 :                                 panicClause = &amp;clause;</span></a>
<a name="1098"><span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                                 if (</span></a>
<a name="1099"><span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                                         !clause.parameters() ||</span></a>
<a name="1100"><span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                                         clause.parameters()-&gt;parameters().size() != 1 ||</span></a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                                         *clause.parameters()-&gt;parameters().front()-&gt;type() != *TypeProvider::uint256()</span></a>
<a name="1102"><span class="lineNum">    1102 </span>            :                                 )</a>
<a name="1103"><span class="lineNum">    1103 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(1271_error, clause.location(), &quot;Expected `catch Panic(uint ...) { ... }`.&quot;);</span></a>
<a name="1104"><span class="lineNum">    1104 </span>            :                         }</a>
<a name="1105"><span class="lineNum">    1105 </span>            :                 }</a>
<a name="1106"><span class="lineNum">    1106 </span>            :                 else</a>
<a name="1107"><span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="1108"><span class="lineNum">    1108 </span>            :                                 3542_error,</a>
<a name="1109"><span class="lineNum">    1109 </span><span class="lineNoCov">          0 :                                 clause.location(),</span></a>
<a name="1110"><span class="lineNum">    1110 </span>            :                                 &quot;Invalid catch clause name. Expected either `catch (...)`, `catch Error(...)`, or `catch Panic(...)`.&quot;</a>
<a name="1111"><span class="lineNum">    1111 </span>            :                         );</a>
<a name="1112"><span class="lineNum">    1112 </span>            :         }</a>
<a name="1113"><span class="lineNum">    1113 </span>            : }</a>
<a name="1114"><span class="lineNum">    1114 </span>            : </a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineCov">        139 : bool TypeChecker::visit(WhileStatement const&amp; _whileStatement)</span></a>
<a name="1116"><span class="lineNum">    1116 </span>            : {</a>
<a name="1117"><span class="lineNum">    1117 </span><span class="lineCov">        139 :         expectType(_whileStatement.condition(), *TypeProvider::boolean());</span></a>
<a name="1118"><span class="lineNum">    1118 </span><span class="lineCov">        138 :         _whileStatement.body().accept(*this);</span></a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineCov">        136 :         return false;</span></a>
<a name="1120"><span class="lineNum">    1120 </span>            : }</a>
<a name="1121"><span class="lineNum">    1121 </span>            : </a>
<a name="1122"><span class="lineNum">    1122 </span><span class="lineCov">         59 : bool TypeChecker::visit(ForStatement const&amp; _forStatement)</span></a>
<a name="1123"><span class="lineNum">    1123 </span>            : {</a>
<a name="1124"><span class="lineNum">    1124 </span><span class="lineCov">         59 :         if (_forStatement.initializationExpression())</span></a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineCov">         59 :                 _forStatement.initializationExpression()-&gt;accept(*this);</span></a>
<a name="1126"><span class="lineNum">    1126 </span><span class="lineCov">         59 :         if (_forStatement.condition())</span></a>
<a name="1127"><span class="lineNum">    1127 </span><span class="lineCov">         59 :                 expectType(*_forStatement.condition(), *TypeProvider::boolean());</span></a>
<a name="1128"><span class="lineNum">    1128 </span><span class="lineCov">         59 :         if (_forStatement.loopExpression())</span></a>
<a name="1129"><span class="lineNum">    1129 </span><span class="lineCov">         54 :                 _forStatement.loopExpression()-&gt;accept(*this);</span></a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineCov">         59 :         _forStatement.body().accept(*this);</span></a>
<a name="1131"><span class="lineNum">    1131 </span><span class="lineCov">         54 :         return false;</span></a>
<a name="1132"><span class="lineNum">    1132 </span>            : }</a>
<a name="1133"><span class="lineNum">    1133 </span>            : </a>
<a name="1134"><span class="lineNum">    1134 </span><span class="lineCov">       2879 : void TypeChecker::endVisit(Return const&amp; _return)</span></a>
<a name="1135"><span class="lineNum">    1135 </span>            : {</a>
<a name="1136"><span class="lineNum">    1136 </span><span class="lineCov">       2879 :         ParameterList const* params = _return.annotation().functionReturnParameters;</span></a>
<a name="1137"><span class="lineNum">    1137 </span><span class="lineCov">       2879 :         if (!_return.expression())</span></a>
<a name="1138"><span class="lineNum">    1138 </span>            :         {</a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineCov">        105 :                 if (params &amp;&amp; !params-&gt;parameters().empty())</span></a>
<a name="1140"><span class="lineNum">    1140 </span><span class="lineCov">         11 :                         m_errorReporter.typeError(6777_error, _return.location(), &quot;Return arguments required.&quot;);</span></a>
<a name="1141"><span class="lineNum">    1141 </span><span class="lineCov">        109 :                 return;</span></a>
<a name="1142"><span class="lineNum">    1142 </span>            :         }</a>
<a name="1143"><span class="lineNum">    1143 </span><span class="lineCov">       2774 :         if (!params)</span></a>
<a name="1144"><span class="lineNum">    1144 </span>            :         {</a>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineCov">          4 :                 m_errorReporter.typeError(7552_error, _return.location(), &quot;Return arguments not allowed.&quot;);</span></a>
<a name="1146"><span class="lineNum">    1146 </span><span class="lineCov">          4 :                 return;</span></a>
<a name="1147"><span class="lineNum">    1147 </span>            :         }</a>
<a name="1148"><span class="lineNum">    1148 </span><span class="lineCov">       5540 :         TypePointers returnTypes;</span></a>
<a name="1149"><span class="lineNum">    1149 </span><span class="lineCov">       5682 :         for (auto const&amp; var: params-&gt;parameters())</span></a>
<a name="1150"><span class="lineNum">    1150 </span><span class="lineCov">       2912 :                 returnTypes.push_back(type(*var));</span></a>
<a name="1151"><span class="lineNum">    1151 </span><span class="lineCov">       2770 :         if (auto tupleType = dynamic_cast&lt;TupleType const*&gt;(type(*_return.expression())))</span></a>
<a name="1152"><span class="lineNum">    1152 </span>            :         {</a>
<a name="1153"><span class="lineNum">    1153 </span><span class="lineCov">        150 :                 if (tupleType-&gt;components().size() != params-&gt;parameters().size())</span></a>
<a name="1154"><span class="lineNum">    1154 </span><span class="lineCov">         11 :                         m_errorReporter.typeError(5132_error, _return.location(), &quot;Different number of arguments in return statement than in returns declaration.&quot;);</span></a>
<a name="1155"><span class="lineNum">    1155 </span>            :                 else</a>
<a name="1156"><span class="lineNum">    1156 </span>            :                 {</a>
<a name="1157"><span class="lineNum">    1157 </span><span class="lineCov">        417 :                         BoolResult result = tupleType-&gt;isImplicitlyConvertibleTo(TupleType(returnTypes));</span></a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineCov">        139 :                         if (!result)</span></a>
<a name="1159"><span class="lineNum">    1159 </span><span class="lineCov">          7 :                                 m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="1160"><span class="lineNum">    1160 </span>            :                                         5992_error,</a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineCov">          7 :                                         _return.expression()-&gt;location(),</span></a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineCov">          7 :                                         &quot;Return argument type &quot; +</span></a>
<a name="1163"><span class="lineNum">    1163 </span><span class="lineCov">         21 :                                         type(*_return.expression())-&gt;humanReadableName() +</span></a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineCov">         14 :                                         &quot; is not implicitly convertible to expected type &quot; +</span></a>
<a name="1165"><span class="lineNum">    1165 </span><span class="lineCov">         28 :                                         TupleType(returnTypes).humanReadableName() + &quot;.&quot;,</span></a>
<a name="1166"><span class="lineNum">    1166 </span><span class="lineCov">          7 :                                         result.message()</span></a>
<a name="1167"><span class="lineNum">    1167 </span>            :                                 );</a>
<a name="1168"><span class="lineNum">    1168 </span>            :                 }</a>
<a name="1169"><span class="lineNum">    1169 </span>            :         }</a>
<a name="1170"><span class="lineNum">    1170 </span><span class="lineCov">       2620 :         else if (params-&gt;parameters().size() != 1)</span></a>
<a name="1171"><span class="lineNum">    1171 </span><span class="lineCov">         77 :                 m_errorReporter.typeError(8863_error, _return.location(), &quot;Different number of arguments in return statement than in returns declaration.&quot;);</span></a>
<a name="1172"><span class="lineNum">    1172 </span>            :         else</a>
<a name="1173"><span class="lineNum">    1173 </span>            :         {</a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineCov">       2543 :                 Type const* expected = type(*params-&gt;parameters().front());</span></a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineCov">       5086 :                 BoolResult result = type(*_return.expression())-&gt;isImplicitlyConvertibleTo(*expected);</span></a>
<a name="1176"><span class="lineNum">    1176 </span><span class="lineCov">       2543 :                 if (!result)</span></a>
<a name="1177"><span class="lineNum">    1177 </span><span class="lineCov">        117 :                         m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="1178"><span class="lineNum">    1178 </span>            :                                 6359_error,</a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineCov">        117 :                                 _return.expression()-&gt;location(),</span></a>
<a name="1180"><span class="lineNum">    1180 </span><span class="lineCov">        117 :                                 &quot;Return argument type &quot; +</span></a>
<a name="1181"><span class="lineNum">    1181 </span><span class="lineCov">        351 :                                 type(*_return.expression())-&gt;humanReadableName() +</span></a>
<a name="1182"><span class="lineNum">    1182 </span><span class="lineCov">        234 :                                 &quot; is not implicitly convertible to expected type (type of first return variable) &quot; +</span></a>
<a name="1183"><span class="lineNum">    1183 </span><span class="lineCov">        468 :                                 expected-&gt;humanReadableName() + &quot;.&quot;,</span></a>
<a name="1184"><span class="lineNum">    1184 </span><span class="lineCov">        117 :                                 result.message()</span></a>
<a name="1185"><span class="lineNum">    1185 </span>            :                         );</a>
<a name="1186"><span class="lineNum">    1186 </span>            :         }</a>
<a name="1187"><span class="lineNum">    1187 </span>            : }</a>
<a name="1188"><span class="lineNum">    1188 </span>            : </a>
<a name="1189"><span class="lineNum">    1189 </span><span class="lineCov">        140 : void TypeChecker::endVisit(EmitStatement const&amp; _emit)</span></a>
<a name="1190"><span class="lineNum">    1190 </span>            : {</a>
<a name="1191"><span class="lineNum">    1191 </span><span class="lineCov">        140 :         if (</span></a>
<a name="1192"><span class="lineNum">    1192 </span><span class="lineCov">        140 :                 *_emit.eventCall().annotation().kind != FunctionCallKind::FunctionCall ||</span></a>
<a name="1193"><span class="lineNum">    1193 </span><span class="lineCov">        279 :                 type(_emit.eventCall().expression())-&gt;category() != Type::Category::Function ||</span></a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineCov">        139 :                 dynamic_cast&lt;FunctionType const&amp;&gt;(*type(_emit.eventCall().expression())).kind() != FunctionType::Kind::Event</span></a>
<a name="1195"><span class="lineNum">    1195 </span>            :         )</a>
<a name="1196"><span class="lineNum">    1196 </span><span class="lineCov">          1 :                 m_errorReporter.typeError(9292_error, _emit.eventCall().expression().location(), &quot;Expression has to be an event invocation.&quot;);</span></a>
<a name="1197"><span class="lineNum">    1197 </span><span class="lineCov">        140 : }</span></a>
<a name="1198"><span class="lineNum">    1198 </span>            : </a>
<a name="1199"><span class="lineNum">    1199 </span><span class="lineNoCov">          0 : void TypeChecker::endVisit(RevertStatement const&amp; _revert)</span></a>
<a name="1200"><span class="lineNum">    1200 </span>            : {</a>
<a name="1201"><span class="lineNum">    1201 </span><span class="lineNoCov">          0 :         FunctionCall const&amp; errorCall = _revert.errorCall();</span></a>
<a name="1202"><span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         if (</span></a>
<a name="1203"><span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                 *errorCall.annotation().kind != FunctionCallKind::FunctionCall ||</span></a>
<a name="1204"><span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                 type(errorCall.expression())-&gt;category() != Type::Category::Function ||</span></a>
<a name="1205"><span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                 dynamic_cast&lt;FunctionType const&amp;&gt;(*type(errorCall.expression())).kind() != FunctionType::Kind::Error</span></a>
<a name="1206"><span class="lineNum">    1206 </span>            :         )</a>
<a name="1207"><span class="lineNum">    1207 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(1885_error, errorCall.expression().location(), &quot;Expression has to be an error.&quot;);</span></a>
<a name="1208"><span class="lineNum">    1208 </span><span class="lineNoCov">          0 : }</span></a>
<a name="1209"><span class="lineNum">    1209 </span>            : </a>
<a name="1210"><span class="lineNum">    1210 </span><span class="lineCov">        690 : void TypeChecker::endVisit(ArrayTypeName const&amp; _typeName)</span></a>
<a name="1211"><span class="lineNum">    1211 </span>            : {</a>
<a name="1212"><span class="lineNum">    1212 </span><span class="lineCov">        690 :         solAssert(</span></a>
<a name="1213"><span class="lineNum">    1213 </span>            :                 _typeName.baseType().annotation().type &amp;&amp;</a>
<a name="1214"><span class="lineNum">    1214 </span>            :                 _typeName.baseType().annotation().type-&gt;storageBytes() != 0,</a>
<a name="1215"><span class="lineNum">    1215 </span>            :                 &quot;Illegal base type of storage size zero for array.&quot;</a>
<a name="1216"><span class="lineNum">    1216 </span>            :         );</a>
<a name="1217"><span class="lineNum">    1217 </span><span class="lineCov">        690 : }</span></a>
<a name="1218"><span class="lineNum">    1218 </span>            : </a>
<a name="1219"><span class="lineNum">    1219 </span><span class="lineCov">       3249 : bool TypeChecker::visit(VariableDeclarationStatement const&amp; _statement)</span></a>
<a name="1220"><span class="lineNum">    1220 </span>            : {</a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineCov">       3249 :         if (!_statement.initialValue())</span></a>
<a name="1222"><span class="lineNum">    1222 </span>            :         {</a>
<a name="1223"><span class="lineNum">    1223 </span>            :                 // No initial value is only permitted for single variables with specified type.</a>
<a name="1224"><span class="lineNum">    1224 </span>            :                 // This usually already results in a parser error.</a>
<a name="1225"><span class="lineNum">    1225 </span><span class="lineCov">        979 :                 if (_statement.declarations().size() != 1 || !_statement.declarations().front())</span></a>
<a name="1226"><span class="lineNum">    1226 </span>            :                 {</a>
<a name="1227"><span class="lineNum">    1227 </span><span class="lineNoCov">          0 :                         solAssert(m_errorReporter.hasErrors(), &quot;&quot;);</span></a>
<a name="1228"><span class="lineNum">    1228 </span>            : </a>
<a name="1229"><span class="lineNum">    1229 </span>            :                         // It is okay to return here, as there are no named components on the</a>
<a name="1230"><span class="lineNum">    1230 </span>            :                         // left-hand-side that could cause any damage later.</a>
<a name="1231"><span class="lineNum">    1231 </span><span class="lineNoCov">          0 :                         return false;</span></a>
<a name="1232"><span class="lineNum">    1232 </span>            :                 }</a>
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineCov">        979 :                 VariableDeclaration const&amp; varDecl = *_statement.declarations().front();</span></a>
<a name="1235"><span class="lineNum">    1235 </span><span class="lineCov">        979 :                 solAssert(varDecl.annotation().type, &quot;&quot;);</span></a>
<a name="1236"><span class="lineNum">    1236 </span>            : </a>
<a name="1237"><span class="lineNum">    1237 </span><span class="lineCov">        979 :                 if (dynamic_cast&lt;MappingType const*&gt;(type(varDecl)))</span></a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineCov">          2 :                         m_errorReporter.typeError(</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            :                                 4182_error,</a>
<a name="1240"><span class="lineNum">    1240 </span><span class="lineCov">          1 :                                 varDecl.location(),</span></a>
<a name="1241"><span class="lineNum">    1241 </span>            :                                 &quot;Uninitialized mapping. Mappings cannot be created dynamically, you have to assign them from a state variable.&quot;</a>
<a name="1242"><span class="lineNum">    1242 </span>            :                         );</a>
<a name="1243"><span class="lineNum">    1243 </span><span class="lineCov">        979 :                 varDecl.accept(*this);</span></a>
<a name="1244"><span class="lineNum">    1244 </span><span class="lineCov">        978 :                 return false;</span></a>
<a name="1245"><span class="lineNum">    1245 </span>            :         }</a>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<a name="1247"><span class="lineNum">    1247 </span>            :         // Here we have an initial value and might have to derive some types before we can visit</a>
<a name="1248"><span class="lineNum">    1248 </span>            :         // the variable declaration(s).</a>
<a name="1249"><span class="lineNum">    1249 </span>            : </a>
<a name="1250"><span class="lineNum">    1250 </span><span class="lineCov">       2270 :         _statement.initialValue()-&gt;accept(*this);</span></a>
<a name="1251"><span class="lineNum">    1251 </span><span class="lineCov">       2252 :         TypePointers valueTypes;</span></a>
<a name="1252"><span class="lineNum">    1252 </span><span class="lineCov">       2252 :         if (auto tupleType = dynamic_cast&lt;TupleType const*&gt;(type(*_statement.initialValue())))</span></a>
<a name="1253"><span class="lineNum">    1253 </span><span class="lineCov">         84 :                 valueTypes = tupleType-&gt;components();</span></a>
<a name="1254"><span class="lineNum">    1254 </span>            :         else</a>
<a name="1255"><span class="lineNum">    1255 </span><span class="lineCov">       2168 :                 valueTypes = TypePointers{type(*_statement.initialValue())};</span></a>
<a name="1256"><span class="lineNum">    1256 </span>            : </a>
<a name="1257"><span class="lineNum">    1257 </span><span class="lineCov">       2252 :         std::vector&lt;ASTPointer&lt;VariableDeclaration&gt;&gt; const&amp; variables = _statement.declarations();</span></a>
<a name="1258"><span class="lineNum">    1258 </span><span class="lineCov">       2252 :         if (variables.empty())</span></a>
<a name="1259"><span class="lineNum">    1259 </span>            :                 // We already have an error for this in the SyntaxChecker.</a>
<a name="1260"><span class="lineNum">    1260 </span><span class="lineNoCov">          0 :                 solAssert(m_errorReporter.hasErrors(), &quot;&quot;);</span></a>
<a name="1261"><span class="lineNum">    1261 </span><span class="lineCov">       2252 :         else if (valueTypes.size() != variables.size())</span></a>
<a name="1262"><span class="lineNum">    1262 </span><span class="lineCov">         24 :                 m_errorReporter.typeError(</span></a>
<a name="1263"><span class="lineNum">    1263 </span>            :                         7364_error,</a>
<a name="1264"><span class="lineNum">    1264 </span><span class="lineCov">         24 :                         _statement.location(),</span></a>
<a name="1265"><span class="lineNum">    1265 </span><span class="lineCov">         24 :                         &quot;Different number of components on the left hand side (&quot; +</span></a>
<a name="1266"><span class="lineNum">    1266 </span><span class="lineCov">         72 :                         toString(variables.size()) +</span></a>
<a name="1267"><span class="lineNum">    1267 </span><span class="lineCov">         48 :                         &quot;) than on the right hand side (&quot; +</span></a>
<a name="1268"><span class="lineNum">    1268 </span><span class="lineCov">         96 :                         toString(valueTypes.size()) +</span></a>
<a name="1269"><span class="lineNum">    1269 </span>            :                         &quot;).&quot;</a>
<a name="1270"><span class="lineNum">    1270 </span>            :                 );</a>
<a name="1271"><span class="lineNum">    1271 </span>            : </a>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineCov">       4607 :         for (size_t i = 0; i &lt; std::min(variables.size(), valueTypes.size()); ++i)</span></a>
<a name="1273"><span class="lineNum">    1273 </span>            :         {</a>
<a name="1274"><span class="lineNum">    1274 </span><span class="lineCov">       2355 :                 if (!variables[i])</span></a>
<a name="1275"><span class="lineNum">    1275 </span><span class="lineCov">         16 :                         continue;</span></a>
<a name="1276"><span class="lineNum">    1276 </span><span class="lineCov">       2339 :                 VariableDeclaration const&amp; var = *variables[i];</span></a>
<a name="1277"><span class="lineNum">    1277 </span><span class="lineCov">       2339 :                 solAssert(!var.value(), &quot;Value has to be tied to statement.&quot;);</span></a>
<a name="1278"><span class="lineNum">    1278 </span><span class="lineCov">       2339 :                 Type const* valueComponentType = valueTypes[i];</span></a>
<a name="1279"><span class="lineNum">    1279 </span><span class="lineCov">       2339 :                 solAssert(!!valueComponentType, &quot;&quot;);</span></a>
<a name="1280"><span class="lineNum">    1280 </span><span class="lineCov">       2339 :                 solAssert(var.annotation().type, &quot;&quot;);</span></a>
<a name="1281"><span class="lineNum">    1281 </span>            : </a>
<a name="1282"><span class="lineNum">    1282 </span><span class="lineCov">       2339 :                 var.accept(*this);</span></a>
<a name="1283"><span class="lineNum">    1283 </span><span class="lineCov">       4678 :                 BoolResult result = valueComponentType-&gt;isImplicitlyConvertibleTo(*var.annotation().type);</span></a>
<a name="1284"><span class="lineNum">    1284 </span><span class="lineCov">       2339 :                 if (!result)</span></a>
<a name="1285"><span class="lineNum">    1285 </span>            :                 {</a>
<a name="1286"><span class="lineNum">    1286 </span><span class="lineCov">        336 :                         auto errorMsg = &quot;Type &quot; +</span></a>
<a name="1287"><span class="lineNum">    1287 </span><span class="lineCov">        672 :                                 valueComponentType-&gt;humanReadableName() +</span></a>
<a name="1288"><span class="lineNum">    1288 </span>            :                                 &quot; is not implicitly convertible to expected type &quot; +</a>
<a name="1289"><span class="lineNum">    1289 </span><span class="lineCov">        504 :                                 var.annotation().type-&gt;humanReadableName();</span></a>
<a name="1290"><span class="lineNum">    1290 </span><span class="lineCov">        168 :                         if (</span></a>
<a name="1291"><span class="lineNum">    1291 </span><span class="lineCov">        168 :                                 valueComponentType-&gt;category() == Type::Category::RationalNumber &amp;&amp;</span></a>
<a name="1292"><span class="lineNum">    1292 </span><span class="lineCov">        169 :                                 dynamic_cast&lt;RationalNumberType const&amp;&gt;(*valueComponentType).isFractional() &amp;&amp;</span></a>
<a name="1293"><span class="lineNum">    1293 </span><span class="lineCov">          1 :                                 valueComponentType-&gt;mobileType()</span></a>
<a name="1294"><span class="lineNum">    1294 </span>            :                         )</a>
<a name="1295"><span class="lineNum">    1295 </span>            :                         {</a>
<a name="1296"><span class="lineNum">    1296 </span><span class="lineCov">          1 :                                 if (var.annotation().type-&gt;operator==(*valueComponentType-&gt;mobileType()))</span></a>
<a name="1297"><span class="lineNum">    1297 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="1298"><span class="lineNum">    1298 </span>            :                                                 5107_error,</a>
<a name="1299"><span class="lineNum">    1299 </span><span class="lineNoCov">          0 :                                                 _statement.location(),</span></a>
<a name="1300"><span class="lineNum">    1300 </span><span class="lineNoCov">          0 :                                                 errorMsg + &quot;, but it can be explicitly converted.&quot;</span></a>
<a name="1301"><span class="lineNum">    1301 </span>            :                                         );</a>
<a name="1302"><span class="lineNum">    1302 </span>            :                                 else</a>
<a name="1303"><span class="lineNum">    1303 </span><span class="lineCov">          1 :                                         m_errorReporter.typeError(</span></a>
<a name="1304"><span class="lineNum">    1304 </span>            :                                                 4486_error,</a>
<a name="1305"><span class="lineNum">    1305 </span><span class="lineCov">          1 :                                                 _statement.location(),</span></a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineCov">          1 :                                                 errorMsg +</span></a>
<a name="1307"><span class="lineNum">    1307 </span><span class="lineCov">          2 :                                                 &quot;. Try converting to type &quot; +</span></a>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineCov">          4 :                                                 valueComponentType-&gt;mobileType()-&gt;humanReadableName() +</span></a>
<a name="1309"><span class="lineNum">    1309 </span>            :                                                 &quot; or use an explicit conversion.&quot;</a>
<a name="1310"><span class="lineNum">    1310 </span>            :                                         );</a>
<a name="1311"><span class="lineNum">    1311 </span>            :                         }</a>
<a name="1312"><span class="lineNum">    1312 </span>            :                         else</a>
<a name="1313"><span class="lineNum">    1313 </span><span class="lineCov">        167 :                                 m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="1314"><span class="lineNum">    1314 </span>            :                                         9574_error,</a>
<a name="1315"><span class="lineNum">    1315 </span><span class="lineCov">        167 :                                         _statement.location(),</span></a>
<a name="1316"><span class="lineNum">    1316 </span><span class="lineCov">        334 :                                         errorMsg + &quot;.&quot;,</span></a>
<a name="1317"><span class="lineNum">    1317 </span><span class="lineCov">        167 :                                         result.message()</span></a>
<a name="1318"><span class="lineNum">    1318 </span>            :                                 );</a>
<a name="1319"><span class="lineNum">    1319 </span>            :                 }</a>
<a name="1320"><span class="lineNum">    1320 </span>            :         }</a>
<a name="1321"><span class="lineNum">    1321 </span>            : </a>
<a name="1322"><span class="lineNum">    1322 </span><span class="lineCov">       2252 :         if (valueTypes.size() != variables.size())</span></a>
<a name="1323"><span class="lineNum">    1323 </span>            :         {</a>
<a name="1324"><span class="lineNum">    1324 </span><span class="lineCov">         24 :                 solAssert(m_errorReporter.hasErrors(), &quot;Should have errors!&quot;);</span></a>
<a name="1325"><span class="lineNum">    1325 </span><span class="lineCov">         79 :                 for (auto const&amp; var: variables)</span></a>
<a name="1326"><span class="lineNum">    1326 </span><span class="lineCov">         55 :                         if (var &amp;&amp; !var-&gt;annotation().type)</span></a>
<a name="1327"><span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                                 BOOST_THROW_EXCEPTION(FatalError());</span></a>
<a name="1328"><span class="lineNum">    1328 </span>            :         }</a>
<a name="1329"><span class="lineNum">    1329 </span>            : </a>
<a name="1330"><span class="lineNum">    1330 </span><span class="lineCov">       2252 :         return false;</span></a>
<a name="1331"><span class="lineNum">    1331 </span>            : }</a>
<a name="1332"><span class="lineNum">    1332 </span>            : </a>
<a name="1333"><span class="lineNum">    1333 </span><span class="lineCov">       8629 : void TypeChecker::endVisit(ExpressionStatement const&amp; _statement)</span></a>
<a name="1334"><span class="lineNum">    1334 </span>            : {</a>
<a name="1335"><span class="lineNum">    1335 </span><span class="lineCov">       8629 :         if (type(_statement.expression())-&gt;category() == Type::Category::RationalNumber)</span></a>
<a name="1336"><span class="lineNum">    1336 </span><span class="lineCov">          7 :                 if (!dynamic_cast&lt;RationalNumberType const&amp;&gt;(*type(_statement.expression())).mobileType())</span></a>
<a name="1337"><span class="lineNum">    1337 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(3757_error, _statement.expression().location(), &quot;Invalid rational number.&quot;);</span></a>
<a name="1338"><span class="lineNum">    1338 </span>            : </a>
<a name="1339"><span class="lineNum">    1339 </span><span class="lineCov">       8629 :         if (auto call = dynamic_cast&lt;FunctionCall const*&gt;(&amp;_statement.expression()))</span></a>
<a name="1340"><span class="lineNum">    1340 </span>            :         {</a>
<a name="1341"><span class="lineNum">    1341 </span><span class="lineCov">       1610 :                 if (auto callType = dynamic_cast&lt;FunctionType const*&gt;(type(call-&gt;expression())))</span></a>
<a name="1342"><span class="lineNum">    1342 </span>            :                 {</a>
<a name="1343"><span class="lineNum">    1343 </span><span class="lineCov">       1600 :                         auto kind = callType-&gt;kind();</span></a>
<a name="1344"><span class="lineNum">    1344 </span><span class="lineCov">       1600 :                         if (</span></a>
<a name="1345"><span class="lineNum">    1345 </span><span class="lineCov">       1588 :                                 kind == FunctionType::Kind::BareCall ||</span></a>
<a name="1346"><span class="lineNum">    1346 </span><span class="lineCov">       1588 :                                 kind == FunctionType::Kind::BareCallCode ||</span></a>
<a name="1347"><span class="lineNum">    1347 </span><span class="lineCov">       1588 :                                 kind == FunctionType::Kind::BareDelegateCall ||</span></a>
<a name="1348"><span class="lineNum">    1348 </span>            :                                 kind == FunctionType::Kind::BareStaticCall</a>
<a name="1349"><span class="lineNum">    1349 </span>            :                         )</a>
<a name="1350"><span class="lineNum">    1350 </span><span class="lineCov">         12 :                                 m_errorReporter.warning(9302_error, _statement.location(), &quot;Return value of low-level calls not used.&quot;);</span></a>
<a name="1351"><span class="lineNum">    1351 </span><span class="lineCov">       1588 :                         else if (kind == FunctionType::Kind::Send)</span></a>
<a name="1352"><span class="lineNum">    1352 </span><span class="lineCov">          2 :                                 m_errorReporter.warning(5878_error, _statement.location(), &quot;Failure condition of 'send' ignored. Consider using 'transfer' instead.&quot;);</span></a>
<a name="1353"><span class="lineNum">    1353 </span>            :                 }</a>
<a name="1354"><span class="lineNum">    1354 </span>            :         }</a>
<a name="1355"><span class="lineNum">    1355 </span><span class="lineCov">       8629 : }</span></a>
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<a name="1357"><span class="lineNum">    1357 </span><span class="lineCov">        212 : bool TypeChecker::visit(Conditional const&amp; _conditional)</span></a>
<a name="1358"><span class="lineNum">    1358 </span>            : {</a>
<a name="1359"><span class="lineNum">    1359 </span><span class="lineCov">        212 :         expectType(_conditional.condition(), *TypeProvider::boolean());</span></a>
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<a name="1361"><span class="lineNum">    1361 </span><span class="lineCov">        212 :         _conditional.trueExpression().accept(*this);</span></a>
<a name="1362"><span class="lineNum">    1362 </span><span class="lineCov">        212 :         _conditional.falseExpression().accept(*this);</span></a>
<a name="1363"><span class="lineNum">    1363 </span>            : </a>
<a name="1364"><span class="lineNum">    1364 </span><span class="lineCov">        212 :         Type const* trueType = type(_conditional.trueExpression())-&gt;mobileType();</span></a>
<a name="1365"><span class="lineNum">    1365 </span><span class="lineCov">        212 :         Type const* falseType = type(_conditional.falseExpression())-&gt;mobileType();</span></a>
<a name="1366"><span class="lineNum">    1366 </span>            : </a>
<a name="1367"><span class="lineNum">    1367 </span><span class="lineCov">        212 :         Type const* commonType = nullptr;</span></a>
<a name="1368"><span class="lineNum">    1368 </span>            : </a>
<a name="1369"><span class="lineNum">    1369 </span><span class="lineCov">        212 :         if (!trueType)</span></a>
<a name="1370"><span class="lineNum">    1370 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(9717_error, _conditional.trueExpression().location(), &quot;Invalid mobile type in true expression.&quot;);</span></a>
<a name="1371"><span class="lineNum">    1371 </span>            :         else</a>
<a name="1372"><span class="lineNum">    1372 </span><span class="lineCov">        212 :                 commonType = trueType;</span></a>
<a name="1373"><span class="lineNum">    1373 </span>            : </a>
<a name="1374"><span class="lineNum">    1374 </span><span class="lineCov">        212 :         if (!falseType)</span></a>
<a name="1375"><span class="lineNum">    1375 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(3703_error, _conditional.falseExpression().location(), &quot;Invalid mobile type in false expression.&quot;);</span></a>
<a name="1376"><span class="lineNum">    1376 </span>            :         else</a>
<a name="1377"><span class="lineNum">    1377 </span><span class="lineCov">        212 :                 commonType = falseType;</span></a>
<a name="1378"><span class="lineNum">    1378 </span>            : </a>
<a name="1379"><span class="lineNum">    1379 </span><span class="lineCov">        212 :         if (!trueType &amp;&amp; !falseType)</span></a>
<a name="1380"><span class="lineNum">    1380 </span><span class="lineNoCov">          0 :                 BOOST_THROW_EXCEPTION(FatalError());</span></a>
<a name="1381"><span class="lineNum">    1381 </span><span class="lineCov">        212 :         else if (trueType &amp;&amp; falseType)</span></a>
<a name="1382"><span class="lineNum">    1382 </span>            :         {</a>
<a name="1383"><span class="lineNum">    1383 </span><span class="lineCov">        212 :                 commonType = Type::commonType(trueType, falseType);</span></a>
<a name="1384"><span class="lineNum">    1384 </span>            : </a>
<a name="1385"><span class="lineNum">    1385 </span><span class="lineCov">        212 :                 if (!commonType)</span></a>
<a name="1386"><span class="lineNum">    1386 </span>            :                 {</a>
<a name="1387"><span class="lineNum">    1387 </span><span class="lineCov">         12 :                         m_errorReporter.typeError(</span></a>
<a name="1388"><span class="lineNum">    1388 </span>            :                                         1080_error,</a>
<a name="1389"><span class="lineNum">    1389 </span><span class="lineCov">         12 :                                         _conditional.location(),</span></a>
<a name="1390"><span class="lineNum">    1390 </span><span class="lineCov">         12 :                                         &quot;True expression's type &quot; +</span></a>
<a name="1391"><span class="lineNum">    1391 </span><span class="lineCov">         36 :                                         trueType-&gt;humanReadableName() +</span></a>
<a name="1392"><span class="lineNum">    1392 </span><span class="lineCov">         24 :                                         &quot; does not match false expression's type &quot; +</span></a>
<a name="1393"><span class="lineNum">    1393 </span><span class="lineCov">         48 :                                         falseType-&gt;humanReadableName() +</span></a>
<a name="1394"><span class="lineNum">    1394 </span>            :                                         &quot;.&quot;</a>
<a name="1395"><span class="lineNum">    1395 </span>            :                                         );</a>
<a name="1396"><span class="lineNum">    1396 </span>            :                         // even we can't find a common type, we have to set a type here,</a>
<a name="1397"><span class="lineNum">    1397 </span>            :                         // otherwise the upper statement will not be able to check the type.</a>
<a name="1398"><span class="lineNum">    1398 </span><span class="lineCov">         12 :                         commonType = trueType;</span></a>
<a name="1399"><span class="lineNum">    1399 </span>            :                 }</a>
<a name="1400"><span class="lineNum">    1400 </span>            :         }</a>
<a name="1401"><span class="lineNum">    1401 </span>            : </a>
<a name="1402"><span class="lineNum">    1402 </span><span class="lineCov">        212 :         _conditional.annotation().isConstant = false;</span></a>
<a name="1403"><span class="lineNum">    1403 </span><span class="lineCov">        212 :         _conditional.annotation().type = commonType;</span></a>
<a name="1404"><span class="lineNum">    1404 </span><span class="lineCov">        424 :         _conditional.annotation().isPure =</span></a>
<a name="1405"><span class="lineNum">    1405 </span><span class="lineCov">        212 :                 *_conditional.condition().annotation().isPure &amp;&amp;</span></a>
<a name="1406"><span class="lineNum">    1406 </span><span class="lineCov">        223 :                 *_conditional.trueExpression().annotation().isPure &amp;&amp;</span></a>
<a name="1407"><span class="lineNum">    1407 </span><span class="lineCov">        223 :                 *_conditional.falseExpression().annotation().isPure;</span></a>
<a name="1408"><span class="lineNum">    1408 </span>            : </a>
<a name="1409"><span class="lineNum">    1409 </span><span class="lineCov">        212 :         _conditional.annotation().isLValue = false;</span></a>
<a name="1410"><span class="lineNum">    1410 </span>            : </a>
<a name="1411"><span class="lineNum">    1411 </span><span class="lineCov">        212 :         if (_conditional.annotation().willBeWrittenTo)</span></a>
<a name="1412"><span class="lineNum">    1412 </span><span class="lineCov">          2 :                 m_errorReporter.typeError(</span></a>
<a name="1413"><span class="lineNum">    1413 </span>            :                         2212_error,</a>
<a name="1414"><span class="lineNum">    1414 </span><span class="lineCov">          1 :                         _conditional.location(),</span></a>
<a name="1415"><span class="lineNum">    1415 </span>            :                         &quot;Conditional expression as left value is not supported yet.&quot;</a>
<a name="1416"><span class="lineNum">    1416 </span>            :                 );</a>
<a name="1417"><span class="lineNum">    1417 </span>            : </a>
<a name="1418"><span class="lineNum">    1418 </span><span class="lineCov">        212 :         return false;</span></a>
<a name="1419"><span class="lineNum">    1419 </span>            : }</a>
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<a name="1421"><span class="lineNum">    1421 </span><span class="lineCov">       6670 : void TypeChecker::checkExpressionAssignment(Type const&amp; _type, Expression const&amp; _expression)</span></a>
<a name="1422"><span class="lineNum">    1422 </span>            : {</a>
<a name="1423"><span class="lineNum">    1423 </span><span class="lineCov">       6670 :         if (auto const* tupleExpression = dynamic_cast&lt;TupleExpression const*&gt;(&amp;_expression))</span></a>
<a name="1424"><span class="lineNum">    1424 </span>            :         {</a>
<a name="1425"><span class="lineNum">    1425 </span><span class="lineCov">        108 :                 if (tupleExpression-&gt;components().empty())</span></a>
<a name="1426"><span class="lineNum">    1426 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(5547_error, _expression.location(), &quot;Empty tuple on the left hand side.&quot;);</span></a>
<a name="1427"><span class="lineNum">    1427 </span>            : </a>
<a name="1428"><span class="lineNum">    1428 </span><span class="lineCov">        108 :                 auto const* tupleType = dynamic_cast&lt;TupleType const*&gt;(&amp;_type);</span></a>
<a name="1429"><span class="lineNum">    1429 </span><span class="lineCov">        317 :                 auto const&amp; types = tupleType &amp;&amp; tupleExpression-&gt;components().size() != 1 ? tupleType-&gt;components() : std::vector&lt;Type const*&gt; { &amp;_type };</span></a>
<a name="1430"><span class="lineNum">    1430 </span>            : </a>
<a name="1431"><span class="lineNum">    1431 </span><span class="lineCov">        108 :                 solAssert(</span></a>
<a name="1432"><span class="lineNum">    1432 </span>            :                         tupleExpression-&gt;components().size() == types.size() || m_errorReporter.hasErrors(),</a>
<a name="1433"><span class="lineNum">    1433 </span>            :                         &quot;Array sizes don't match and no errors generated.&quot;</a>
<a name="1434"><span class="lineNum">    1434 </span>            :                 );</a>
<a name="1435"><span class="lineNum">    1435 </span>            : </a>
<a name="1436"><span class="lineNum">    1436 </span><span class="lineCov">        356 :                 for (size_t i = 0; i &lt; std::min(tupleExpression-&gt;components().size(), types.size()); i++)</span></a>
<a name="1437"><span class="lineNum">    1437 </span><span class="lineCov">        248 :                         if (types[i])</span></a>
<a name="1438"><span class="lineNum">    1438 </span>            :                         {</a>
<a name="1439"><span class="lineNum">    1439 </span><span class="lineCov">        235 :                                 solAssert(!!tupleExpression-&gt;components()[i], &quot;&quot;);</span></a>
<a name="1440"><span class="lineNum">    1440 </span><span class="lineCov">        235 :                                 checkExpressionAssignment(*types[i], *tupleExpression-&gt;components()[i]);</span></a>
<a name="1441"><span class="lineNum">    1441 </span>            :                         }</a>
<a name="1442"><span class="lineNum">    1442 </span>            :         }</a>
<a name="1443"><span class="lineNum">    1443 </span><span class="lineCov">       6562 :         else if (_type.nameable() &amp;&amp; _type.containsNestedMapping())</span></a>
<a name="1444"><span class="lineNum">    1444 </span>            :         {</a>
<a name="1445"><span class="lineNum">    1445 </span><span class="lineCov">          2 :                 bool isLocalOrReturn = false;</span></a>
<a name="1446"><span class="lineNum">    1446 </span><span class="lineCov">          2 :                 if (auto const* identifier = dynamic_cast&lt;Identifier const*&gt;(&amp;_expression))</span></a>
<a name="1447"><span class="lineNum">    1447 </span><span class="lineCov">          2 :                         if (auto const *variableDeclaration = dynamic_cast&lt;VariableDeclaration const*&gt;(identifier-&gt;annotation().referencedDeclaration))</span></a>
<a name="1448"><span class="lineNum">    1448 </span><span class="lineCov">          2 :                                 if (variableDeclaration-&gt;isLocalOrReturn())</span></a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                                         isLocalOrReturn = true;</span></a>
<a name="1450"><span class="lineNum">    1450 </span><span class="lineCov">          2 :                 if (!isLocalOrReturn)</span></a>
<a name="1451"><span class="lineNum">    1451 </span><span class="lineCov">          2 :                         m_errorReporter.typeError(9214_error, _expression.location(), &quot;Types in storage containing (nested) mappings cannot be assigned to.&quot;);</span></a>
<a name="1452"><span class="lineNum">    1452 </span>            :         }</a>
<a name="1453"><span class="lineNum">    1453 </span><span class="lineCov">       6670 : }</span></a>
<a name="1454"><span class="lineNum">    1454 </span>            : </a>
<a name="1455"><span class="lineNum">    1455 </span><span class="lineCov">       6457 : bool TypeChecker::visit(Assignment const&amp; _assignment)</span></a>
<a name="1456"><span class="lineNum">    1456 </span>            : {</a>
<a name="1457"><span class="lineNum">    1457 </span><span class="lineCov">       6457 :         requireLValue(</span></a>
<a name="1458"><span class="lineNum">    1458 </span>            :                 _assignment.leftHandSide(),</a>
<a name="1459"><span class="lineNum">    1459 </span><span class="lineCov">       6457 :                 _assignment.assignmentOperator() == Token::Assign</span></a>
<a name="1460"><span class="lineNum">    1460 </span>            :         );</a>
<a name="1461"><span class="lineNum">    1461 </span><span class="lineCov">       6435 :         Type const* t = type(_assignment.leftHandSide());</span></a>
<a name="1462"><span class="lineNum">    1462 </span><span class="lineCov">       6435 :         _assignment.annotation().type = t;</span></a>
<a name="1463"><span class="lineNum">    1463 </span><span class="lineCov">       6435 :         _assignment.annotation().isPure = false;</span></a>
<a name="1464"><span class="lineNum">    1464 </span><span class="lineCov">       6435 :         _assignment.annotation().isLValue = false;</span></a>
<a name="1465"><span class="lineNum">    1465 </span><span class="lineCov">       6435 :         _assignment.annotation().isConstant = false;</span></a>
<a name="1466"><span class="lineNum">    1466 </span>            : </a>
<a name="1467"><span class="lineNum">    1467 </span><span class="lineCov">       6435 :         checkExpressionAssignment(*t, _assignment.leftHandSide());</span></a>
<a name="1468"><span class="lineNum">    1468 </span>            : </a>
<a name="1469"><span class="lineNum">    1469 </span><span class="lineCov">       6435 :         if (TupleType const* tupleType = dynamic_cast&lt;TupleType const*&gt;(t))</span></a>
<a name="1470"><span class="lineNum">    1470 </span>            :         {</a>
<a name="1471"><span class="lineNum">    1471 </span><span class="lineCov">        101 :                 if (_assignment.assignmentOperator() != Token::Assign)</span></a>
<a name="1472"><span class="lineNum">    1472 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="1473"><span class="lineNum">    1473 </span>            :                                 4289_error,</a>
<a name="1474"><span class="lineNum">    1474 </span><span class="lineNoCov">          0 :                                 _assignment.location(),</span></a>
<a name="1475"><span class="lineNum">    1475 </span>            :                                 &quot;Compound assignment is not allowed for tuple types.&quot;</a>
<a name="1476"><span class="lineNum">    1476 </span>            :                         );</a>
<a name="1477"><span class="lineNum">    1477 </span>            :                 // Sequenced assignments of tuples is not valid, make the result a &quot;void&quot; type.</a>
<a name="1478"><span class="lineNum">    1478 </span><span class="lineCov">        101 :                 _assignment.annotation().type = TypeProvider::emptyTuple();</span></a>
<a name="1479"><span class="lineNum">    1479 </span>            : </a>
<a name="1480"><span class="lineNum">    1480 </span><span class="lineCov">        101 :                 expectType(_assignment.rightHandSide(), *tupleType);</span></a>
<a name="1481"><span class="lineNum">    1481 </span>            :         }</a>
<a name="1482"><span class="lineNum">    1482 </span><span class="lineCov">       6334 :         else if (_assignment.assignmentOperator() == Token::Assign)</span></a>
<a name="1483"><span class="lineNum">    1483 </span><span class="lineCov">       5135 :                 expectType(_assignment.rightHandSide(), *t);</span></a>
<a name="1484"><span class="lineNum">    1484 </span>            :         else</a>
<a name="1485"><span class="lineNum">    1485 </span>            :         {</a>
<a name="1486"><span class="lineNum">    1486 </span>            :                 // compound assignment</a>
<a name="1487"><span class="lineNum">    1487 </span><span class="lineCov">       1199 :                 _assignment.rightHandSide().accept(*this);</span></a>
<a name="1488"><span class="lineNum">    1488 </span><span class="lineCov">       1197 :                 Type const* resultType = t-&gt;binaryOperatorResult(</span></a>
<a name="1489"><span class="lineNum">    1489 </span>            :                         TokenTraits::AssignmentToBinaryOp(_assignment.assignmentOperator()),</a>
<a name="1490"><span class="lineNum">    1490 </span>            :                         type(_assignment.rightHandSide())</a>
<a name="1491"><span class="lineNum">    1491 </span><span class="lineCov">       2394 :                 );</span></a>
<a name="1492"><span class="lineNum">    1492 </span><span class="lineCov">       1197 :                 if (!resultType || *resultType != *t)</span></a>
<a name="1493"><span class="lineNum">    1493 </span><span class="lineCov">         69 :                         m_errorReporter.typeError(</span></a>
<a name="1494"><span class="lineNum">    1494 </span>            :                                 7366_error,</a>
<a name="1495"><span class="lineNum">    1495 </span><span class="lineCov">         69 :                                 _assignment.location(),</span></a>
<a name="1496"><span class="lineNum">    1496 </span><span class="lineCov">         69 :                                 &quot;Operator &quot; +</span></a>
<a name="1497"><span class="lineNum">    1497 </span><span class="lineCov">        207 :                                 std::string(TokenTraits::friendlyName(_assignment.assignmentOperator())) +</span></a>
<a name="1498"><span class="lineNum">    1498 </span><span class="lineCov">        138 :                                 &quot; not compatible with types &quot; +</span></a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineCov">        276 :                                 t-&gt;humanReadableName() +</span></a>
<a name="1500"><span class="lineNum">    1500 </span><span class="lineCov">        138 :                                 &quot; and &quot; +</span></a>
<a name="1501"><span class="lineNum">    1501 </span><span class="lineCov">        276 :                                 type(_assignment.rightHandSide())-&gt;humanReadableName() +</span></a>
<a name="1502"><span class="lineNum">    1502 </span>            :                                 &quot;.&quot;</a>
<a name="1503"><span class="lineNum">    1503 </span>            :                         );</a>
<a name="1504"><span class="lineNum">    1504 </span>            :         }</a>
<a name="1505"><span class="lineNum">    1505 </span><span class="lineCov">       6410 :         return false;</span></a>
<a name="1506"><span class="lineNum">    1506 </span>            : }</a>
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineCov">       1702 : bool TypeChecker::visit(TupleExpression const&amp; _tuple)</span></a>
<a name="1509"><span class="lineNum">    1509 </span>            : {</a>
<a name="1510"><span class="lineNum">    1510 </span><span class="lineCov">       1702 :         _tuple.annotation().isConstant = false;</span></a>
<a name="1511"><span class="lineNum">    1511 </span><span class="lineCov">       1702 :         std::vector&lt;ASTPointer&lt;Expression&gt;&gt; const&amp; components = _tuple.components();</span></a>
<a name="1512"><span class="lineNum">    1512 </span><span class="lineCov">       1717 :         TypePointers types;</span></a>
<a name="1513"><span class="lineNum">    1513 </span>            : </a>
<a name="1514"><span class="lineNum">    1514 </span><span class="lineCov">       1702 :         if (_tuple.annotation().willBeWrittenTo)</span></a>
<a name="1515"><span class="lineNum">    1515 </span>            :         {</a>
<a name="1516"><span class="lineNum">    1516 </span><span class="lineCov">        109 :                 if (_tuple.isInlineArray())</span></a>
<a name="1517"><span class="lineNum">    1517 </span><span class="lineNoCov">          0 :                         m_errorReporter.fatalTypeError(3025_error, _tuple.location(), &quot;Inline array type cannot be declared as LValue.&quot;);</span></a>
<a name="1518"><span class="lineNum">    1518 </span><span class="lineCov">        358 :                 for (auto const&amp; component: components)</span></a>
<a name="1519"><span class="lineNum">    1519 </span><span class="lineCov">        249 :                         if (component)</span></a>
<a name="1520"><span class="lineNum">    1520 </span>            :                         {</a>
<a name="1521"><span class="lineNum">    1521 </span><span class="lineCov">        236 :                                 requireLValue(</span></a>
<a name="1522"><span class="lineNum">    1522 </span><span class="lineCov">        236 :                                         *component,</span></a>
<a name="1523"><span class="lineNum">    1523 </span><span class="lineCov">        236 :                                         _tuple.annotation().lValueOfOrdinaryAssignment</span></a>
<a name="1524"><span class="lineNum">    1524 </span>            :                                 );</a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineCov">        236 :                                 types.push_back(type(*component));</span></a>
<a name="1526"><span class="lineNum">    1526 </span>            :                         }</a>
<a name="1527"><span class="lineNum">    1527 </span>            :                         else</a>
<a name="1528"><span class="lineNum">    1528 </span><span class="lineCov">         13 :                                 types.push_back(nullptr);</span></a>
<a name="1529"><span class="lineNum">    1529 </span><span class="lineCov">        109 :                 if (components.size() == 1)</span></a>
<a name="1530"><span class="lineNum">    1530 </span><span class="lineCov">          8 :                         _tuple.annotation().type = type(*components[0]);</span></a>
<a name="1531"><span class="lineNum">    1531 </span>            :                 else</a>
<a name="1532"><span class="lineNum">    1532 </span><span class="lineCov">        101 :                         _tuple.annotation().type = TypeProvider::tuple(std::move(types));</span></a>
<a name="1533"><span class="lineNum">    1533 </span>            :                 // If some of the components are not LValues, the error is reported above.</a>
<a name="1534"><span class="lineNum">    1534 </span><span class="lineCov">        109 :                 _tuple.annotation().isLValue = true;</span></a>
<a name="1535"><span class="lineNum">    1535 </span><span class="lineCov">        109 :                 _tuple.annotation().isPure = false;</span></a>
<a name="1536"><span class="lineNum">    1536 </span>            :         }</a>
<a name="1537"><span class="lineNum">    1537 </span>            :         else</a>
<a name="1538"><span class="lineNum">    1538 </span>            :         {</a>
<a name="1539"><span class="lineNum">    1539 </span><span class="lineCov">       1593 :                 bool isPure = true;</span></a>
<a name="1540"><span class="lineNum">    1540 </span><span class="lineCov">       1593 :                 Type const* inlineArrayType = nullptr;</span></a>
<a name="1541"><span class="lineNum">    1541 </span>            : </a>
<a name="1542"><span class="lineNum">    1542 </span><span class="lineCov">       3646 :                 for (size_t i = 0; i &lt; components.size(); ++i)</span></a>
<a name="1543"><span class="lineNum">    1543 </span>            :                 {</a>
<a name="1544"><span class="lineNum">    1544 </span><span class="lineCov">       2066 :                         if (!components[i])</span></a>
<a name="1545"><span class="lineNum">    1545 </span><span class="lineCov">         15 :                                 m_errorReporter.fatalTypeError(8381_error, _tuple.location(), &quot;Tuple component cannot be empty.&quot;);</span></a>
<a name="1546"><span class="lineNum">    1546 </span>            : </a>
<a name="1547"><span class="lineNum">    1547 </span><span class="lineCov">       2061 :                         components[i]-&gt;accept(*this);</span></a>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineCov">       2053 :                         types.push_back(type(*components[i]));</span></a>
<a name="1549"><span class="lineNum">    1549 </span>            : </a>
<a name="1550"><span class="lineNum">    1550 </span><span class="lineCov">       2053 :                         if (types[i]-&gt;category() == Type::Category::Tuple)</span></a>
<a name="1551"><span class="lineNum">    1551 </span><span class="lineCov">          2 :                                 if (dynamic_cast&lt;TupleType const&amp;&gt;(*types[i]).components().empty())</span></a>
<a name="1552"><span class="lineNum">    1552 </span>            :                                 {</a>
<a name="1553"><span class="lineNum">    1553 </span><span class="lineCov">          2 :                                         if (_tuple.isInlineArray())</span></a>
<a name="1554"><span class="lineNum">    1554 </span><span class="lineNoCov">          0 :                                                 m_errorReporter.fatalTypeError(5604_error, components[i]-&gt;location(), &quot;Array component cannot be empty.&quot;);</span></a>
<a name="1555"><span class="lineNum">    1555 </span><span class="lineCov">          2 :                                         m_errorReporter.typeError(6473_error, components[i]-&gt;location(), &quot;Tuple component cannot be empty.&quot;);</span></a>
<a name="1556"><span class="lineNum">    1556 </span>            :                                 }</a>
<a name="1557"><span class="lineNum">    1557 </span>            : </a>
<a name="1558"><span class="lineNum">    1558 </span>            :                         // Note: code generation will visit each of the expression even if they are not assigned from.</a>
<a name="1559"><span class="lineNum">    1559 </span><span class="lineCov">       2053 :                         if (types[i]-&gt;category() == Type::Category::RationalNumber &amp;&amp; components.size() &gt; 1)</span></a>
<a name="1560"><span class="lineNum">    1560 </span><span class="lineCov">        211 :                                 if (!dynamic_cast&lt;RationalNumberType const&amp;&gt;(*types[i]).mobileType())</span></a>
<a name="1561"><span class="lineNum">    1561 </span><span class="lineNoCov">          0 :                                         m_errorReporter.fatalTypeError(3390_error, components[i]-&gt;location(), &quot;Invalid rational number.&quot;);</span></a>
<a name="1562"><span class="lineNum">    1562 </span>            : </a>
<a name="1563"><span class="lineNum">    1563 </span><span class="lineCov">       2053 :                         if (_tuple.isInlineArray())</span></a>
<a name="1564"><span class="lineNum">    1564 </span>            :                         {</a>
<a name="1565"><span class="lineNum">    1565 </span><span class="lineCov">         60 :                                 solAssert(!!types[i], &quot;Inline array cannot have empty components&quot;);</span></a>
<a name="1566"><span class="lineNum">    1566 </span>            : </a>
<a name="1567"><span class="lineNum">    1567 </span><span class="lineCov">         60 :                                 if ((i == 0 || inlineArrayType) &amp;&amp; !types[i]-&gt;mobileType())</span></a>
<a name="1568"><span class="lineNum">    1568 </span><span class="lineNoCov">          0 :                                         m_errorReporter.fatalTypeError(9563_error, components[i]-&gt;location(), &quot;Invalid mobile type.&quot;);</span></a>
<a name="1569"><span class="lineNum">    1569 </span>            : </a>
<a name="1570"><span class="lineNum">    1570 </span><span class="lineCov">         60 :                                 if (i == 0)</span></a>
<a name="1571"><span class="lineNum">    1571 </span><span class="lineCov">         14 :                                         inlineArrayType = types[i]-&gt;mobileType();</span></a>
<a name="1572"><span class="lineNum">    1572 </span><span class="lineCov">         46 :                                 else if (inlineArrayType)</span></a>
<a name="1573"><span class="lineNum">    1573 </span><span class="lineCov">         46 :                                         inlineArrayType = Type::commonType(inlineArrayType, types[i]);</span></a>
<a name="1574"><span class="lineNum">    1574 </span>            :                         }</a>
<a name="1575"><span class="lineNum">    1575 </span><span class="lineCov">       2053 :                         if (!*components[i]-&gt;annotation().isPure)</span></a>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineCov">       1387 :                                 isPure = false;</span></a>
<a name="1577"><span class="lineNum">    1577 </span>            :                 }</a>
<a name="1578"><span class="lineNum">    1578 </span><span class="lineCov">       1580 :                 _tuple.annotation().isPure = isPure;</span></a>
<a name="1579"><span class="lineNum">    1579 </span><span class="lineCov">       1580 :                 if (_tuple.isInlineArray())</span></a>
<a name="1580"><span class="lineNum">    1580 </span>            :                 {</a>
<a name="1581"><span class="lineNum">    1581 </span><span class="lineCov">         16 :                         if (!inlineArrayType)</span></a>
<a name="1582"><span class="lineNum">    1582 </span><span class="lineCov">          6 :                                 m_errorReporter.fatalTypeError(6378_error, _tuple.location(), &quot;Unable to deduce common type for array elements.&quot;);</span></a>
<a name="1583"><span class="lineNum">    1583 </span><span class="lineCov">         14 :                         else if (!inlineArrayType-&gt;nameable())</span></a>
<a name="1584"><span class="lineNum">    1584 </span><span class="lineNoCov">          0 :                                 m_errorReporter.fatalTypeError(</span></a>
<a name="1585"><span class="lineNum">    1585 </span>            :                                         9656_error,</a>
<a name="1586"><span class="lineNum">    1586 </span><span class="lineNoCov">          0 :                                         _tuple.location(),</span></a>
<a name="1587"><span class="lineNum">    1587 </span>            :                                         &quot;Unable to deduce nameable type for array elements. Try adding explicit type conversion for the first element.&quot;</a>
<a name="1588"><span class="lineNum">    1588 </span>            :                                 );</a>
<a name="1589"><span class="lineNum">    1589 </span><span class="lineCov">         14 :                         else if (inlineArrayType-&gt;containsNestedMapping())</span></a>
<a name="1590"><span class="lineNum">    1590 </span><span class="lineNoCov">          0 :                                 m_errorReporter.fatalTypeError(</span></a>
<a name="1591"><span class="lineNum">    1591 </span>            :                                         1545_error,</a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineNoCov">          0 :                                         _tuple.location(),</span></a>
<a name="1593"><span class="lineNum">    1593 </span><span class="lineNoCov">          0 :                                         &quot;Type &quot; + inlineArrayType-&gt;humanReadableName() + &quot; is only valid in storage.&quot;</span></a>
<a name="1594"><span class="lineNum">    1594 </span>            :                                 );</a>
<a name="1595"><span class="lineNum">    1595 </span>            : </a>
<a name="1596"><span class="lineNum">    1596 </span><span class="lineCov">         14 :                         _tuple.annotation().type = TypeProvider::array(DataLocation::Memory, inlineArrayType, types.size());</span></a>
<a name="1597"><span class="lineNum">    1597 </span>            :                 }</a>
<a name="1598"><span class="lineNum">    1598 </span>            :                 else</a>
<a name="1599"><span class="lineNum">    1599 </span>            :                 {</a>
<a name="1600"><span class="lineNum">    1600 </span><span class="lineCov">       1564 :                         if (components.size() == 1)</span></a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineCov">       1273 :                                 _tuple.annotation().type = type(*components[0]);</span></a>
<a name="1602"><span class="lineNum">    1602 </span>            :                         else</a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineCov">        291 :                                 _tuple.annotation().type = TypeProvider::tuple(std::move(types));</span></a>
<a name="1604"><span class="lineNum">    1604 </span>            :                 }</a>
<a name="1605"><span class="lineNum">    1605 </span>            : </a>
<a name="1606"><span class="lineNum">    1606 </span><span class="lineCov">       1578 :                 _tuple.annotation().isLValue = false;</span></a>
<a name="1607"><span class="lineNum">    1607 </span>            :         }</a>
<a name="1608"><span class="lineNum">    1608 </span><span class="lineCov">       3374 :         return false;</span></a>
<a name="1609"><span class="lineNum">    1609 </span>            : }</a>
<a name="1610"><span class="lineNum">    1610 </span>            : </a>
<a name="1611"><span class="lineNum">    1611 </span><span class="lineCov">        824 : bool TypeChecker::visit(UnaryOperation const&amp; _operation)</span></a>
<a name="1612"><span class="lineNum">    1612 </span>            : {</a>
<a name="1613"><span class="lineNum">    1613 </span>            :         // Inc, Dec, Add, Sub, Not, BitNot, Delete</a>
<a name="1614"><span class="lineNum">    1614 </span><span class="lineCov">        824 :         Token op = _operation.getOperator();</span></a>
<a name="1615"><span class="lineNum">    1615 </span><span class="lineCov">        824 :         bool const modifying = (op == Token::Inc || op == Token::Dec || op == Token::Delete);</span></a>
<a name="1616"><span class="lineNum">    1616 </span><span class="lineCov">        824 :         if (modifying)</span></a>
<a name="1617"><span class="lineNum">    1617 </span><span class="lineCov">        304 :                 requireLValue(_operation.subExpression(), false);</span></a>
<a name="1618"><span class="lineNum">    1618 </span>            :         else</a>
<a name="1619"><span class="lineNum">    1619 </span><span class="lineCov">        520 :                 _operation.subExpression().accept(*this);</span></a>
<a name="1620"><span class="lineNum">    1620 </span><span class="lineCov">        821 :         Type const* operandType = type(_operation.subExpression());</span></a>
<a name="1621"><span class="lineNum">    1621 </span>            : </a>
<a name="1622"><span class="lineNum">    1622 </span>            :         // Check if the operator is built-in or user-defined.</a>
<a name="1623"><span class="lineNum">    1623 </span><span class="lineCov">       1642 :         TypeResult builtinResult = operandType-&gt;unaryOperatorResult(op);</span></a>
<a name="1624"><span class="lineNum">    1624 </span>            :         std::set&lt;FunctionDefinition const*, ASTNode::CompareByID&gt; matchingDefinitions = operandType-&gt;operatorDefinitions(</a>
<a name="1625"><span class="lineNum">    1625 </span>            :                 op,</a>
<a name="1626"><span class="lineNum">    1626 </span><span class="lineCov">        821 :                 *currentDefinitionScope(),</span></a>
<a name="1627"><span class="lineNum">    1627 </span>            :                 true // _unary</a>
<a name="1628"><span class="lineNum">    1628 </span><span class="lineCov">        831 :         );</span></a>
<a name="1629"><span class="lineNum">    1629 </span>            : </a>
<a name="1630"><span class="lineNum">    1630 </span>            :         // Operator can't be both user-defined and built-in at the same time.</a>
<a name="1631"><span class="lineNum">    1631 </span><span class="lineCov">        821 :         solAssert(!builtinResult || matchingDefinitions.empty());</span></a>
<a name="1632"><span class="lineNum">    1632 </span>            : </a>
<a name="1633"><span class="lineNum">    1633 </span>            :         // By default use the type we'd expect from correct code. This way we can continue analysis</a>
<a name="1634"><span class="lineNum">    1634 </span>            :         // of other expressions in a sensible way in case of a non-fatal error.</a>
<a name="1635"><span class="lineNum">    1635 </span><span class="lineCov">        821 :         Type const* resultType = operandType;</span></a>
<a name="1636"><span class="lineNum">    1636 </span>            : </a>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineCov">        821 :         FunctionDefinition const* operatorDefinition = nullptr;</span></a>
<a name="1638"><span class="lineNum">    1638 </span><span class="lineCov">        821 :         if (builtinResult)</span></a>
<a name="1639"><span class="lineNum">    1639 </span><span class="lineCov">        749 :                 resultType = builtinResult;</span></a>
<a name="1640"><span class="lineNum">    1640 </span><span class="lineCov">         72 :         else if (!matchingDefinitions.empty())</span></a>
<a name="1641"><span class="lineNum">    1641 </span>            :         {</a>
<a name="1642"><span class="lineNum">    1642 </span>            :                 // This is checked along with `using for` directive but the error is not fatal.</a>
<a name="1643"><span class="lineNum">    1643 </span><span class="lineNoCov">          0 :                 if (matchingDefinitions.size() != 1)</span></a>
<a name="1644"><span class="lineNum">    1644 </span><span class="lineNoCov">          0 :                         solAssert(m_errorReporter.hasErrors());</span></a>
<a name="1645"><span class="lineNum">    1645 </span>            : </a>
<a name="1646"><span class="lineNum">    1646 </span><span class="lineNoCov">          0 :                 operatorDefinition = *matchingDefinitions.begin();</span></a>
<a name="1647"><span class="lineNum">    1647 </span>            :         }</a>
<a name="1648"><span class="lineNum">    1648 </span>            :         else</a>
<a name="1649"><span class="lineNum">    1649 </span>            :         {</a>
<a name="1650"><span class="lineNum">    1650 </span>            :                 std::string description = fmt::format(</a>
<a name="1651"><span class="lineNum">    1651 </span>            :                         &quot;Built-in unary operator {} cannot be applied to type {}.&quot;,</a>
<a name="1652"><span class="lineNum">    1652 </span><span class="lineCov">        144 :                         TokenTraits::friendlyName(op),</span></a>
<a name="1653"><span class="lineNum">    1653 </span><span class="lineCov">         72 :                         operandType-&gt;humanReadableName()</span></a>
<a name="1654"><span class="lineNum">    1654 </span><span class="lineCov">        144 :                 );</span></a>
<a name="1655"><span class="lineNum">    1655 </span><span class="lineCov">         72 :                 if (!builtinResult.message().empty())</span></a>
<a name="1656"><span class="lineNum">    1656 </span><span class="lineCov">         50 :                         description += &quot; &quot; + builtinResult.message();</span></a>
<a name="1657"><span class="lineNum">    1657 </span><span class="lineCov">         72 :                 if (operandType-&gt;typeDefinition() &amp;&amp; util::contains(userDefinableOperators, op))</span></a>
<a name="1658"><span class="lineNum">    1658 </span><span class="lineNoCov">          0 :                         description += &quot; No matching user-defined operator found.&quot;;</span></a>
<a name="1659"><span class="lineNum">    1659 </span>            : </a>
<a name="1660"><span class="lineNum">    1660 </span><span class="lineCov">         72 :                 if (modifying)</span></a>
<a name="1661"><span class="lineNum">    1661 </span>            :                         // Cannot just report the error, ignore the unary operator, and continue,</a>
<a name="1662"><span class="lineNum">    1662 </span>            :                         // because the sub-expression was already processed with requireLValue()</a>
<a name="1663"><span class="lineNum">    1663 </span><span class="lineCov">         10 :                         m_errorReporter.fatalTypeError(9767_error, _operation.location(), description);</span></a>
<a name="1664"><span class="lineNum">    1664 </span>            :                 else</a>
<a name="1665"><span class="lineNum">    1665 </span><span class="lineCov">         62 :                         m_errorReporter.typeError(4907_error, _operation.location(), description);</span></a>
<a name="1666"><span class="lineNum">    1666 </span>            :         }</a>
<a name="1667"><span class="lineNum">    1667 </span>            : </a>
<a name="1668"><span class="lineNum">    1668 </span><span class="lineCov">        811 :         _operation.annotation().userDefinedFunction = operatorDefinition;</span></a>
<a name="1669"><span class="lineNum">    1669 </span>            : </a>
<a name="1670"><span class="lineNum">    1670 </span><span class="lineCov">        811 :         if (operatorDefinition &amp;&amp; !_operation.userDefinedFunctionType()-&gt;returnParameterTypes().empty())</span></a>
<a name="1671"><span class="lineNum">    1671 </span>            :                 // Use the actual result type from operator definition. Ignore all values but the</a>
<a name="1672"><span class="lineNum">    1672 </span>            :                 // first one - in valid code there will be only one anyway.</a>
<a name="1673"><span class="lineNum">    1673 </span><span class="lineNoCov">          0 :                 resultType = _operation.userDefinedFunctionType()-&gt;returnParameterTypes()[0];</span></a>
<a name="1674"><span class="lineNum">    1674 </span><span class="lineCov">        811 :         _operation.annotation().type = resultType;</span></a>
<a name="1675"><span class="lineNum">    1675 </span><span class="lineCov">        811 :         _operation.annotation().isConstant = false;</span></a>
<a name="1676"><span class="lineNum">    1676 </span><span class="lineCov">       1622 :         _operation.annotation().isPure =</span></a>
<a name="1677"><span class="lineNum">    1677 </span><span class="lineCov">       1330 :                 !modifying &amp;&amp;</span></a>
<a name="1678"><span class="lineNum">    1678 </span><span class="lineCov">       1179 :                 *_operation.subExpression().annotation().isPure &amp;&amp;</span></a>
<a name="1679"><span class="lineNum">    1679 </span><span class="lineCov">       1179 :                 (!_operation.userDefinedFunctionType() || _operation.userDefinedFunctionType()-&gt;isPure());</span></a>
<a name="1680"><span class="lineNum">    1680 </span><span class="lineCov">        811 :         _operation.annotation().isLValue = false;</span></a>
<a name="1681"><span class="lineNum">    1681 </span>            : </a>
<a name="1682"><span class="lineNum">    1682 </span><span class="lineCov">       1622 :         return false;</span></a>
<a name="1683"><span class="lineNum">    1683 </span>            : }</a>
<a name="1684"><span class="lineNum">    1684 </span>            : </a>
<a name="1685"><span class="lineNum">    1685 </span><span class="lineCov">       9646 : void TypeChecker::endVisit(BinaryOperation const&amp; _operation)</span></a>
<a name="1686"><span class="lineNum">    1686 </span>            : {</a>
<a name="1687"><span class="lineNum">    1687 </span><span class="lineCov">       9646 :         Type const* leftType = type(_operation.leftExpression());</span></a>
<a name="1688"><span class="lineNum">    1688 </span><span class="lineCov">       9646 :         Type const* rightType = type(_operation.rightExpression());</span></a>
<a name="1689"><span class="lineNum">    1689 </span>            : </a>
<a name="1690"><span class="lineNum">    1690 </span>            :         // Check if the operator is built-in or user-defined.</a>
<a name="1691"><span class="lineNum">    1691 </span><span class="lineCov">      19292 :         TypeResult builtinResult = leftType-&gt;binaryOperatorResult(_operation.getOperator(), rightType);</span></a>
<a name="1692"><span class="lineNum">    1692 </span>            :         std::set&lt;FunctionDefinition const*, ASTNode::CompareByID&gt; matchingDefinitions = leftType-&gt;operatorDefinitions(</a>
<a name="1693"><span class="lineNum">    1693 </span>            :                 _operation.getOperator(),</a>
<a name="1694"><span class="lineNum">    1694 </span><span class="lineCov">       9646 :                 *currentDefinitionScope(),</span></a>
<a name="1695"><span class="lineNum">    1695 </span>            :                 false // _unary</a>
<a name="1696"><span class="lineNum">    1696 </span><span class="lineCov">      19292 :         );</span></a>
<a name="1697"><span class="lineNum">    1697 </span>            : </a>
<a name="1698"><span class="lineNum">    1698 </span>            :         // Operator can't be both user-defined and built-in at the same time.</a>
<a name="1699"><span class="lineNum">    1699 </span><span class="lineCov">       9646 :         solAssert(!builtinResult || matchingDefinitions.empty());</span></a>
<a name="1700"><span class="lineNum">    1700 </span>            : </a>
<a name="1701"><span class="lineNum">    1701 </span><span class="lineCov">       9646 :         Type const* commonType = nullptr;</span></a>
<a name="1702"><span class="lineNum">    1702 </span><span class="lineCov">       9646 :         FunctionDefinition const* operatorDefinition = nullptr;</span></a>
<a name="1703"><span class="lineNum">    1703 </span><span class="lineCov">       9646 :         if (builtinResult)</span></a>
<a name="1704"><span class="lineNum">    1704 </span><span class="lineCov">       9253 :                 commonType = builtinResult.get();</span></a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineCov">        393 :         else if (!matchingDefinitions.empty())</span></a>
<a name="1706"><span class="lineNum">    1706 </span>            :         {</a>
<a name="1707"><span class="lineNum">    1707 </span>            :                 // This is checked along with `using for` directive but the error is not fatal.</a>
<a name="1708"><span class="lineNum">    1708 </span><span class="lineNoCov">          0 :                 if (matchingDefinitions.size() != 1)</span></a>
<a name="1709"><span class="lineNum">    1709 </span><span class="lineNoCov">          0 :                         solAssert(m_errorReporter.hasErrors());</span></a>
<a name="1710"><span class="lineNum">    1710 </span>            : </a>
<a name="1711"><span class="lineNum">    1711 </span><span class="lineNoCov">          0 :                 operatorDefinition = *matchingDefinitions.begin();</span></a>
<a name="1712"><span class="lineNum">    1712 </span>            : </a>
<a name="1713"><span class="lineNum">    1713 </span>            :                 // Set common type to the type used in the `using for` directive.</a>
<a name="1714"><span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                 commonType = leftType;</span></a>
<a name="1715"><span class="lineNum">    1715 </span>            :         }</a>
<a name="1716"><span class="lineNum">    1716 </span>            :         else</a>
<a name="1717"><span class="lineNum">    1717 </span>            :         {</a>
<a name="1718"><span class="lineNum">    1718 </span>            :                 std::string description = fmt::format(</a>
<a name="1719"><span class="lineNum">    1719 </span>            :                         &quot;Built-in binary operator {} cannot be applied to types {} and {}.&quot;,</a>
<a name="1720"><span class="lineNum">    1720 </span><span class="lineCov">        786 :                         TokenTraits::friendlyName(_operation.getOperator()),</span></a>
<a name="1721"><span class="lineNum">    1721 </span><span class="lineCov">        786 :                         leftType-&gt;humanReadableName(),</span></a>
<a name="1722"><span class="lineNum">    1722 </span><span class="lineCov">        393 :                         rightType-&gt;humanReadableName()</span></a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineCov">        393 :                 );</span></a>
<a name="1724"><span class="lineNum">    1724 </span><span class="lineCov">        393 :                 if (!builtinResult.message().empty())</span></a>
<a name="1725"><span class="lineNum">    1725 </span><span class="lineCov">         42 :                         description += &quot; &quot; + builtinResult.message();</span></a>
<a name="1726"><span class="lineNum">    1726 </span><span class="lineCov">        393 :                 if (leftType-&gt;typeDefinition() &amp;&amp; util::contains(userDefinableOperators, _operation.getOperator()))</span></a>
<a name="1727"><span class="lineNum">    1727 </span><span class="lineNoCov">          0 :                         description += &quot; No matching user-defined operator found.&quot;;</span></a>
<a name="1728"><span class="lineNum">    1728 </span>            : </a>
<a name="1729"><span class="lineNum">    1729 </span><span class="lineCov">        393 :                 m_errorReporter.typeError(2271_error, _operation.location(), description);</span></a>
<a name="1730"><span class="lineNum">    1730 </span>            : </a>
<a name="1731"><span class="lineNum">    1731 </span>            :                 // Set common type to something we'd expect from correct code just so that we can continue analysis.</a>
<a name="1732"><span class="lineNum">    1732 </span><span class="lineCov">        393 :                 commonType = leftType;</span></a>
<a name="1733"><span class="lineNum">    1733 </span>            :         }</a>
<a name="1734"><span class="lineNum">    1734 </span>            : </a>
<a name="1735"><span class="lineNum">    1735 </span><span class="lineCov">       9646 :         _operation.annotation().commonType = commonType;</span></a>
<a name="1736"><span class="lineNum">    1736 </span><span class="lineCov">       9646 :         _operation.annotation().userDefinedFunction = operatorDefinition;</span></a>
<a name="1737"><span class="lineNum">    1737 </span><span class="lineCov">       9646 :         FunctionType const* userDefinedFunctionType = _operation.userDefinedFunctionType();</span></a>
<a name="1738"><span class="lineNum">    1738 </span>            : </a>
<a name="1739"><span class="lineNum">    1739 </span>            :         // By default use the type we'd expect from correct code. This way we can continue analysis</a>
<a name="1740"><span class="lineNum">    1740 </span>            :         // of other expressions in a sensible way in case of a non-fatal error.</a>
<a name="1741"><span class="lineNum">    1741 </span>            :         Type const* resultType =</a>
<a name="1742"><span class="lineNum">    1742 </span><span class="lineCov">       9646 :                 TokenTraits::isCompareOp(_operation.getOperator()) ?</span></a>
<a name="1743"><span class="lineNum">    1743 </span><span class="lineCov">       2197 :                 TypeProvider::boolean() :</span></a>
<a name="1744"><span class="lineNum">    1744 </span><span class="lineCov">       9646 :                 commonType;</span></a>
<a name="1745"><span class="lineNum">    1745 </span>            : </a>
<a name="1746"><span class="lineNum">    1746 </span><span class="lineCov">       9646 :         if (operatorDefinition)</span></a>
<a name="1747"><span class="lineNum">    1747 </span>            :         {</a>
<a name="1748"><span class="lineNum">    1748 </span><span class="lineNoCov">          0 :                 TypePointers const&amp; parameterTypes = userDefinedFunctionType-&gt;parameterTypes();</span></a>
<a name="1749"><span class="lineNum">    1749 </span><span class="lineNoCov">          0 :                 TypePointers const&amp; returnParameterTypes = userDefinedFunctionType-&gt;returnParameterTypes();</span></a>
<a name="1750"><span class="lineNum">    1750 </span>            : </a>
<a name="1751"><span class="lineNum">    1751 </span>            :                 // operatorDefinitions() filters out definitions with non-matching first argument.</a>
<a name="1752"><span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                 solAssert(parameterTypes.size() == 2);</span></a>
<a name="1753"><span class="lineNum">    1753 </span><span class="lineNoCov">          0 :                 solAssert(parameterTypes[0] &amp;&amp; *leftType == *parameterTypes[0]);</span></a>
<a name="1754"><span class="lineNum">    1754 </span>            : </a>
<a name="1755"><span class="lineNum">    1755 </span><span class="lineNoCov">          0 :                 if (*rightType != *parameterTypes[0])</span></a>
<a name="1756"><span class="lineNum">    1756 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="1757"><span class="lineNum">    1757 </span>            :                                 5653_error,</a>
<a name="1758"><span class="lineNum">    1758 </span><span class="lineNoCov">          0 :                                 _operation.location(),</span></a>
<a name="1759"><span class="lineNum">    1759 </span><span class="lineNoCov">          0 :                                 fmt::format(</span></a>
<a name="1760"><span class="lineNum">    1760 </span>            :                                         &quot;The type of the second operand of this user-defined binary operator {} &quot;</a>
<a name="1761"><span class="lineNum">    1761 </span>            :                                         &quot;does not match the type of the first operand, which is {}.&quot;,</a>
<a name="1762"><span class="lineNum">    1762 </span><span class="lineNoCov">          0 :                                         TokenTraits::friendlyName(_operation.getOperator()),</span></a>
<a name="1763"><span class="lineNum">    1763 </span><span class="lineNoCov">          0 :                                         parameterTypes[0]-&gt;humanReadableName()</span></a>
<a name="1764"><span class="lineNum">    1764 </span>            :                                 )</a>
<a name="1765"><span class="lineNum">    1765 </span>            :                         );</a>
<a name="1766"><span class="lineNum">    1766 </span>            : </a>
<a name="1767"><span class="lineNum">    1767 </span><span class="lineNoCov">          0 :                 if (!returnParameterTypes.empty())</span></a>
<a name="1768"><span class="lineNum">    1768 </span>            :                         // Use the actual result type from operator definition. Ignore all values but the</a>
<a name="1769"><span class="lineNum">    1769 </span>            :                         // first one - in valid code there will be only one anyway.</a>
<a name="1770"><span class="lineNum">    1770 </span><span class="lineNoCov">          0 :                         resultType = returnParameterTypes[0];</span></a>
<a name="1771"><span class="lineNum">    1771 </span>            :         }</a>
<a name="1772"><span class="lineNum">    1772 </span>            : </a>
<a name="1773"><span class="lineNum">    1773 </span><span class="lineCov">       9646 :         _operation.annotation().type = resultType;</span></a>
<a name="1774"><span class="lineNum">    1774 </span><span class="lineCov">      19292 :         _operation.annotation().isPure =</span></a>
<a name="1775"><span class="lineNum">    1775 </span><span class="lineCov">       9646 :                 *_operation.leftExpression().annotation().isPure &amp;&amp;</span></a>
<a name="1776"><span class="lineNum">    1776 </span><span class="lineCov">       9646 :                 *_operation.rightExpression().annotation().isPure &amp;&amp;</span></a>
<a name="1777"><span class="lineNum">    1777 </span><span class="lineCov">       9646 :                 (!userDefinedFunctionType || userDefinedFunctionType-&gt;isPure());</span></a>
<a name="1778"><span class="lineNum">    1778 </span><span class="lineCov">       9646 :         _operation.annotation().isLValue = false;</span></a>
<a name="1779"><span class="lineNum">    1779 </span><span class="lineCov">       9646 :         _operation.annotation().isConstant = false;</span></a>
<a name="1780"><span class="lineNum">    1780 </span>            : </a>
<a name="1781"><span class="lineNum">    1781 </span><span class="lineCov">       9646 :         if (_operation.getOperator() == Token::Equal || _operation.getOperator() == Token::NotEqual)</span></a>
<a name="1782"><span class="lineNum">    1782 </span>            :         {</a>
<a name="1783"><span class="lineNum">    1783 </span><span class="lineCov">        822 :                 auto const* leftFunction = dynamic_cast&lt;FunctionType const*&gt;(leftType);</span></a>
<a name="1784"><span class="lineNum">    1784 </span><span class="lineCov">        822 :                 auto const* rightFunction = dynamic_cast&lt;FunctionType const*&gt;(rightType);</span></a>
<a name="1785"><span class="lineNum">    1785 </span><span class="lineCov">        822 :                 if (</span></a>
<a name="1786"><span class="lineNum">    1786 </span><span class="lineCov">          1 :                         leftFunction &amp;&amp;</span></a>
<a name="1787"><span class="lineNum">    1787 </span><span class="lineNoCov">          0 :                         rightFunction &amp;&amp;</span></a>
<a name="1788"><span class="lineNum">    1788 </span><span class="lineCov">        823 :                         leftFunction-&gt;kind() == FunctionType::Kind::Internal &amp;&amp;</span></a>
<a name="1789"><span class="lineNum">    1789 </span><span class="lineNoCov">          0 :                         rightFunction-&gt;kind() == FunctionType::Kind::Internal</span></a>
<a name="1790"><span class="lineNum">    1790 </span>            :                 )</a>
<a name="1791"><span class="lineNum">    1791 </span>            :                 {</a>
<a name="1792"><span class="lineNum">    1792 </span><span class="lineNoCov">          0 :                         m_errorReporter.warning(</span></a>
<a name="1793"><span class="lineNum">    1793 </span>            :                                 3075_error,</a>
<a name="1794"><span class="lineNum">    1794 </span><span class="lineNoCov">          0 :                                 _operation.location(),</span></a>
<a name="1795"><span class="lineNum">    1795 </span>            :                                 &quot;Comparison of internal function pointers can yield unexpected results &quot;</a>
<a name="1796"><span class="lineNum">    1796 </span>            :                                 &quot;in the legacy pipeline with the optimizer enabled, and will be disallowed entirely &quot;</a>
<a name="1797"><span class="lineNum">    1797 </span>            :                                 &quot;in the next breaking release.&quot;</a>
<a name="1798"><span class="lineNum">    1798 </span>            :                         );</a>
<a name="1799"><span class="lineNum">    1799 </span>            :                 }</a>
<a name="1800"><span class="lineNum">    1800 </span>            :         }</a>
<a name="1801"><span class="lineNum">    1801 </span>            : </a>
<a name="1802"><span class="lineNum">    1802 </span><span class="lineCov">       9646 :         if (_operation.getOperator() == Token::Exp || _operation.getOperator() == Token::SHL)</span></a>
<a name="1803"><span class="lineNum">    1803 </span>            :         {</a>
<a name="1804"><span class="lineNum">    1804 </span><span class="lineCov">        654 :                 std::string operation = _operation.getOperator() == Token::Exp ? &quot;exponentiation&quot; : &quot;shift&quot;;</span></a>
<a name="1805"><span class="lineNum">    1805 </span><span class="lineCov">        327 :                 if (</span></a>
<a name="1806"><span class="lineNum">    1806 </span><span class="lineCov">        552 :                         leftType-&gt;category() == Type::Category::RationalNumber &amp;&amp;</span></a>
<a name="1807"><span class="lineNum">    1807 </span><span class="lineCov">        225 :                         rightType-&gt;category() != Type::Category::RationalNumber</span></a>
<a name="1808"><span class="lineNum">    1808 </span>            :                 )</a>
<a name="1809"><span class="lineNum">    1809 </span>            :                 {</a>
<a name="1810"><span class="lineNum">    1810 </span>            :                         // These rules are enforced by the binary operator, but assert them here too.</a>
<a name="1811"><span class="lineNum">    1811 </span><span class="lineCov">         35 :                         if (auto type = dynamic_cast&lt;IntegerType const*&gt;(commonType))</span></a>
<a name="1812"><span class="lineNum">    1812 </span><span class="lineCov">         35 :                                 solAssert(type-&gt;numBits() == 256, &quot;&quot;);</span></a>
<a name="1813"><span class="lineNum">    1813 </span><span class="lineCov">         35 :                         if (auto type = dynamic_cast&lt;FixedPointType const*&gt;(commonType))</span></a>
<a name="1814"><span class="lineNum">    1814 </span><span class="lineNoCov">          0 :                                 solAssert(type-&gt;numBits() == 256, &quot;&quot;);</span></a>
<a name="1815"><span class="lineNum">    1815 </span>            :                 }</a>
<a name="1816"><span class="lineNum">    1816 </span><span class="lineCov">        327 :                 if (</span></a>
<a name="1817"><span class="lineNum">    1817 </span><span class="lineCov">        327 :                         commonType-&gt;category() == Type::Category::Integer &amp;&amp;</span></a>
<a name="1818"><span class="lineNum">    1818 </span><span class="lineCov">        379 :                         rightType-&gt;category() == Type::Category::Integer &amp;&amp;</span></a>
<a name="1819"><span class="lineNum">    1819 </span><span class="lineCov">         52 :                         dynamic_cast&lt;IntegerType const&amp;&gt;(*commonType).numBits() &lt;</span></a>
<a name="1820"><span class="lineNum">    1820 </span><span class="lineCov">         52 :                         dynamic_cast&lt;IntegerType const&amp;&gt;(*rightType).numBits()</span></a>
<a name="1821"><span class="lineNum">    1821 </span>            :                 )</a>
<a name="1822"><span class="lineNum">    1822 </span><span class="lineCov">          1 :                         m_errorReporter.warning(</span></a>
<a name="1823"><span class="lineNum">    1823 </span>            :                                 3149_error,</a>
<a name="1824"><span class="lineNum">    1824 </span><span class="lineCov">          1 :                                 _operation.location(),</span></a>
<a name="1825"><span class="lineNum">    1825 </span><span class="lineCov">          2 :                                 fmt::format(</span></a>
<a name="1826"><span class="lineNum">    1826 </span>            :                                         &quot;The result type of the {} operation is equal to the type of the first operand ({}) &quot;</a>
<a name="1827"><span class="lineNum">    1827 </span>            :                                         &quot;ignoring the (larger) type of the second operand ({}) which might be unexpected. &quot;</a>
<a name="1828"><span class="lineNum">    1828 </span>            :                                         &quot;Silence this warning by either converting the first or the second operand to the type of the other.&quot;,</a>
<a name="1829"><span class="lineNum">    1829 </span>            :                                         operation,</a>
<a name="1830"><span class="lineNum">    1830 </span><span class="lineCov">          2 :                                         commonType-&gt;humanReadableName(),</span></a>
<a name="1831"><span class="lineNum">    1831 </span><span class="lineCov">          2 :                                         rightType-&gt;humanReadableName()</span></a>
<a name="1832"><span class="lineNum">    1832 </span>            :                                 )</a>
<a name="1833"><span class="lineNum">    1833 </span>            :                         );</a>
<a name="1834"><span class="lineNum">    1834 </span>            :         }</a>
<a name="1835"><span class="lineNum">    1835 </span><span class="lineCov">       9646 : }</span></a>
<a name="1836"><span class="lineNum">    1836 </span>            : </a>
<a name="1837"><span class="lineNum">    1837 </span><span class="lineCov">       2177 : Type const* TypeChecker::typeCheckTypeConversionAndRetrieveReturnType(</span></a>
<a name="1838"><span class="lineNum">    1838 </span>            :         FunctionCall const&amp; _functionCall</a>
<a name="1839"><span class="lineNum">    1839 </span>            : )</a>
<a name="1840"><span class="lineNum">    1840 </span>            : {</a>
<a name="1841"><span class="lineNum">    1841 </span><span class="lineCov">       2177 :         solAssert(*_functionCall.annotation().kind == FunctionCallKind::TypeConversion, &quot;&quot;);</span></a>
<a name="1842"><span class="lineNum">    1842 </span><span class="lineCov">       2177 :         Type const* expressionType = type(_functionCall.expression());</span></a>
<a name="1843"><span class="lineNum">    1843 </span>            : </a>
<a name="1844"><span class="lineNum">    1844 </span><span class="lineCov">       2177 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; const&amp; arguments = _functionCall.arguments();</span></a>
<a name="1845"><span class="lineNum">    1845 </span><span class="lineCov">       2177 :         bool const isPositionalCall = _functionCall.names().empty();</span></a>
<a name="1846"><span class="lineNum">    1846 </span>            : </a>
<a name="1847"><span class="lineNum">    1847 </span><span class="lineCov">       2177 :         Type const* resultType = dynamic_cast&lt;TypeType const&amp;&gt;(*expressionType).actualType();</span></a>
<a name="1848"><span class="lineNum">    1848 </span><span class="lineCov">       2177 :         if (arguments.size() != 1)</span></a>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineCov">         48 :                 m_errorReporter.typeError(</span></a>
<a name="1850"><span class="lineNum">    1850 </span>            :                         2558_error,</a>
<a name="1851"><span class="lineNum">    1851 </span><span class="lineCov">         24 :                         _functionCall.location(),</span></a>
<a name="1852"><span class="lineNum">    1852 </span>            :                         &quot;Exactly one argument expected for explicit type conversion.&quot;</a>
<a name="1853"><span class="lineNum">    1853 </span>            :                 );</a>
<a name="1854"><span class="lineNum">    1854 </span><span class="lineCov">       2153 :         else if (!isPositionalCall)</span></a>
<a name="1855"><span class="lineNum">    1855 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="1856"><span class="lineNum">    1856 </span>            :                         5153_error,</a>
<a name="1857"><span class="lineNum">    1857 </span><span class="lineNoCov">          0 :                         _functionCall.location(),</span></a>
<a name="1858"><span class="lineNum">    1858 </span>            :                         &quot;Type conversion cannot allow named arguments.&quot;</a>
<a name="1859"><span class="lineNum">    1859 </span>            :                 );</a>
<a name="1860"><span class="lineNum">    1860 </span>            :         else</a>
<a name="1861"><span class="lineNum">    1861 </span>            :         {</a>
<a name="1862"><span class="lineNum">    1862 </span><span class="lineCov">       2153 :                 Type const* argType = type(*arguments.front());</span></a>
<a name="1863"><span class="lineNum">    1863 </span>            :                 // Resulting data location is memory unless we are converting from a reference</a>
<a name="1864"><span class="lineNum">    1864 </span>            :                 // type with a different data location.</a>
<a name="1865"><span class="lineNum">    1865 </span>            :                 // (data location cannot yet be specified for type conversions)</a>
<a name="1866"><span class="lineNum">    1866 </span><span class="lineCov">       2153 :                 DataLocation dataLoc = DataLocation::Memory;</span></a>
<a name="1867"><span class="lineNum">    1867 </span><span class="lineCov">       2153 :                 if (auto argRefType = dynamic_cast&lt;ReferenceType const*&gt;(argType))</span></a>
<a name="1868"><span class="lineNum">    1868 </span><span class="lineCov">         29 :                         dataLoc = argRefType-&gt;location();</span></a>
<a name="1869"><span class="lineNum">    1869 </span><span class="lineCov">       2153 :                 if (auto type = dynamic_cast&lt;ReferenceType const*&gt;(resultType))</span></a>
<a name="1870"><span class="lineNum">    1870 </span><span class="lineCov">         24 :                         resultType = TypeProvider::withLocation(type, dataLoc, type-&gt;isPointer());</span></a>
<a name="1871"><span class="lineNum">    1871 </span><span class="lineCov">       4306 :                 BoolResult result = argType-&gt;isExplicitlyConvertibleTo(*resultType);</span></a>
<a name="1872"><span class="lineNum">    1872 </span><span class="lineCov">       2153 :                 if (result)</span></a>
<a name="1873"><span class="lineNum">    1873 </span>            :                 {</a>
<a name="1874"><span class="lineNum">    1874 </span><span class="lineCov">       1847 :                         if (auto argArrayType = dynamic_cast&lt;ArrayType const*&gt;(argType))</span></a>
<a name="1875"><span class="lineNum">    1875 </span>            :                         {</a>
<a name="1876"><span class="lineNum">    1876 </span><span class="lineCov">         12 :                                 if (auto resultArrayType = dynamic_cast&lt;ArrayType const*&gt;(resultType))</span></a>
<a name="1877"><span class="lineNum">    1877 </span><span class="lineCov">         12 :                                         solAssert(</span></a>
<a name="1878"><span class="lineNum">    1878 </span>            :                                                 argArrayType-&gt;location() != DataLocation::Storage ||</a>
<a name="1879"><span class="lineNum">    1879 </span>            :                                                 (</a>
<a name="1880"><span class="lineNum">    1880 </span>            :                                                         (</a>
<a name="1881"><span class="lineNum">    1881 </span>            :                                                                 resultArrayType-&gt;isPointer() ||</a>
<a name="1882"><span class="lineNum">    1882 </span>            :                                                                 (argArrayType-&gt;isByteArrayOrString() &amp;&amp; resultArrayType-&gt;isByteArrayOrString())</a>
<a name="1883"><span class="lineNum">    1883 </span>            :                                                         ) &amp;&amp;</a>
<a name="1884"><span class="lineNum">    1884 </span>            :                                                         resultArrayType-&gt;location() == DataLocation::Storage</a>
<a name="1885"><span class="lineNum">    1885 </span>            :                                                 ),</a>
<a name="1886"><span class="lineNum">    1886 </span>            :                                                 &quot;Invalid explicit conversion to storage type.&quot;</a>
<a name="1887"><span class="lineNum">    1887 </span>            :                                         );</a>
<a name="1888"><span class="lineNum">    1888 </span>            :                                 else</a>
<a name="1889"><span class="lineNum">    1889 </span><span class="lineNoCov">          0 :                                         solAssert(</span></a>
<a name="1890"><span class="lineNum">    1890 </span>            :                                                 argArrayType-&gt;isByteArray() &amp;&amp; resultType-&gt;category() == Type::Category::FixedBytes,</a>
<a name="1891"><span class="lineNum">    1891 </span>            :                                                 &quot;&quot;</a>
<a name="1892"><span class="lineNum">    1892 </span>            :                                         );</a>
<a name="1893"><span class="lineNum">    1893 </span>            :                         }</a>
<a name="1894"><span class="lineNum">    1894 </span>            :                 }</a>
<a name="1895"><span class="lineNum">    1895 </span>            :                 else</a>
<a name="1896"><span class="lineNum">    1896 </span>            :                 {</a>
<a name="1897"><span class="lineNum">    1897 </span><span class="lineCov">        306 :                         if (</span></a>
<a name="1898"><span class="lineNum">    1898 </span><span class="lineCov">        333 :                                 resultType-&gt;category() == Type::Category::Contract &amp;&amp;</span></a>
<a name="1899"><span class="lineNum">    1899 </span><span class="lineCov">         27 :                                 argType-&gt;category() == Type::Category::Address</span></a>
<a name="1900"><span class="lineNum">    1900 </span>            :                         )</a>
<a name="1901"><span class="lineNum">    1901 </span>            :                         {</a>
<a name="1902"><span class="lineNum">    1902 </span><span class="lineNoCov">          0 :                                 solAssert(dynamic_cast&lt;ContractType const*&gt;(resultType)-&gt;isPayable(), &quot;&quot;);</span></a>
<a name="1903"><span class="lineNum">    1903 </span><span class="lineNoCov">          0 :                                 solAssert(</span></a>
<a name="1904"><span class="lineNum">    1904 </span>            :                                         dynamic_cast&lt;AddressType const*&gt;(argType)-&gt;stateMutability() &lt;</a>
<a name="1905"><span class="lineNum">    1905 </span>            :                                                 StateMutability::Payable,</a>
<a name="1906"><span class="lineNum">    1906 </span>            :                                         &quot;&quot;</a>
<a name="1907"><span class="lineNum">    1907 </span>            :                                 );</a>
<a name="1908"><span class="lineNum">    1908 </span><span class="lineNoCov">          0 :                                 SecondarySourceLocation ssl;</span></a>
<a name="1909"><span class="lineNum">    1909 </span><span class="lineNoCov">          0 :                                 if (</span></a>
<a name="1910"><span class="lineNum">    1910 </span><span class="lineNoCov">          0 :                                         auto const* identifier = dynamic_cast&lt;Identifier const*&gt;(arguments.front().get())</span></a>
<a name="1911"><span class="lineNum">    1911 </span>            :                                 )</a>
<a name="1912"><span class="lineNum">    1912 </span><span class="lineNoCov">          0 :                                         if (</span></a>
<a name="1913"><span class="lineNum">    1913 </span><span class="lineNoCov">          0 :                                                 auto const* variableDeclaration = dynamic_cast&lt;VariableDeclaration const*&gt;(</span></a>
<a name="1914"><span class="lineNum">    1914 </span><span class="lineNoCov">          0 :                                                         identifier-&gt;annotation().referencedDeclaration</span></a>
<a name="1915"><span class="lineNum">    1915 </span><span class="lineNoCov">          0 :                                                 )</span></a>
<a name="1916"><span class="lineNum">    1916 </span>            :                                         )</a>
<a name="1917"><span class="lineNum">    1917 </span>            :                                                 ssl.append(</a>
<a name="1918"><span class="lineNum">    1918 </span>            :                                                         &quot;Did you mean to declare this variable as \&quot;address payable\&quot;?&quot;,</a>
<a name="1919"><span class="lineNum">    1919 </span><span class="lineNoCov">          0 :                                                         variableDeclaration-&gt;location()</span></a>
<a name="1920"><span class="lineNum">    1920 </span><span class="lineNoCov">          0 :                                                 );</span></a>
<a name="1921"><span class="lineNum">    1921 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="1922"><span class="lineNum">    1922 </span>            :                                         7398_error,</a>
<a name="1923"><span class="lineNum">    1923 </span><span class="lineNoCov">          0 :                                         _functionCall.location(),</span></a>
<a name="1924"><span class="lineNum">    1924 </span>            :                                         ssl,</a>
<a name="1925"><span class="lineNum">    1925 </span><span class="lineNoCov">          0 :                                         &quot;Explicit type conversion not allowed from non-payable \&quot;address\&quot; to \&quot;&quot; +</span></a>
<a name="1926"><span class="lineNum">    1926 </span><span class="lineNoCov">          0 :                                         resultType-&gt;humanReadableName() +</span></a>
<a name="1927"><span class="lineNum">    1927 </span>            :                                         &quot;\&quot;, which has a payable fallback function.&quot;</a>
<a name="1928"><span class="lineNum">    1928 </span>            :                                 );</a>
<a name="1929"><span class="lineNum">    1929 </span>            :                         }</a>
<a name="1930"><span class="lineNum">    1930 </span><span class="lineCov">        306 :                         else if (</span></a>
<a name="1931"><span class="lineNum">    1931 </span><span class="lineCov">        306 :                                 auto const* functionType = dynamic_cast&lt;FunctionType const*&gt;(argType);</span></a>
<a name="1932"><span class="lineNum">    1932 </span><span class="lineCov">          1 :                                 functionType &amp;&amp;</span></a>
<a name="1933"><span class="lineNum">    1933 </span><span class="lineCov">        306 :                                 functionType-&gt;kind() == FunctionType::Kind::External &amp;&amp;</span></a>
<a name="1934"><span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                                 resultType-&gt;category() == Type::Category::Address</span></a>
<a name="1935"><span class="lineNum">    1935 </span>            :                         )</a>
<a name="1936"><span class="lineNum">    1936 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="1937"><span class="lineNum">    1937 </span>            :                                         5030_error,</a>
<a name="1938"><span class="lineNum">    1938 </span><span class="lineNoCov">          0 :                                         _functionCall.location(),</span></a>
<a name="1939"><span class="lineNum">    1939 </span><span class="lineNoCov">          0 :                                         &quot;Explicit type conversion not allowed from \&quot;&quot; +</span></a>
<a name="1940"><span class="lineNum">    1940 </span><span class="lineNoCov">          0 :                                         argType-&gt;humanReadableName() +</span></a>
<a name="1941"><span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                                         &quot;\&quot; to \&quot;&quot; +</span></a>
<a name="1942"><span class="lineNum">    1942 </span><span class="lineNoCov">          0 :                                         resultType-&gt;humanReadableName() +</span></a>
<a name="1943"><span class="lineNum">    1943 </span><span class="lineNoCov">          0 :                                         &quot;\&quot;. To obtain the address of the contract of the function, &quot; +</span></a>
<a name="1944"><span class="lineNum">    1944 </span>            :                                         &quot;you can use the .address member of the function.&quot;</a>
<a name="1945"><span class="lineNum">    1945 </span>            :                                 );</a>
<a name="1946"><span class="lineNum">    1946 </span>            :                         else</a>
<a name="1947"><span class="lineNum">    1947 </span><span class="lineCov">        306 :                                 m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="1948"><span class="lineNum">    1948 </span>            :                                         9640_error,</a>
<a name="1949"><span class="lineNum">    1949 </span><span class="lineCov">        306 :                                         _functionCall.location(),</span></a>
<a name="1950"><span class="lineNum">    1950 </span><span class="lineCov">        306 :                                         &quot;Explicit type conversion not allowed from \&quot;&quot; +</span></a>
<a name="1951"><span class="lineNum">    1951 </span><span class="lineCov">        918 :                                         argType-&gt;humanReadableName() +</span></a>
<a name="1952"><span class="lineNum">    1952 </span><span class="lineCov">        612 :                                         &quot;\&quot; to \&quot;&quot; +</span></a>
<a name="1953"><span class="lineNum">    1953 </span><span class="lineCov">       1224 :                                         resultType-&gt;humanReadableName() +</span></a>
<a name="1954"><span class="lineNum">    1954 </span>            :                                         &quot;\&quot;.&quot;,</a>
<a name="1955"><span class="lineNum">    1955 </span><span class="lineCov">        306 :                                         result.message()</span></a>
<a name="1956"><span class="lineNum">    1956 </span>            :                                 );</a>
<a name="1957"><span class="lineNum">    1957 </span>            :                 }</a>
<a name="1958"><span class="lineNum">    1958 </span>            :         }</a>
<a name="1959"><span class="lineNum">    1959 </span><span class="lineCov">       4354 :         return resultType;</span></a>
<a name="1960"><span class="lineNum">    1960 </span>            : }</a>
<a name="1961"><span class="lineNum">    1961 </span>            : </a>
<a name="1962"><span class="lineNum">    1962 </span><span class="lineCov">       2411 : void TypeChecker::typeCheckFunctionCall(</span></a>
<a name="1963"><span class="lineNum">    1963 </span>            :         FunctionCall const&amp; _functionCall,</a>
<a name="1964"><span class="lineNum">    1964 </span>            :         FunctionTypePointer _functionType</a>
<a name="1965"><span class="lineNum">    1965 </span>            : )</a>
<a name="1966"><span class="lineNum">    1966 </span>            : {</a>
<a name="1967"><span class="lineNum">    1967 </span>            :         // Actual function call or struct constructor call.</a>
<a name="1968"><span class="lineNum">    1968 </span>            : </a>
<a name="1969"><span class="lineNum">    1969 </span><span class="lineCov">       2411 :         solAssert(!!_functionType, &quot;&quot;);</span></a>
<a name="1970"><span class="lineNum">    1970 </span><span class="lineCov">       2411 :         solAssert(_functionType-&gt;kind() != FunctionType::Kind::ABIDecode, &quot;&quot;);</span></a>
<a name="1971"><span class="lineNum">    1971 </span>            : </a>
<a name="1972"><span class="lineNum">    1972 </span><span class="lineCov">       2411 :         if (_functionType-&gt;kind() == FunctionType::Kind::Declaration)</span></a>
<a name="1973"><span class="lineNum">    1973 </span>            :         {</a>
<a name="1974"><span class="lineNum">    1974 </span><span class="lineCov">          5 :                 solAssert(_functionType-&gt;declaration().annotation().contract, &quot;&quot;);</span></a>
<a name="1975"><span class="lineNum">    1975 </span><span class="lineCov">          5 :                 if (</span></a>
<a name="1976"><span class="lineNum">    1976 </span><span class="lineCov">         10 :                         m_currentContract &amp;&amp;</span></a>
<a name="1977"><span class="lineNum">    1977 </span><span class="lineCov">          5 :                         m_currentContract-&gt;derivesFrom(*_functionType-&gt;declaration().annotation().contract) &amp;&amp;</span></a>
<a name="1978"><span class="lineNum">    1978 </span><span class="lineNoCov">          0 :                         !dynamic_cast&lt;FunctionDefinition const&amp;&gt;(_functionType-&gt;declaration()).isImplemented()</span></a>
<a name="1979"><span class="lineNum">    1979 </span>            :                 )</a>
<a name="1980"><span class="lineNum">    1980 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="1981"><span class="lineNum">    1981 </span>            :                                 7501_error,</a>
<a name="1982"><span class="lineNum">    1982 </span><span class="lineNoCov">          0 :                                 _functionCall.location(),</span></a>
<a name="1983"><span class="lineNum">    1983 </span>            :                                 &quot;Cannot call unimplemented base function.&quot;</a>
<a name="1984"><span class="lineNum">    1984 </span>            :                         );</a>
<a name="1985"><span class="lineNum">    1985 </span>            :                 else</a>
<a name="1986"><span class="lineNum">    1986 </span><span class="lineCov">         10 :                         m_errorReporter.typeError(</span></a>
<a name="1987"><span class="lineNum">    1987 </span>            :                                 3419_error,</a>
<a name="1988"><span class="lineNum">    1988 </span><span class="lineCov">          5 :                                 _functionCall.location(),</span></a>
<a name="1989"><span class="lineNum">    1989 </span>            :                                 &quot;Cannot call function via contract type name.&quot;</a>
<a name="1990"><span class="lineNum">    1990 </span>            :                         );</a>
<a name="1991"><span class="lineNum">    1991 </span><span class="lineCov">          5 :                 return;</span></a>
<a name="1992"><span class="lineNum">    1992 </span>            :         }</a>
<a name="1993"><span class="lineNum">    1993 </span>            : </a>
<a name="1994"><span class="lineNum">    1994 </span>            :         // Check for unsupported use of bare static call</a>
<a name="1995"><span class="lineNum">    1995 </span><span class="lineCov">       2406 :         if (</span></a>
<a name="1996"><span class="lineNum">    1996 </span><span class="lineCov">       2406 :                 _functionType-&gt;kind() == FunctionType::Kind::BareStaticCall &amp;&amp;</span></a>
<a name="1997"><span class="lineNum">    1997 </span><span class="lineNoCov">          0 :                 !m_evmVersion.hasStaticCall()</span></a>
<a name="1998"><span class="lineNum">    1998 </span>            :         )</a>
<a name="1999"><span class="lineNum">    1999 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="2000"><span class="lineNum">    2000 </span>            :                         5052_error,</a>
<a name="2001"><span class="lineNum">    2001 </span><span class="lineNoCov">          0 :                         _functionCall.location(),</span></a>
<a name="2002"><span class="lineNum">    2002 </span>            :                         &quot;\&quot;staticcall\&quot; is not supported by the VM version.&quot;</a>
<a name="2003"><span class="lineNum">    2003 </span>            :                 );</a>
<a name="2004"><span class="lineNum">    2004 </span>            : </a>
<a name="2005"><span class="lineNum">    2005 </span>            :         // Perform standard function call type checking</a>
<a name="2006"><span class="lineNum">    2006 </span><span class="lineCov">       2406 :         typeCheckFunctionGeneralChecks(_functionCall, _functionType);</span></a>
<a name="2007"><span class="lineNum">    2007 </span>            : }</a>
<a name="2008"><span class="lineNum">    2008 </span>            : </a>
<a name="2009"><span class="lineNum">    2009 </span><span class="lineCov">         15 : void TypeChecker::typeCheckFallbackFunction(FunctionDefinition const&amp; _function)</span></a>
<a name="2010"><span class="lineNum">    2010 </span>            : {</a>
<a name="2011"><span class="lineNum">    2011 </span><span class="lineCov">         15 :         solAssert(_function.isFallback(), &quot;&quot;);</span></a>
<a name="2012"><span class="lineNum">    2012 </span>            : </a>
<a name="2013"><span class="lineNum">    2013 </span><span class="lineCov">         15 :         if (_function.libraryFunction())</span></a>
<a name="2014"><span class="lineNum">    2014 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(5982_error, _function.location(), &quot;Libraries cannot have fallback functions.&quot;);</span></a>
<a name="2015"><span class="lineNum">    2015 </span><span class="lineCov">         15 :         if (_function.stateMutability() != StateMutability::NonPayable &amp;&amp; _function.stateMutability() != StateMutability::Payable)</span></a>
<a name="2016"><span class="lineNum">    2016 </span><span class="lineCov">          2 :                 m_errorReporter.typeError(</span></a>
<a name="2017"><span class="lineNum">    2017 </span>            :                         4575_error,</a>
<a name="2018"><span class="lineNum">    2018 </span><span class="lineCov">          2 :                         _function.location(),</span></a>
<a name="2019"><span class="lineNum">    2019 </span><span class="lineCov">          2 :                         &quot;Fallback function must be payable or non-payable, but is \&quot;&quot; +</span></a>
<a name="2020"><span class="lineNum">    2020 </span><span class="lineCov">          6 :                         stateMutabilityToString(_function.stateMutability()) +</span></a>
<a name="2021"><span class="lineNum">    2021 </span>            :                         &quot;\&quot;.&quot;</a>
<a name="2022"><span class="lineNum">    2022 </span>            :                 );</a>
<a name="2023"><span class="lineNum">    2023 </span><span class="lineCov">         15 :         if (_function.visibility() != Visibility::External)</span></a>
<a name="2024"><span class="lineNum">    2024 </span><span class="lineCov">          8 :                 m_errorReporter.typeError(1159_error, _function.location(), &quot;Fallback function must be defined as \&quot;external\&quot;.&quot;);</span></a>
<a name="2025"><span class="lineNum">    2025 </span>            : </a>
<a name="2026"><span class="lineNum">    2026 </span><span class="lineCov">         15 :         if (!_function.returnParameters().empty() || !_function.parameters().empty())</span></a>
<a name="2027"><span class="lineNum">    2027 </span>            :         {</a>
<a name="2028"><span class="lineNum">    2028 </span><span class="lineCov">          1 :                 if (</span></a>
<a name="2029"><span class="lineNum">    2029 </span><span class="lineCov">          1 :                         _function.returnParameters().size() != 1 ||</span></a>
<a name="2030"><span class="lineNum">    2030 </span><span class="lineCov">          1 :                         *type(*_function.returnParameters().front()) != *TypeProvider::bytesMemory() ||</span></a>
<a name="2031"><span class="lineNum">    2031 </span><span class="lineCov">          2 :                         _function.parameters().size() != 1 ||</span></a>
<a name="2032"><span class="lineNum">    2032 </span><span class="lineNoCov">          0 :                         *type(*_function.parameters().front()) != *TypeProvider::bytesCalldata()</span></a>
<a name="2033"><span class="lineNum">    2033 </span>            :                 )</a>
<a name="2034"><span class="lineNum">    2034 </span><span class="lineCov">          2 :                         m_errorReporter.typeError(</span></a>
<a name="2035"><span class="lineNum">    2035 </span>            :                                 5570_error,</a>
<a name="2036"><span class="lineNum">    2036 </span><span class="lineCov">          1 :                                 _function.returnParameterList()-&gt;location(),</span></a>
<a name="2037"><span class="lineNum">    2037 </span>            :                                 &quot;Fallback function either has to have the signature \&quot;fallback()\&quot; or \&quot;fallback(bytes calldata) returns (bytes memory)\&quot;.&quot;</a>
<a name="2038"><span class="lineNum">    2038 </span>            :                         );</a>
<a name="2039"><span class="lineNum">    2039 </span>            :         }</a>
<a name="2040"><span class="lineNum">    2040 </span><span class="lineCov">         15 : }</span></a>
<a name="2041"><span class="lineNum">    2041 </span>            : </a>
<a name="2042"><span class="lineNum">    2042 </span><span class="lineCov">       1431 : void TypeChecker::typeCheckConstructor(FunctionDefinition const&amp; _function)</span></a>
<a name="2043"><span class="lineNum">    2043 </span>            : {</a>
<a name="2044"><span class="lineNum">    2044 </span><span class="lineCov">       1431 :         solAssert(_function.isConstructor(), &quot;&quot;);</span></a>
<a name="2045"><span class="lineNum">    2045 </span><span class="lineCov">       1431 :         if (_function.overrides())</span></a>
<a name="2046"><span class="lineNum">    2046 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(1209_error, _function.location(), &quot;Constructors cannot override.&quot;);</span></a>
<a name="2047"><span class="lineNum">    2047 </span><span class="lineCov">       1431 :         if (!_function.returnParameters().empty())</span></a>
<a name="2048"><span class="lineNum">    2048 </span><span class="lineCov">          1 :                 m_errorReporter.typeError(9712_error, _function.returnParameterList()-&gt;location(), &quot;Non-empty \&quot;returns\&quot; directive for constructor.&quot;);</span></a>
<a name="2049"><span class="lineNum">    2049 </span><span class="lineCov">       1431 :         if (_function.stateMutability() != StateMutability::NonPayable &amp;&amp; _function.stateMutability() != StateMutability::Payable)</span></a>
<a name="2050"><span class="lineNum">    2050 </span><span class="lineCov">          1 :                 m_errorReporter.typeError(</span></a>
<a name="2051"><span class="lineNum">    2051 </span>            :                         1558_error,</a>
<a name="2052"><span class="lineNum">    2052 </span><span class="lineCov">          1 :                         _function.location(),</span></a>
<a name="2053"><span class="lineNum">    2053 </span><span class="lineCov">          1 :                         &quot;Constructor must be payable or non-payable, but is \&quot;&quot; +</span></a>
<a name="2054"><span class="lineNum">    2054 </span><span class="lineCov">          3 :                         stateMutabilityToString(_function.stateMutability()) +</span></a>
<a name="2055"><span class="lineNum">    2055 </span>            :                         &quot;\&quot;.&quot;</a>
<a name="2056"><span class="lineNum">    2056 </span>            :                 );</a>
<a name="2057"><span class="lineNum">    2057 </span><span class="lineCov">       1431 :         if (!_function.noVisibilitySpecified())</span></a>
<a name="2058"><span class="lineNum">    2058 </span>            :         {</a>
<a name="2059"><span class="lineNum">    2059 </span><span class="lineCov">       1094 :                 auto const&amp; contract = dynamic_cast&lt;ContractDefinition const&amp;&gt;(*_function.scope());</span></a>
<a name="2060"><span class="lineNum">    2060 </span><span class="lineCov">       1094 :                 if (_function.visibility() != Visibility::Public &amp;&amp; _function.visibility() != Visibility::Internal)</span></a>
<a name="2061"><span class="lineNum">    2061 </span><span class="lineCov">          2 :                         m_errorReporter.typeError(9239_error, _function.location(), &quot;Constructor cannot have visibility.&quot;);</span></a>
<a name="2062"><span class="lineNum">    2062 </span><span class="lineCov">       1092 :                 else if (_function.isPublic() &amp;&amp; contract.abstract())</span></a>
<a name="2063"><span class="lineNum">    2063 </span><span class="lineCov">          2 :                         m_errorReporter.declarationError(</span></a>
<a name="2064"><span class="lineNum">    2064 </span>            :                                 8295_error,</a>
<a name="2065"><span class="lineNum">    2065 </span><span class="lineCov">          1 :                                 _function.location(),</span></a>
<a name="2066"><span class="lineNum">    2066 </span>            :                                 &quot;Abstract contracts cannot have public constructors. Remove the \&quot;public\&quot; keyword to fix this.&quot;</a>
<a name="2067"><span class="lineNum">    2067 </span>            :                         );</a>
<a name="2068"><span class="lineNum">    2068 </span><span class="lineCov">       1091 :                 else if (!_function.isPublic() &amp;&amp; !contract.abstract())</span></a>
<a name="2069"><span class="lineNum">    2069 </span><span class="lineCov">         12 :                         m_errorReporter.declarationError(</span></a>
<a name="2070"><span class="lineNum">    2070 </span>            :                                 1845_error,</a>
<a name="2071"><span class="lineNum">    2071 </span><span class="lineCov">          6 :                                 _function.location(),</span></a>
<a name="2072"><span class="lineNum">    2072 </span>            :                                 &quot;Non-abstract contracts cannot have internal constructors. Remove the \&quot;internal\&quot; keyword and make the contract abstract to fix this.&quot;</a>
<a name="2073"><span class="lineNum">    2073 </span>            :                         );</a>
<a name="2074"><span class="lineNum">    2074 </span>            :                 else</a>
<a name="2075"><span class="lineNum">    2075 </span><span class="lineCov">       2170 :                         m_errorReporter.warning(</span></a>
<a name="2076"><span class="lineNum">    2076 </span>            :                                 2462_error,</a>
<a name="2077"><span class="lineNum">    2077 </span><span class="lineCov">       1085 :                                 _function.location(),</span></a>
<a name="2078"><span class="lineNum">    2078 </span>            :                                 &quot;Visibility for constructor is ignored. If you want the contract to be non-deployable, making it \&quot;abstract\&quot; is sufficient.&quot;</a>
<a name="2079"><span class="lineNum">    2079 </span>            :                         );</a>
<a name="2080"><span class="lineNum">    2080 </span>            :         }</a>
<a name="2081"><span class="lineNum">    2081 </span><span class="lineCov">       1431 : }</span></a>
<a name="2082"><span class="lineNum">    2082 </span>            : </a>
<a name="2083"><span class="lineNum">    2083 </span><span class="lineCov">         37 : void TypeChecker::typeCheckABIEncodeFunctions(</span></a>
<a name="2084"><span class="lineNum">    2084 </span>            :         FunctionCall const&amp; _functionCall,</a>
<a name="2085"><span class="lineNum">    2085 </span>            :         FunctionTypePointer _functionType</a>
<a name="2086"><span class="lineNum">    2086 </span>            : )</a>
<a name="2087"><span class="lineNum">    2087 </span>            : {</a>
<a name="2088"><span class="lineNum">    2088 </span><span class="lineCov">         37 :         solAssert(!!_functionType, &quot;&quot;);</span></a>
<a name="2089"><span class="lineNum">    2089 </span><span class="lineCov">         37 :         solAssert(</span></a>
<a name="2090"><span class="lineNum">    2090 </span>            :                 _functionType-&gt;kind() == FunctionType::Kind::ABIEncode ||</a>
<a name="2091"><span class="lineNum">    2091 </span>            :                 _functionType-&gt;kind() == FunctionType::Kind::ABIEncodePacked ||</a>
<a name="2092"><span class="lineNum">    2092 </span>            :                 _functionType-&gt;kind() == FunctionType::Kind::ABIEncodeWithSelector ||</a>
<a name="2093"><span class="lineNum">    2093 </span>            :                 _functionType-&gt;kind() == FunctionType::Kind::ABIEncodeCall ||</a>
<a name="2094"><span class="lineNum">    2094 </span>            :                 _functionType-&gt;kind() == FunctionType::Kind::ABIEncodeWithSignature,</a>
<a name="2095"><span class="lineNum">    2095 </span>            :                 &quot;ABI function has unexpected FunctionType::Kind.&quot;</a>
<a name="2096"><span class="lineNum">    2096 </span>            :         );</a>
<a name="2097"><span class="lineNum">    2097 </span><span class="lineCov">         37 :         solAssert(_functionType-&gt;takesArbitraryParameters(), &quot;ABI functions should be variadic.&quot;);</span></a>
<a name="2098"><span class="lineNum">    2098 </span>            : </a>
<a name="2099"><span class="lineNum">    2099 </span><span class="lineCov">         37 :         bool const isPacked = _functionType-&gt;kind() == FunctionType::Kind::ABIEncodePacked;</span></a>
<a name="2100"><span class="lineNum">    2100 </span><span class="lineCov">         37 :         solAssert(_functionType-&gt;padArguments() != isPacked, &quot;ABI function with unexpected padding&quot;);</span></a>
<a name="2101"><span class="lineNum">    2101 </span>            : </a>
<a name="2102"><span class="lineNum">    2102 </span><span class="lineCov">         37 :         bool const abiEncoderV2 = useABICoderV2();</span></a>
<a name="2103"><span class="lineNum">    2103 </span>            : </a>
<a name="2104"><span class="lineNum">    2104 </span>            :         // Check for named arguments</a>
<a name="2105"><span class="lineNum">    2105 </span><span class="lineCov">         37 :         if (!_functionCall.names().empty())</span></a>
<a name="2106"><span class="lineNum">    2106 </span>            :         {</a>
<a name="2107"><span class="lineNum">    2107 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="2108"><span class="lineNum">    2108 </span>            :                         2627_error,</a>
<a name="2109"><span class="lineNum">    2109 </span><span class="lineNoCov">          0 :                         _functionCall.location(),</span></a>
<a name="2110"><span class="lineNum">    2110 </span>            :                         &quot;Named arguments cannot be used for functions that take arbitrary parameters.&quot;</a>
<a name="2111"><span class="lineNum">    2111 </span>            :                 );</a>
<a name="2112"><span class="lineNum">    2112 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="2113"><span class="lineNum">    2113 </span>            :         }</a>
<a name="2114"><span class="lineNum">    2114 </span>            : </a>
<a name="2115"><span class="lineNum">    2115 </span>            :         // Perform standard function call type checking</a>
<a name="2116"><span class="lineNum">    2116 </span><span class="lineCov">         37 :         typeCheckFunctionGeneralChecks(_functionCall, _functionType);</span></a>
<a name="2117"><span class="lineNum">    2117 </span>            : </a>
<a name="2118"><span class="lineNum">    2118 </span>            :         // No further generic checks needed as we do a precise check for ABIEncodeCall</a>
<a name="2119"><span class="lineNum">    2119 </span><span class="lineCov">         37 :         if (_functionType-&gt;kind() == FunctionType::Kind::ABIEncodeCall)</span></a>
<a name="2120"><span class="lineNum">    2120 </span>            :         {</a>
<a name="2121"><span class="lineNum">    2121 </span><span class="lineNoCov">          0 :                 typeCheckABIEncodeCallFunction(_functionCall);</span></a>
<a name="2122"><span class="lineNum">    2122 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="2123"><span class="lineNum">    2123 </span>            :         }</a>
<a name="2124"><span class="lineNum">    2124 </span>            : </a>
<a name="2125"><span class="lineNum">    2125 </span>            :         // Check additional arguments for variadic functions</a>
<a name="2126"><span class="lineNum">    2126 </span><span class="lineCov">         74 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; const&amp; arguments = _functionCall.arguments();</span></a>
<a name="2127"><span class="lineNum">    2127 </span><span class="lineCov">         87 :         for (size_t i = 0; i &lt; arguments.size(); ++i)</span></a>
<a name="2128"><span class="lineNum">    2128 </span>            :         {</a>
<a name="2129"><span class="lineNum">    2129 </span><span class="lineCov">         50 :                 auto const&amp; argType = type(*arguments[i]);</span></a>
<a name="2130"><span class="lineNum">    2130 </span>            : </a>
<a name="2131"><span class="lineNum">    2131 </span><span class="lineCov">         50 :                 if (argType-&gt;category() == Type::Category::RationalNumber)</span></a>
<a name="2132"><span class="lineNum">    2132 </span>            :                 {</a>
<a name="2133"><span class="lineNum">    2133 </span><span class="lineCov">          8 :                         auto const&amp; rationalType = dynamic_cast&lt;RationalNumberType const&amp;&gt;(*argType);</span></a>
<a name="2134"><span class="lineNum">    2134 </span><span class="lineCov">          8 :                         if (rationalType.isFractional())</span></a>
<a name="2135"><span class="lineNum">    2135 </span>            :                         {</a>
<a name="2136"><span class="lineNum">    2136 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2137"><span class="lineNum">    2137 </span>            :                                         6090_error,</a>
<a name="2138"><span class="lineNum">    2138 </span><span class="lineNoCov">          0 :                                         arguments[i]-&gt;location(),</span></a>
<a name="2139"><span class="lineNum">    2139 </span>            :                                         &quot;Fractional numbers cannot yet be encoded.&quot;</a>
<a name="2140"><span class="lineNum">    2140 </span>            :                                 );</a>
<a name="2141"><span class="lineNum">    2141 </span><span class="lineNoCov">          0 :                                 continue;</span></a>
<a name="2142"><span class="lineNum">    2142 </span>            :                         }</a>
<a name="2143"><span class="lineNum">    2143 </span><span class="lineCov">          8 :                         else if (!argType-&gt;mobileType())</span></a>
<a name="2144"><span class="lineNum">    2144 </span>            :                         {</a>
<a name="2145"><span class="lineNum">    2145 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2146"><span class="lineNum">    2146 </span>            :                                         8009_error,</a>
<a name="2147"><span class="lineNum">    2147 </span><span class="lineNoCov">          0 :                                         arguments[i]-&gt;location(),</span></a>
<a name="2148"><span class="lineNum">    2148 </span>            :                                         &quot;Invalid rational number (too large or division by zero).&quot;</a>
<a name="2149"><span class="lineNum">    2149 </span>            :                                 );</a>
<a name="2150"><span class="lineNum">    2150 </span><span class="lineNoCov">          0 :                                 continue;</span></a>
<a name="2151"><span class="lineNum">    2151 </span>            :                         }</a>
<a name="2152"><span class="lineNum">    2152 </span><span class="lineCov">          8 :                         else if (isPacked)</span></a>
<a name="2153"><span class="lineNum">    2153 </span>            :                         {</a>
<a name="2154"><span class="lineNum">    2154 </span><span class="lineCov">         12 :                                 m_errorReporter.typeError(</span></a>
<a name="2155"><span class="lineNum">    2155 </span>            :                                         7279_error,</a>
<a name="2156"><span class="lineNum">    2156 </span><span class="lineCov">          6 :                                         arguments[i]-&gt;location(),</span></a>
<a name="2157"><span class="lineNum">    2157 </span>            :                                         &quot;Cannot perform packed encoding for a literal.&quot;</a>
<a name="2158"><span class="lineNum">    2158 </span>            :                                         &quot; Please convert it to an explicit type first.&quot;</a>
<a name="2159"><span class="lineNum">    2159 </span>            :                                 );</a>
<a name="2160"><span class="lineNum">    2160 </span><span class="lineCov">          6 :                                 continue;</span></a>
<a name="2161"><span class="lineNum">    2161 </span>            :                         }</a>
<a name="2162"><span class="lineNum">    2162 </span>            :                 }</a>
<a name="2163"><span class="lineNum">    2163 </span>            : </a>
<a name="2164"><span class="lineNum">    2164 </span><span class="lineCov">         44 :                 if (isPacked &amp;&amp; !typeSupportedByOldABIEncoder(*argType, false /* isLibrary */))</span></a>
<a name="2165"><span class="lineNum">    2165 </span>            :                 {</a>
<a name="2166"><span class="lineNum">    2166 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2167"><span class="lineNum">    2167 </span>            :                                 9578_error,</a>
<a name="2168"><span class="lineNum">    2168 </span><span class="lineNoCov">          0 :                                 arguments[i]-&gt;location(),</span></a>
<a name="2169"><span class="lineNum">    2169 </span>            :                                 &quot;Type not supported in packed mode.&quot;</a>
<a name="2170"><span class="lineNum">    2170 </span>            :                         );</a>
<a name="2171"><span class="lineNum">    2171 </span><span class="lineNoCov">          0 :                         continue;</span></a>
<a name="2172"><span class="lineNum">    2172 </span>            :                 }</a>
<a name="2173"><span class="lineNum">    2173 </span>            : </a>
<a name="2174"><span class="lineNum">    2174 </span><span class="lineCov">         44 :                 if (!argType-&gt;fullEncodingType(false, abiEncoderV2, !_functionType-&gt;padArguments()))</span></a>
<a name="2175"><span class="lineNum">    2175 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2176"><span class="lineNum">    2176 </span>            :                                 2056_error,</a>
<a name="2177"><span class="lineNum">    2177 </span><span class="lineNoCov">          0 :                                 arguments[i]-&gt;location(),</span></a>
<a name="2178"><span class="lineNum">    2178 </span>            :                                 &quot;This type cannot be encoded.&quot;</a>
<a name="2179"><span class="lineNum">    2179 </span>            :                         );</a>
<a name="2180"><span class="lineNum">    2180 </span>            :         }</a>
<a name="2181"><span class="lineNum">    2181 </span>            : }</a>
<a name="2182"><span class="lineNum">    2182 </span>            : </a>
<a name="2183"><span class="lineNum">    2183 </span><span class="lineNoCov">          0 : void TypeChecker::typeCheckABIEncodeCallFunction(FunctionCall const&amp; _functionCall)</span></a>
<a name="2184"><span class="lineNum">    2184 </span>            : {</a>
<a name="2185"><span class="lineNum">    2185 </span><span class="lineNoCov">          0 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; const&amp; arguments = _functionCall.arguments();</span></a>
<a name="2186"><span class="lineNum">    2186 </span>            : </a>
<a name="2187"><span class="lineNum">    2187 </span>            :         // Expecting first argument to be the function pointer and second to be a tuple.</a>
<a name="2188"><span class="lineNum">    2188 </span><span class="lineNoCov">          0 :         if (arguments.size() != 2)</span></a>
<a name="2189"><span class="lineNum">    2189 </span>            :         {</a>
<a name="2190"><span class="lineNum">    2190 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="2191"><span class="lineNum">    2191 </span>            :                         6219_error,</a>
<a name="2192"><span class="lineNum">    2192 </span><span class="lineNoCov">          0 :                         _functionCall.location(),</span></a>
<a name="2193"><span class="lineNum">    2193 </span>            :                         &quot;Expected two arguments: a function pointer followed by a tuple.&quot;</a>
<a name="2194"><span class="lineNum">    2194 </span>            :                 );</a>
<a name="2195"><span class="lineNum">    2195 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="2196"><span class="lineNum">    2196 </span>            :         }</a>
<a name="2197"><span class="lineNum">    2197 </span>            : </a>
<a name="2198"><span class="lineNum">    2198 </span><span class="lineNoCov">          0 :         FunctionType const* externalFunctionType = nullptr;</span></a>
<a name="2199"><span class="lineNum">    2199 </span><span class="lineNoCov">          0 :         if (auto const functionPointerType = dynamic_cast&lt;FunctionTypePointer&gt;(type(*arguments.front())))</span></a>
<a name="2200"><span class="lineNum">    2200 </span>            :         {</a>
<a name="2201"><span class="lineNum">    2201 </span>            :                 // this cannot be a library function, that is checked below</a>
<a name="2202"><span class="lineNum">    2202 </span><span class="lineNoCov">          0 :                 externalFunctionType = functionPointerType-&gt;asExternallyCallableFunction(false);</span></a>
<a name="2203"><span class="lineNum">    2203 </span><span class="lineNoCov">          0 :                 solAssert(externalFunctionType-&gt;kind() == functionPointerType-&gt;kind());</span></a>
<a name="2204"><span class="lineNum">    2204 </span>            :         }</a>
<a name="2205"><span class="lineNum">    2205 </span>            :         else</a>
<a name="2206"><span class="lineNum">    2206 </span>            :         {</a>
<a name="2207"><span class="lineNum">    2207 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="2208"><span class="lineNum">    2208 </span>            :                         5511_error,</a>
<a name="2209"><span class="lineNum">    2209 </span><span class="lineNoCov">          0 :                         arguments.front()-&gt;location(),</span></a>
<a name="2210"><span class="lineNum">    2210 </span><span class="lineNoCov">          0 :                         &quot;Expected first argument to be a function pointer, not \&quot;&quot; +</span></a>
<a name="2211"><span class="lineNum">    2211 </span><span class="lineNoCov">          0 :                         type(*arguments.front())-&gt;humanReadableName() +</span></a>
<a name="2212"><span class="lineNum">    2212 </span>            :                         &quot;\&quot;.&quot;</a>
<a name="2213"><span class="lineNum">    2213 </span>            :                 );</a>
<a name="2214"><span class="lineNum">    2214 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="2215"><span class="lineNum">    2215 </span>            :         }</a>
<a name="2216"><span class="lineNum">    2216 </span>            : </a>
<a name="2217"><span class="lineNum">    2217 </span><span class="lineNoCov">          0 :         if (</span></a>
<a name="2218"><span class="lineNum">    2218 </span><span class="lineNoCov">          0 :                 externalFunctionType-&gt;kind() != FunctionType::Kind::External &amp;&amp;</span></a>
<a name="2219"><span class="lineNum">    2219 </span><span class="lineNoCov">          0 :                 externalFunctionType-&gt;kind() != FunctionType::Kind::Declaration</span></a>
<a name="2220"><span class="lineNum">    2220 </span>            :         )</a>
<a name="2221"><span class="lineNum">    2221 </span>            :         {</a>
<a name="2222"><span class="lineNum">    2222 </span><span class="lineNoCov">          0 :                 std::string msg = &quot;Expected regular external function type, or external view on public function.&quot;;</span></a>
<a name="2223"><span class="lineNum">    2223 </span>            : </a>
<a name="2224"><span class="lineNum">    2224 </span><span class="lineNoCov">          0 :                 switch (externalFunctionType-&gt;kind())</span></a>
<a name="2225"><span class="lineNum">    2225 </span>            :                 {</a>
<a name="2226"><span class="lineNum">    2226 </span><span class="lineNoCov">          0 :                         case FunctionType::Kind::Internal:</span></a>
<a name="2227"><span class="lineNum">    2227 </span><span class="lineNoCov">          0 :                                 msg += &quot; Provided internal function.&quot;;</span></a>
<a name="2228"><span class="lineNum">    2228 </span><span class="lineNoCov">          0 :                                 break;</span></a>
<a name="2229"><span class="lineNum">    2229 </span><span class="lineNoCov">          0 :                         case FunctionType::Kind::DelegateCall:</span></a>
<a name="2230"><span class="lineNum">    2230 </span><span class="lineNoCov">          0 :                                 msg += &quot; Cannot use library functions for abi.encodeCall.&quot;;</span></a>
<a name="2231"><span class="lineNum">    2231 </span><span class="lineNoCov">          0 :                                 break;</span></a>
<a name="2232"><span class="lineNum">    2232 </span><span class="lineNoCov">          0 :                         case FunctionType::Kind::Creation:</span></a>
<a name="2233"><span class="lineNum">    2233 </span><span class="lineNoCov">          0 :                                 msg += &quot; Provided creation function.&quot;;</span></a>
<a name="2234"><span class="lineNum">    2234 </span><span class="lineNoCov">          0 :                                 break;</span></a>
<a name="2235"><span class="lineNum">    2235 </span><span class="lineNoCov">          0 :                         case FunctionType::Kind::Event:</span></a>
<a name="2236"><span class="lineNum">    2236 </span><span class="lineNoCov">          0 :                                 msg += &quot; Cannot use events for abi.encodeCall.&quot;;</span></a>
<a name="2237"><span class="lineNum">    2237 </span><span class="lineNoCov">          0 :                                 break;</span></a>
<a name="2238"><span class="lineNum">    2238 </span><span class="lineNoCov">          0 :                         case FunctionType::Kind::Error:</span></a>
<a name="2239"><span class="lineNum">    2239 </span><span class="lineNoCov">          0 :                                 msg += &quot; Cannot use errors for abi.encodeCall.&quot;;</span></a>
<a name="2240"><span class="lineNum">    2240 </span><span class="lineNoCov">          0 :                                 break;</span></a>
<a name="2241"><span class="lineNum">    2241 </span><span class="lineNoCov">          0 :                         default:</span></a>
<a name="2242"><span class="lineNum">    2242 </span><span class="lineNoCov">          0 :                                 msg += &quot; Cannot use special function.&quot;;</span></a>
<a name="2243"><span class="lineNum">    2243 </span>            :                 }</a>
<a name="2244"><span class="lineNum">    2244 </span>            : </a>
<a name="2245"><span class="lineNum">    2245 </span><span class="lineNoCov">          0 :                 SecondarySourceLocation ssl{};</span></a>
<a name="2246"><span class="lineNum">    2246 </span>            : </a>
<a name="2247"><span class="lineNum">    2247 </span><span class="lineNoCov">          0 :                 if (externalFunctionType-&gt;hasDeclaration())</span></a>
<a name="2248"><span class="lineNum">    2248 </span>            :                 {</a>
<a name="2249"><span class="lineNum">    2249 </span><span class="lineNoCov">          0 :                         ssl.append(&quot;Function is declared here:&quot;, externalFunctionType-&gt;declaration().location());</span></a>
<a name="2250"><span class="lineNum">    2250 </span><span class="lineNoCov">          0 :                         if (</span></a>
<a name="2251"><span class="lineNum">    2251 </span><span class="lineNoCov">          0 :                                 externalFunctionType-&gt;declaration().visibility() == Visibility::Public &amp;&amp;</span></a>
<a name="2252"><span class="lineNum">    2252 </span><span class="lineNoCov">          0 :                                 externalFunctionType-&gt;declaration().scope() == m_currentContract</span></a>
<a name="2253"><span class="lineNum">    2253 </span>            :                         )</a>
<a name="2254"><span class="lineNum">    2254 </span><span class="lineNoCov">          0 :                                 msg += &quot; Did you forget to prefix \&quot;this.\&quot;?&quot;;</span></a>
<a name="2255"><span class="lineNum">    2255 </span><span class="lineNoCov">          0 :                         else if (</span></a>
<a name="2256"><span class="lineNum">    2256 </span><span class="lineNoCov">          0 :                                 m_currentContract &amp;&amp;</span></a>
<a name="2257"><span class="lineNum">    2257 </span><span class="lineNoCov">          0 :                                 externalFunctionType-&gt;declaration().scope() != m_currentContract &amp;&amp;</span></a>
<a name="2258"><span class="lineNum">    2258 </span><span class="lineNoCov">          0 :                                 util::contains(</span></a>
<a name="2259"><span class="lineNum">    2259 </span><span class="lineNoCov">          0 :                                         m_currentContract-&gt;annotation().linearizedBaseContracts,</span></a>
<a name="2260"><span class="lineNum">    2260 </span><span class="lineNoCov">          0 :                                         externalFunctionType-&gt;declaration().scope()</span></a>
<a name="2261"><span class="lineNum">    2261 </span>            :                                 )</a>
<a name="2262"><span class="lineNum">    2262 </span>            :                         )</a>
<a name="2263"><span class="lineNum">    2263 </span><span class="lineNoCov">          0 :                                 msg += &quot; Functions from base contracts have to be external.&quot;;</span></a>
<a name="2264"><span class="lineNum">    2264 </span>            :                 }</a>
<a name="2265"><span class="lineNum">    2265 </span>            : </a>
<a name="2266"><span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(3509_error, arguments[0]-&gt;location(), ssl, msg);</span></a>
<a name="2267"><span class="lineNum">    2267 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="2268"><span class="lineNum">    2268 </span>            :         }</a>
<a name="2269"><span class="lineNum">    2269 </span><span class="lineNoCov">          0 :         solAssert(!externalFunctionType-&gt;takesArbitraryParameters(), &quot;Function must have fixed parameters.&quot;);</span></a>
<a name="2270"><span class="lineNum">    2270 </span>            :         // Tuples with only one component become that component</a>
<a name="2271"><span class="lineNum">    2271 </span><span class="lineNoCov">          0 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; callArguments;</span></a>
<a name="2272"><span class="lineNum">    2272 </span>            : </a>
<a name="2273"><span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         auto const* tupleType = dynamic_cast&lt;TupleType const*&gt;(type(*arguments[1]));</span></a>
<a name="2274"><span class="lineNum">    2274 </span><span class="lineNoCov">          0 :         if (tupleType)</span></a>
<a name="2275"><span class="lineNum">    2275 </span>            :         {</a>
<a name="2276"><span class="lineNum">    2276 </span><span class="lineNoCov">          0 :                 if (TupleExpression const* argumentTuple = dynamic_cast&lt;TupleExpression const*&gt;(arguments[1].get()))</span></a>
<a name="2277"><span class="lineNum">    2277 </span><span class="lineNoCov">          0 :                         callArguments = decltype(callArguments){argumentTuple-&gt;components().begin(), argumentTuple-&gt;components().end()};</span></a>
<a name="2278"><span class="lineNum">    2278 </span>            :                 else</a>
<a name="2279"><span class="lineNum">    2279 </span>            :                 {</a>
<a name="2280"><span class="lineNum">    2280 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2281"><span class="lineNum">    2281 </span>            :                                 9062_error,</a>
<a name="2282"><span class="lineNum">    2282 </span><span class="lineNoCov">          0 :                                 arguments[1]-&gt;location(),</span></a>
<a name="2283"><span class="lineNum">    2283 </span>            :                                 &quot;Expected an inline tuple, not an expression of a tuple type.&quot;</a>
<a name="2284"><span class="lineNum">    2284 </span>            :                         );</a>
<a name="2285"><span class="lineNum">    2285 </span><span class="lineNoCov">          0 :                         return;</span></a>
<a name="2286"><span class="lineNum">    2286 </span>            :                 }</a>
<a name="2287"><span class="lineNum">    2287 </span>            :         }</a>
<a name="2288"><span class="lineNum">    2288 </span>            :         else</a>
<a name="2289"><span class="lineNum">    2289 </span><span class="lineNoCov">          0 :                 callArguments.push_back(arguments[1]);</span></a>
<a name="2290"><span class="lineNum">    2290 </span>            : </a>
<a name="2291"><span class="lineNum">    2291 </span><span class="lineNoCov">          0 :         if (externalFunctionType-&gt;parameterTypes().size() != callArguments.size())</span></a>
<a name="2292"><span class="lineNum">    2292 </span>            :         {</a>
<a name="2293"><span class="lineNum">    2293 </span><span class="lineNoCov">          0 :                 if (tupleType)</span></a>
<a name="2294"><span class="lineNum">    2294 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2295"><span class="lineNum">    2295 </span>            :                                 7788_error,</a>
<a name="2296"><span class="lineNum">    2296 </span><span class="lineNoCov">          0 :                                 _functionCall.location(),</span></a>
<a name="2297"><span class="lineNum">    2297 </span><span class="lineNoCov">          0 :                                 &quot;Expected &quot; +</span></a>
<a name="2298"><span class="lineNum">    2298 </span><span class="lineNoCov">          0 :                                 std::to_string(externalFunctionType-&gt;parameterTypes().size()) +</span></a>
<a name="2299"><span class="lineNum">    2299 </span><span class="lineNoCov">          0 :                                 &quot; instead of &quot; +</span></a>
<a name="2300"><span class="lineNum">    2300 </span><span class="lineNoCov">          0 :                                 std::to_string(callArguments.size()) +</span></a>
<a name="2301"><span class="lineNum">    2301 </span>            :                                 &quot; components for the tuple parameter.&quot;</a>
<a name="2302"><span class="lineNum">    2302 </span>            :                         );</a>
<a name="2303"><span class="lineNum">    2303 </span>            :                 else</a>
<a name="2304"><span class="lineNum">    2304 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2305"><span class="lineNum">    2305 </span>            :                                 7515_error,</a>
<a name="2306"><span class="lineNum">    2306 </span><span class="lineNoCov">          0 :                                 _functionCall.location(),</span></a>
<a name="2307"><span class="lineNum">    2307 </span><span class="lineNoCov">          0 :                                 &quot;Expected a tuple with &quot; +</span></a>
<a name="2308"><span class="lineNum">    2308 </span><span class="lineNoCov">          0 :                                 std::to_string(externalFunctionType-&gt;parameterTypes().size()) +</span></a>
<a name="2309"><span class="lineNum">    2309 </span>            :                                 &quot; components instead of a single non-tuple parameter.&quot;</a>
<a name="2310"><span class="lineNum">    2310 </span>            :                         );</a>
<a name="2311"><span class="lineNum">    2311 </span>            :         }</a>
<a name="2312"><span class="lineNum">    2312 </span>            : </a>
<a name="2313"><span class="lineNum">    2313 </span>            :         // Use min() to check as much as we can before failing fatally</a>
<a name="2314"><span class="lineNum">    2314 </span><span class="lineNoCov">          0 :         size_t const numParameters = std::min(callArguments.size(), externalFunctionType-&gt;parameterTypes().size());</span></a>
<a name="2315"><span class="lineNum">    2315 </span>            : </a>
<a name="2316"><span class="lineNum">    2316 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; numParameters; i++)</span></a>
<a name="2317"><span class="lineNum">    2317 </span>            :         {</a>
<a name="2318"><span class="lineNum">    2318 </span><span class="lineNoCov">          0 :                 Type const&amp; argType = *type(*callArguments[i]);</span></a>
<a name="2319"><span class="lineNum">    2319 </span><span class="lineNoCov">          0 :                 BoolResult result = argType.isImplicitlyConvertibleTo(*externalFunctionType-&gt;parameterTypes()[i]);</span></a>
<a name="2320"><span class="lineNum">    2320 </span><span class="lineNoCov">          0 :                 if (!result)</span></a>
<a name="2321"><span class="lineNum">    2321 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2322"><span class="lineNum">    2322 </span>            :                                 5407_error,</a>
<a name="2323"><span class="lineNum">    2323 </span><span class="lineNoCov">          0 :                                 callArguments[i]-&gt;location(),</span></a>
<a name="2324"><span class="lineNum">    2324 </span><span class="lineNoCov">          0 :                                 &quot;Cannot implicitly convert component at position &quot; +</span></a>
<a name="2325"><span class="lineNum">    2325 </span><span class="lineNoCov">          0 :                                 std::to_string(i) +</span></a>
<a name="2326"><span class="lineNum">    2326 </span><span class="lineNoCov">          0 :                                 &quot; from \&quot;&quot; +</span></a>
<a name="2327"><span class="lineNum">    2327 </span><span class="lineNoCov">          0 :                                 argType.humanReadableName() +</span></a>
<a name="2328"><span class="lineNum">    2328 </span><span class="lineNoCov">          0 :                                 &quot;\&quot; to \&quot;&quot; +</span></a>
<a name="2329"><span class="lineNum">    2329 </span><span class="lineNoCov">          0 :                                 externalFunctionType-&gt;parameterTypes()[i]-&gt;humanReadableName() +</span></a>
<a name="2330"><span class="lineNum">    2330 </span><span class="lineNoCov">          0 :                                 &quot;\&quot;&quot; +</span></a>
<a name="2331"><span class="lineNum">    2331 </span><span class="lineNoCov">          0 :                                 (result.message().empty() ?  &quot;.&quot; : &quot;: &quot; + result.message())</span></a>
<a name="2332"><span class="lineNum">    2332 </span>            :                         );</a>
<a name="2333"><span class="lineNum">    2333 </span>            :         }</a>
<a name="2334"><span class="lineNum">    2334 </span>            : }</a>
<a name="2335"><span class="lineNum">    2335 </span>            : </a>
<a name="2336"><span class="lineNum">    2336 </span>            : </a>
<a name="2337"><span class="lineNum">    2337 </span><span class="lineNoCov">          0 : void TypeChecker::typeCheckStringConcatFunction(</span></a>
<a name="2338"><span class="lineNum">    2338 </span>            :         FunctionCall const&amp; _functionCall,</a>
<a name="2339"><span class="lineNum">    2339 </span>            :         FunctionType const* _functionType</a>
<a name="2340"><span class="lineNum">    2340 </span>            : )</a>
<a name="2341"><span class="lineNum">    2341 </span>            : {</a>
<a name="2342"><span class="lineNum">    2342 </span><span class="lineNoCov">          0 :         solAssert(_functionType);</span></a>
<a name="2343"><span class="lineNum">    2343 </span><span class="lineNoCov">          0 :         solAssert(_functionType-&gt;kind() == FunctionType::Kind::StringConcat);</span></a>
<a name="2344"><span class="lineNum">    2344 </span><span class="lineNoCov">          0 :         solAssert(_functionCall.names().empty());</span></a>
<a name="2345"><span class="lineNum">    2345 </span>            : </a>
<a name="2346"><span class="lineNum">    2346 </span><span class="lineNoCov">          0 :         typeCheckFunctionGeneralChecks(_functionCall, _functionType);</span></a>
<a name="2347"><span class="lineNum">    2347 </span>            : </a>
<a name="2348"><span class="lineNum">    2348 </span><span class="lineNoCov">          0 :         for (std::shared_ptr&lt;Expression const&gt; const&amp; argument: _functionCall.arguments())</span></a>
<a name="2349"><span class="lineNum">    2349 </span>            :         {</a>
<a name="2350"><span class="lineNum">    2350 </span><span class="lineNoCov">          0 :                 Type const* argumentType = type(*argument);</span></a>
<a name="2351"><span class="lineNum">    2351 </span><span class="lineNoCov">          0 :                 bool notConvertibleToString = !argumentType-&gt;isImplicitlyConvertibleTo(*TypeProvider::stringMemory());</span></a>
<a name="2352"><span class="lineNum">    2352 </span>            : </a>
<a name="2353"><span class="lineNum">    2353 </span><span class="lineNoCov">          0 :                 if (notConvertibleToString)</span></a>
<a name="2354"><span class="lineNum">    2354 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2355"><span class="lineNum">    2355 </span>            :                                 9977_error,</a>
<a name="2356"><span class="lineNum">    2356 </span><span class="lineNoCov">          0 :                                 argument-&gt;location(),</span></a>
<a name="2357"><span class="lineNum">    2357 </span>            :                                 &quot;Invalid type for argument in the string.concat function call. &quot;</a>
<a name="2358"><span class="lineNum">    2358 </span><span class="lineNoCov">          0 :                                 &quot;string type is required, but &quot; +</span></a>
<a name="2359"><span class="lineNum">    2359 </span><span class="lineNoCov">          0 :                                 argumentType-&gt;identifier() + &quot; provided.&quot;</span></a>
<a name="2360"><span class="lineNum">    2360 </span>            :                         );</a>
<a name="2361"><span class="lineNum">    2361 </span>            :         }</a>
<a name="2362"><span class="lineNum">    2362 </span><span class="lineNoCov">          0 : }</span></a>
<a name="2363"><span class="lineNum">    2363 </span>            : </a>
<a name="2364"><span class="lineNum">    2364 </span><span class="lineCov">          1 : void TypeChecker::typeCheckBytesConcatFunction(</span></a>
<a name="2365"><span class="lineNum">    2365 </span>            :         FunctionCall const&amp; _functionCall,</a>
<a name="2366"><span class="lineNum">    2366 </span>            :         FunctionType const* _functionType</a>
<a name="2367"><span class="lineNum">    2367 </span>            : )</a>
<a name="2368"><span class="lineNum">    2368 </span>            : {</a>
<a name="2369"><span class="lineNum">    2369 </span><span class="lineCov">          1 :         solAssert(_functionType);</span></a>
<a name="2370"><span class="lineNum">    2370 </span><span class="lineCov">          1 :         solAssert(_functionType-&gt;kind() == FunctionType::Kind::BytesConcat);</span></a>
<a name="2371"><span class="lineNum">    2371 </span><span class="lineCov">          1 :         solAssert(_functionCall.names().empty());</span></a>
<a name="2372"><span class="lineNum">    2372 </span>            : </a>
<a name="2373"><span class="lineNum">    2373 </span><span class="lineCov">          1 :         typeCheckFunctionGeneralChecks(_functionCall, _functionType);</span></a>
<a name="2374"><span class="lineNum">    2374 </span>            : </a>
<a name="2375"><span class="lineNum">    2375 </span><span class="lineCov">          2 :         for (std::shared_ptr&lt;Expression const&gt; const&amp; argument: _functionCall.arguments())</span></a>
<a name="2376"><span class="lineNum">    2376 </span>            :         {</a>
<a name="2377"><span class="lineNum">    2377 </span><span class="lineCov">          1 :                 Type const* argumentType = type(*argument);</span></a>
<a name="2378"><span class="lineNum">    2378 </span>            :                 bool notConvertibleToBytes =</a>
<a name="2379"><span class="lineNum">    2379 </span><span class="lineCov">          3 :                         !argumentType-&gt;isImplicitlyConvertibleTo(*TypeProvider::fixedBytes(32)) &amp;&amp;</span></a>
<a name="2380"><span class="lineNum">    2380 </span><span class="lineCov">          2 :                         !argumentType-&gt;isImplicitlyConvertibleTo(*TypeProvider::bytesMemory());</span></a>
<a name="2381"><span class="lineNum">    2381 </span><span class="lineCov">          1 :                 bool numberLiteral = (dynamic_cast&lt;RationalNumberType const*&gt;(argumentType) != nullptr);</span></a>
<a name="2382"><span class="lineNum">    2382 </span>            : </a>
<a name="2383"><span class="lineNum">    2383 </span><span class="lineCov">          1 :                 if (notConvertibleToBytes || numberLiteral)</span></a>
<a name="2384"><span class="lineNum">    2384 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2385"><span class="lineNum">    2385 </span>            :                                 8015_error,</a>
<a name="2386"><span class="lineNum">    2386 </span><span class="lineNoCov">          0 :                                 argument-&gt;location(),</span></a>
<a name="2387"><span class="lineNum">    2387 </span>            :                                 &quot;Invalid type for argument in the bytes.concat function call. &quot;</a>
<a name="2388"><span class="lineNum">    2388 </span><span class="lineNoCov">          0 :                                 &quot;bytes or fixed bytes type is required, but &quot; +</span></a>
<a name="2389"><span class="lineNum">    2389 </span><span class="lineNoCov">          0 :                                 argumentType-&gt;humanReadableName() + &quot; provided.&quot;</span></a>
<a name="2390"><span class="lineNum">    2390 </span>            :                         );</a>
<a name="2391"><span class="lineNum">    2391 </span>            :         }</a>
<a name="2392"><span class="lineNum">    2392 </span><span class="lineCov">          1 : }</span></a>
<a name="2393"><span class="lineNum">    2393 </span>            : </a>
<a name="2394"><span class="lineNum">    2394 </span><span class="lineCov">       2444 : void TypeChecker::typeCheckFunctionGeneralChecks(</span></a>
<a name="2395"><span class="lineNum">    2395 </span>            :         FunctionCall const&amp; _functionCall,</a>
<a name="2396"><span class="lineNum">    2396 </span>            :         FunctionTypePointer _functionType</a>
<a name="2397"><span class="lineNum">    2397 </span>            : )</a>
<a name="2398"><span class="lineNum">    2398 </span>            : {</a>
<a name="2399"><span class="lineNum">    2399 </span>            :         // Actual function call or struct constructor call.</a>
<a name="2400"><span class="lineNum">    2400 </span>            : </a>
<a name="2401"><span class="lineNum">    2401 </span><span class="lineCov">       2444 :         solAssert(!!_functionType, &quot;&quot;);</span></a>
<a name="2402"><span class="lineNum">    2402 </span><span class="lineCov">       2444 :         solAssert(_functionType-&gt;kind() != FunctionType::Kind::ABIDecode, &quot;&quot;);</span></a>
<a name="2403"><span class="lineNum">    2403 </span>            : </a>
<a name="2404"><span class="lineNum">    2404 </span><span class="lineCov">       2444 :         bool const isPositionalCall = _functionCall.names().empty();</span></a>
<a name="2405"><span class="lineNum">    2405 </span><span class="lineCov">       2444 :         bool const isVariadic = _functionType-&gt;takesArbitraryParameters();</span></a>
<a name="2406"><span class="lineNum">    2406 </span>            : </a>
<a name="2407"><span class="lineNum">    2407 </span><span class="lineCov">       2444 :         auto functionCallKind = *_functionCall.annotation().kind;</span></a>
<a name="2408"><span class="lineNum">    2408 </span>            : </a>
<a name="2409"><span class="lineNum">    2409 </span><span class="lineCov">       2444 :         solAssert(</span></a>
<a name="2410"><span class="lineNum">    2410 </span>            :                 !isVariadic || functionCallKind == FunctionCallKind::FunctionCall,</a>
<a name="2411"><span class="lineNum">    2411 </span>            :                 &quot;Struct constructor calls cannot be variadic.&quot;</a>
<a name="2412"><span class="lineNum">    2412 </span>            :         );</a>
<a name="2413"><span class="lineNum">    2413 </span>            : </a>
<a name="2414"><span class="lineNum">    2414 </span><span class="lineCov">       2444 :         TypePointers const&amp; parameterTypes = _functionType-&gt;parameterTypes();</span></a>
<a name="2415"><span class="lineNum">    2415 </span><span class="lineCov">       2444 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; const&amp; arguments = _functionCall.arguments();</span></a>
<a name="2416"><span class="lineNum">    2416 </span><span class="lineCov">       2444 :         std::vector&lt;ASTPointer&lt;ASTString&gt;&gt; const&amp; argumentNames = _functionCall.names();</span></a>
<a name="2417"><span class="lineNum">    2417 </span>            : </a>
<a name="2418"><span class="lineNum">    2418 </span>            :         // Check number of passed in arguments</a>
<a name="2419"><span class="lineNum">    2419 </span><span class="lineCov">       2444 :         if (</span></a>
<a name="2420"><span class="lineNum">    2420 </span><span class="lineCov">       4849 :                 arguments.size() &lt; parameterTypes.size() ||</span></a>
<a name="2421"><span class="lineNum">    2421 </span><span class="lineCov">       2405 :                 (!isVariadic &amp;&amp; arguments.size() &gt; parameterTypes.size())</span></a>
<a name="2422"><span class="lineNum">    2422 </span>            :         )</a>
<a name="2423"><span class="lineNum">    2423 </span>            :         {</a>
<a name="2424"><span class="lineNum">    2424 </span><span class="lineCov">         68 :                 bool const isStructConstructorCall =</span></a>
<a name="2425"><span class="lineNum">    2425 </span><span class="lineCov">         68 :                         functionCallKind == FunctionCallKind::StructConstructorCall;</span></a>
<a name="2426"><span class="lineNum">    2426 </span>            : </a>
<a name="2427"><span class="lineNum">    2427 </span><span class="lineCov">         68 :                 auto [errorId, description] = [&amp;]() -&gt; std::tuple&lt;ErrorId, std::string&gt; {</span></a>
<a name="2428"><span class="lineNum">    2428 </span><span class="lineCov">        204 :                         std::string msg = isVariadic ?</span></a>
<a name="2429"><span class="lineNum">    2429 </span><span class="lineNoCov">          0 :                                 &quot;Need at least &quot; +</span></a>
<a name="2430"><span class="lineNum">    2430 </span><span class="lineCov">         68 :                                 toString(parameterTypes.size()) +</span></a>
<a name="2431"><span class="lineNum">    2431 </span><span class="lineCov">         68 :                                 &quot; arguments for &quot; +</span></a>
<a name="2432"><span class="lineNum">    2432 </span><span class="lineCov">        136 :                                 std::string(isStructConstructorCall ? &quot;struct constructor&quot; : &quot;function call&quot;) +</span></a>
<a name="2433"><span class="lineNum">    2433 </span><span class="lineCov">         68 :                                 &quot;, but provided only &quot; +</span></a>
<a name="2434"><span class="lineNum">    2434 </span><span class="lineCov">         68 :                                 toString(arguments.size()) +</span></a>
<a name="2435"><span class="lineNum">    2435 </span>            :                                 &quot;.&quot;</a>
<a name="2436"><span class="lineNum">    2436 </span>            :                                 :</a>
<a name="2437"><span class="lineNum">    2437 </span><span class="lineCov">         68 :                                 &quot;Wrong argument count for &quot; +</span></a>
<a name="2438"><span class="lineNum">    2438 </span><span class="lineCov">        340 :                                 std::string(isStructConstructorCall ? &quot;struct constructor&quot; : &quot;function call&quot;) +</span></a>
<a name="2439"><span class="lineNum">    2439 </span><span class="lineCov">        204 :                                 &quot;: &quot; +</span></a>
<a name="2440"><span class="lineNum">    2440 </span><span class="lineCov">        340 :                                 toString(arguments.size()) +</span></a>
<a name="2441"><span class="lineNum">    2441 </span><span class="lineCov">        204 :                                 &quot; arguments given but &quot; +</span></a>
<a name="2442"><span class="lineNum">    2442 </span><span class="lineCov">        408 :                                 std::string(isVariadic ? &quot;need at least &quot; : &quot;expected &quot;) +</span></a>
<a name="2443"><span class="lineNum">    2443 </span><span class="lineCov">        204 :                                 toString(parameterTypes.size()) +</span></a>
<a name="2444"><span class="lineNum">    2444 </span><span class="lineCov">        204 :                                 &quot;.&quot;;</span></a>
<a name="2445"><span class="lineNum">    2445 </span>            : </a>
<a name="2446"><span class="lineNum">    2446 </span><span class="lineCov">         68 :                         if (isStructConstructorCall)</span></a>
<a name="2447"><span class="lineNum">    2447 </span>            :                         {</a>
<a name="2448"><span class="lineNum">    2448 </span><span class="lineCov">          9 :                                 solAssert(!isVariadic, &quot;&quot;);</span></a>
<a name="2449"><span class="lineNum">    2449 </span><span class="lineCov">         18 :                                 return { 9755_error, msg };</span></a>
<a name="2450"><span class="lineNum">    2450 </span>            :                         }</a>
<a name="2451"><span class="lineNum">    2451 </span><span class="lineCov">         59 :                         else if (</span></a>
<a name="2452"><span class="lineNum">    2452 </span><span class="lineCov">         59 :                                 _functionType-&gt;kind() == FunctionType::Kind::BareCall ||</span></a>
<a name="2453"><span class="lineNum">    2453 </span><span class="lineCov">         58 :                                 _functionType-&gt;kind() == FunctionType::Kind::BareCallCode ||</span></a>
<a name="2454"><span class="lineNum">    2454 </span><span class="lineCov">        175 :                                 _functionType-&gt;kind() == FunctionType::Kind::BareDelegateCall ||</span></a>
<a name="2455"><span class="lineNum">    2455 </span><span class="lineCov">         58 :                                 _functionType-&gt;kind() == FunctionType::Kind::BareStaticCall</span></a>
<a name="2456"><span class="lineNum">    2456 </span>            :                         )</a>
<a name="2457"><span class="lineNum">    2457 </span>            :                         {</a>
<a name="2458"><span class="lineNum">    2458 </span><span class="lineCov">          1 :                                 solAssert(!isVariadic, &quot;&quot;);</span></a>
<a name="2459"><span class="lineNum">    2459 </span><span class="lineCov">          1 :                                 if (arguments.empty())</span></a>
<a name="2460"><span class="lineNum">    2460 </span>            :                                         return {</a>
<a name="2461"><span class="lineNum">    2461 </span><span class="lineCov">          1 :                                                 6138_error,</span></a>
<a name="2462"><span class="lineNum">    2462 </span><span class="lineCov">          2 :                                                 msg +</span></a>
<a name="2463"><span class="lineNum">    2463 </span>            :                                                 &quot; This function requires a single bytes argument.&quot;</a>
<a name="2464"><span class="lineNum">    2464 </span>            :                                                 &quot; Use \&quot;\&quot; as argument to provide empty calldata.&quot;</a>
<a name="2465"><span class="lineNum">    2465 </span><span class="lineCov">          1 :                                         };</span></a>
<a name="2466"><span class="lineNum">    2466 </span>            :                                 else</a>
<a name="2467"><span class="lineNum">    2467 </span>            :                                         return {</a>
<a name="2468"><span class="lineNum">    2468 </span><span class="lineNoCov">          0 :                                                 8922_error,</span></a>
<a name="2469"><span class="lineNum">    2469 </span><span class="lineNoCov">          0 :                                                 msg +</span></a>
<a name="2470"><span class="lineNum">    2470 </span>            :                                                 &quot; This function requires a single bytes argument.&quot;</a>
<a name="2471"><span class="lineNum">    2471 </span>            :                                                 &quot; If all your arguments are value types, you can use&quot;</a>
<a name="2472"><span class="lineNum">    2472 </span>            :                                                 &quot; abi.encode(...) to properly generate it.&quot;</a>
<a name="2473"><span class="lineNum">    2473 </span><span class="lineNoCov">          0 :                                         };</span></a>
<a name="2474"><span class="lineNum">    2474 </span>            :                         }</a>
<a name="2475"><span class="lineNum">    2475 </span><span class="lineCov">         58 :                         else if (</span></a>
<a name="2476"><span class="lineNum">    2476 </span><span class="lineCov">         58 :                                 _functionType-&gt;kind() == FunctionType::Kind::KECCAK256 ||</span></a>
<a name="2477"><span class="lineNum">    2477 </span><span class="lineCov">        115 :                                 _functionType-&gt;kind() == FunctionType::Kind::SHA256 ||</span></a>
<a name="2478"><span class="lineNum">    2478 </span><span class="lineCov">         57 :                                 _functionType-&gt;kind() == FunctionType::Kind::RIPEMD160</span></a>
<a name="2479"><span class="lineNum">    2479 </span>            :                         )</a>
<a name="2480"><span class="lineNum">    2480 </span>            :                         {</a>
<a name="2481"><span class="lineNum">    2481 </span><span class="lineCov">          1 :                                 solAssert(!isVariadic, &quot;&quot;);</span></a>
<a name="2482"><span class="lineNum">    2482 </span>            :                                 return {</a>
<a name="2483"><span class="lineNum">    2483 </span><span class="lineCov">          1 :                                         4323_error,</span></a>
<a name="2484"><span class="lineNum">    2484 </span><span class="lineCov">          2 :                                         msg +</span></a>
<a name="2485"><span class="lineNum">    2485 </span>            :                                         &quot; This function requires a single bytes argument.&quot;</a>
<a name="2486"><span class="lineNum">    2486 </span>            :                                         &quot; Use abi.encodePacked(...) to obtain the pre-0.5.0&quot;</a>
<a name="2487"><span class="lineNum">    2487 </span>            :                                         &quot; behaviour or abi.encode(...) to use ABI encoding.&quot;</a>
<a name="2488"><span class="lineNum">    2488 </span><span class="lineCov">          1 :                                 };</span></a>
<a name="2489"><span class="lineNum">    2489 </span>            :                         }</a>
<a name="2490"><span class="lineNum">    2490 </span>            :                         else</a>
<a name="2491"><span class="lineNum">    2491 </span><span class="lineCov">        114 :                                 return { isVariadic ? 9308_error : 6160_error, msg };</span></a>
<a name="2492"><span class="lineNum">    2492 </span><span class="lineCov">         68 :                 }();</span></a>
<a name="2493"><span class="lineNum">    2493 </span>            : </a>
<a name="2494"><span class="lineNum">    2494 </span><span class="lineCov">         68 :                 m_errorReporter.typeError(errorId, _functionCall.location(), description);</span></a>
<a name="2495"><span class="lineNum">    2495 </span><span class="lineCov">         68 :                 return;</span></a>
<a name="2496"><span class="lineNum">    2496 </span>            :         }</a>
<a name="2497"><span class="lineNum">    2497 </span>            : </a>
<a name="2498"><span class="lineNum">    2498 </span>            :         // Parameter to argument map</a>
<a name="2499"><span class="lineNum">    2499 </span><span class="lineCov">       2376 :         std::vector&lt;Expression const*&gt; paramArgMap(parameterTypes.size());</span></a>
<a name="2500"><span class="lineNum">    2500 </span>            : </a>
<a name="2501"><span class="lineNum">    2501 </span>            :         // Map parameters to arguments - trivially for positional calls, less so for named calls</a>
<a name="2502"><span class="lineNum">    2502 </span><span class="lineCov">       2376 :         if (isPositionalCall)</span></a>
<a name="2503"><span class="lineNum">    2503 </span><span class="lineCov">       4792 :                 for (size_t i = 0; i &lt; paramArgMap.size(); ++i)</span></a>
<a name="2504"><span class="lineNum">    2504 </span><span class="lineCov">       2421 :                         paramArgMap[i] = arguments[i].get();</span></a>
<a name="2505"><span class="lineNum">    2505 </span>            :         else</a>
<a name="2506"><span class="lineNum">    2506 </span>            :         {</a>
<a name="2507"><span class="lineNum">    2507 </span><span class="lineCov">          5 :                 auto const&amp; parameterNames = _functionType-&gt;parameterNames();</span></a>
<a name="2508"><span class="lineNum">    2508 </span>            : </a>
<a name="2509"><span class="lineNum">    2509 </span><span class="lineCov">          5 :                 solAssert(</span></a>
<a name="2510"><span class="lineNum">    2510 </span>            :                         parameterNames.size() == argumentNames.size(),</a>
<a name="2511"><span class="lineNum">    2511 </span>            :                         &quot;Unexpected parameter length mismatch!&quot;</a>
<a name="2512"><span class="lineNum">    2512 </span>            :                 );</a>
<a name="2513"><span class="lineNum">    2513 </span>            : </a>
<a name="2514"><span class="lineNum">    2514 </span>            :                 // Check for duplicate argument names</a>
<a name="2515"><span class="lineNum">    2515 </span>            :                 {</a>
<a name="2516"><span class="lineNum">    2516 </span><span class="lineCov">          5 :                         bool duplication = false;</span></a>
<a name="2517"><span class="lineNum">    2517 </span><span class="lineCov">         18 :                         for (size_t i = 0; i &lt; argumentNames.size(); i++)</span></a>
<a name="2518"><span class="lineNum">    2518 </span><span class="lineCov">         25 :                                 for (size_t j = i + 1; j &lt; argumentNames.size(); j++)</span></a>
<a name="2519"><span class="lineNum">    2519 </span><span class="lineCov">         12 :                                         if (*argumentNames[i] == *argumentNames[j])</span></a>
<a name="2520"><span class="lineNum">    2520 </span>            :                                         {</a>
<a name="2521"><span class="lineNum">    2521 </span><span class="lineNoCov">          0 :                                                 duplication = true;</span></a>
<a name="2522"><span class="lineNum">    2522 </span><span class="lineNoCov">          0 :                                                 m_errorReporter.typeError(</span></a>
<a name="2523"><span class="lineNum">    2523 </span>            :                                                         6995_error,</a>
<a name="2524"><span class="lineNum">    2524 </span><span class="lineNoCov">          0 :                                                         arguments[i]-&gt;location(),</span></a>
<a name="2525"><span class="lineNum">    2525 </span><span class="lineNoCov">          0 :                                                         &quot;Duplicate named argument \&quot;&quot; + *argumentNames[i] + &quot;\&quot;.&quot;</span></a>
<a name="2526"><span class="lineNum">    2526 </span>            :                                                 );</a>
<a name="2527"><span class="lineNum">    2527 </span>            :                                         }</a>
<a name="2528"><span class="lineNum">    2528 </span><span class="lineCov">          5 :                         if (duplication)</span></a>
<a name="2529"><span class="lineNum">    2529 </span><span class="lineNoCov">          0 :                                 return;</span></a>
<a name="2530"><span class="lineNum">    2530 </span>            :                 }</a>
<a name="2531"><span class="lineNum">    2531 </span>            : </a>
<a name="2532"><span class="lineNum">    2532 </span>            :                 // map parameter names to argument names</a>
<a name="2533"><span class="lineNum">    2533 </span>            :                 {</a>
<a name="2534"><span class="lineNum">    2534 </span><span class="lineCov">          5 :                         bool not_all_mapped = false;</span></a>
<a name="2535"><span class="lineNum">    2535 </span>            : </a>
<a name="2536"><span class="lineNum">    2536 </span><span class="lineCov">         18 :                         for (size_t i = 0; i &lt; argumentNames.size(); i++)</span></a>
<a name="2537"><span class="lineNum">    2537 </span>            :                         {</a>
<a name="2538"><span class="lineNum">    2538 </span>            :                                 size_t j;</a>
<a name="2539"><span class="lineNum">    2539 </span><span class="lineCov">         25 :                                 for (j = 0; j &lt; parameterNames.size(); j++)</span></a>
<a name="2540"><span class="lineNum">    2540 </span><span class="lineCov">         25 :                                         if (parameterNames[j] == *argumentNames[i])</span></a>
<a name="2541"><span class="lineNum">    2541 </span><span class="lineCov">         13 :                                                 break;</span></a>
<a name="2542"><span class="lineNum">    2542 </span>            : </a>
<a name="2543"><span class="lineNum">    2543 </span><span class="lineCov">         13 :                                 if (j &lt; parameterNames.size())</span></a>
<a name="2544"><span class="lineNum">    2544 </span><span class="lineCov">         13 :                                         paramArgMap[j] = arguments[i].get();</span></a>
<a name="2545"><span class="lineNum">    2545 </span>            :                                 else</a>
<a name="2546"><span class="lineNum">    2546 </span>            :                                 {</a>
<a name="2547"><span class="lineNum">    2547 </span><span class="lineNoCov">          0 :                                         not_all_mapped = true;</span></a>
<a name="2548"><span class="lineNum">    2548 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="2549"><span class="lineNum">    2549 </span>            :                                                 4974_error,</a>
<a name="2550"><span class="lineNum">    2550 </span><span class="lineNoCov">          0 :                                                 _functionCall.location(),</span></a>
<a name="2551"><span class="lineNum">    2551 </span><span class="lineNoCov">          0 :                                                 &quot;Named argument \&quot;&quot; +</span></a>
<a name="2552"><span class="lineNum">    2552 </span><span class="lineNoCov">          0 :                                                 *argumentNames[i] +</span></a>
<a name="2553"><span class="lineNum">    2553 </span>            :                                                 &quot;\&quot; does not match function declaration.&quot;</a>
<a name="2554"><span class="lineNum">    2554 </span>            :                                         );</a>
<a name="2555"><span class="lineNum">    2555 </span>            :                                 }</a>
<a name="2556"><span class="lineNum">    2556 </span>            :                         }</a>
<a name="2557"><span class="lineNum">    2557 </span>            : </a>
<a name="2558"><span class="lineNum">    2558 </span><span class="lineCov">          5 :                         if (not_all_mapped)</span></a>
<a name="2559"><span class="lineNum">    2559 </span><span class="lineNoCov">          0 :                                 return;</span></a>
<a name="2560"><span class="lineNum">    2560 </span>            :                 }</a>
<a name="2561"><span class="lineNum">    2561 </span>            :         }</a>
<a name="2562"><span class="lineNum">    2562 </span>            : </a>
<a name="2563"><span class="lineNum">    2563 </span>            :         // Check for compatible types between arguments and parameters</a>
<a name="2564"><span class="lineNum">    2564 </span><span class="lineCov">       4810 :         for (size_t i = 0; i &lt; paramArgMap.size(); ++i)</span></a>
<a name="2565"><span class="lineNum">    2565 </span>            :         {</a>
<a name="2566"><span class="lineNum">    2566 </span><span class="lineCov">       2434 :                 solAssert(!!paramArgMap[i], &quot;unmapped parameter&quot;);</span></a>
<a name="2567"><span class="lineNum">    2567 </span><span class="lineCov">       4868 :                 BoolResult result = type(*paramArgMap[i])-&gt;isImplicitlyConvertibleTo(*parameterTypes[i]);</span></a>
<a name="2568"><span class="lineNum">    2568 </span><span class="lineCov">       2434 :                 if (!result)</span></a>
<a name="2569"><span class="lineNum">    2569 </span>            :                 {</a>
<a name="2570"><span class="lineNum">    2570 </span><span class="lineCov">         75 :                         auto [errorId, description] = [&amp;]() -&gt; std::tuple&lt;ErrorId, std::string&gt; {</span></a>
<a name="2571"><span class="lineNum">    2571 </span>            :                                 std::string msg =</a>
<a name="2572"><span class="lineNum">    2572 </span>            :                                         &quot;Invalid type for argument in function call. &quot;</a>
<a name="2573"><span class="lineNum">    2573 </span><span class="lineCov">        150 :                                         &quot;Invalid implicit conversion from &quot; +</span></a>
<a name="2574"><span class="lineNum">    2574 </span><span class="lineCov">        300 :                                         type(*paramArgMap[i])-&gt;humanReadableName() +</span></a>
<a name="2575"><span class="lineNum">    2575 </span><span class="lineCov">        150 :                                         &quot; to &quot; +</span></a>
<a name="2576"><span class="lineNum">    2576 </span><span class="lineCov">         75 :                                         parameterTypes[i]-&gt;humanReadableName() +</span></a>
<a name="2577"><span class="lineNum">    2577 </span><span class="lineCov">        150 :                                         &quot; requested.&quot;;</span></a>
<a name="2578"><span class="lineNum">    2578 </span><span class="lineCov">         75 :                                 if (!result.message().empty())</span></a>
<a name="2579"><span class="lineNum">    2579 </span><span class="lineCov">         10 :                                         msg += &quot; &quot; + result.message();</span></a>
<a name="2580"><span class="lineNum">    2580 </span><span class="lineCov">         75 :                                 if (</span></a>
<a name="2581"><span class="lineNum">    2581 </span><span class="lineCov">         75 :                                         _functionType-&gt;kind() == FunctionType::Kind::BareCall ||</span></a>
<a name="2582"><span class="lineNum">    2582 </span><span class="lineCov">         75 :                                         _functionType-&gt;kind() == FunctionType::Kind::BareCallCode ||</span></a>
<a name="2583"><span class="lineNum">    2583 </span><span class="lineCov">        225 :                                         _functionType-&gt;kind() == FunctionType::Kind::BareDelegateCall ||</span></a>
<a name="2584"><span class="lineNum">    2584 </span><span class="lineCov">         75 :                                         _functionType-&gt;kind() == FunctionType::Kind::BareStaticCall</span></a>
<a name="2585"><span class="lineNum">    2585 </span>            :                                 )</a>
<a name="2586"><span class="lineNum">    2586 </span>            :                                         return {</a>
<a name="2587"><span class="lineNum">    2587 </span><span class="lineNoCov">          0 :                                                 8051_error,</span></a>
<a name="2588"><span class="lineNum">    2588 </span><span class="lineNoCov">          0 :                                                 msg +</span></a>
<a name="2589"><span class="lineNum">    2589 </span>            :                                                 &quot; This function requires a single bytes argument.&quot;</a>
<a name="2590"><span class="lineNum">    2590 </span>            :                                                 &quot; If all your arguments are value types, you can&quot;</a>
<a name="2591"><span class="lineNum">    2591 </span>            :                                                 &quot; use abi.encode(...) to properly generate it.&quot;</a>
<a name="2592"><span class="lineNum">    2592 </span><span class="lineNoCov">          0 :                                         };</span></a>
<a name="2593"><span class="lineNum">    2593 </span><span class="lineCov">         75 :                                 else if (</span></a>
<a name="2594"><span class="lineNum">    2594 </span><span class="lineCov">         75 :                                         _functionType-&gt;kind() == FunctionType::Kind::KECCAK256 ||</span></a>
<a name="2595"><span class="lineNum">    2595 </span><span class="lineCov">        149 :                                         _functionType-&gt;kind() == FunctionType::Kind::SHA256 ||</span></a>
<a name="2596"><span class="lineNum">    2596 </span><span class="lineCov">         74 :                                         _functionType-&gt;kind() == FunctionType::Kind::RIPEMD160</span></a>
<a name="2597"><span class="lineNum">    2597 </span>            :                                 )</a>
<a name="2598"><span class="lineNum">    2598 </span>            :                                         return {</a>
<a name="2599"><span class="lineNum">    2599 </span><span class="lineCov">          1 :                                                 7556_error,</span></a>
<a name="2600"><span class="lineNum">    2600 </span><span class="lineCov">          2 :                                                 msg +</span></a>
<a name="2601"><span class="lineNum">    2601 </span>            :                                                 &quot; This function requires a single bytes argument.&quot;</a>
<a name="2602"><span class="lineNum">    2602 </span>            :                                                 &quot; Use abi.encodePacked(...) to obtain the pre-0.5.0&quot;</a>
<a name="2603"><span class="lineNum">    2603 </span>            :                                                 &quot; behaviour or abi.encode(...) to use ABI encoding.&quot;</a>
<a name="2604"><span class="lineNum">    2604 </span><span class="lineCov">          1 :                                         };</span></a>
<a name="2605"><span class="lineNum">    2605 </span>            :                                 else</a>
<a name="2606"><span class="lineNum">    2606 </span><span class="lineCov">        148 :                                         return { 9553_error, msg };</span></a>
<a name="2607"><span class="lineNum">    2607 </span><span class="lineCov">        150 :                         }();</span></a>
<a name="2608"><span class="lineNum">    2608 </span><span class="lineCov">         75 :                         m_errorReporter.typeError(errorId, paramArgMap[i]-&gt;location(), description);</span></a>
<a name="2609"><span class="lineNum">    2609 </span>            :                 }</a>
<a name="2610"><span class="lineNum">    2610 </span>            :         }</a>
<a name="2611"><span class="lineNum">    2611 </span>            : </a>
<a name="2612"><span class="lineNum">    2612 </span><span class="lineCov">       2376 :         TypePointers const&amp; returnParameterTypes = _functionType-&gt;returnParameterTypes();</span></a>
<a name="2613"><span class="lineNum">    2613 </span><span class="lineCov">       2376 :         bool isLibraryCall = (_functionType-&gt;kind() == FunctionType::Kind::DelegateCall);</span></a>
<a name="2614"><span class="lineNum">    2614 </span>            :         bool callRequiresABIEncoding =</a>
<a name="2615"><span class="lineNum">    2615 </span>            :                 // ABIEncode/ABIDecode calls not included because they should have been already validated</a>
<a name="2616"><span class="lineNum">    2616 </span>            :                 // at this point and they have variadic arguments so they need special handling.</a>
<a name="2617"><span class="lineNum">    2617 </span><span class="lineCov">       2376 :                 _functionType-&gt;kind() == FunctionType::Kind::DelegateCall ||</span></a>
<a name="2618"><span class="lineNum">    2618 </span><span class="lineCov">       2365 :                 _functionType-&gt;kind() == FunctionType::Kind::External ||</span></a>
<a name="2619"><span class="lineNum">    2619 </span><span class="lineCov">       2274 :                 _functionType-&gt;kind() == FunctionType::Kind::Creation ||</span></a>
<a name="2620"><span class="lineNum">    2620 </span><span class="lineCov">       6800 :                 _functionType-&gt;kind() == FunctionType::Kind::Event ||</span></a>
<a name="2621"><span class="lineNum">    2621 </span><span class="lineCov">       2059 :                 _functionType-&gt;kind() == FunctionType::Kind::Error;</span></a>
<a name="2622"><span class="lineNum">    2622 </span>            : </a>
<a name="2623"><span class="lineNum">    2623 </span><span class="lineCov">       2376 :         if (callRequiresABIEncoding &amp;&amp; !useABICoderV2())</span></a>
<a name="2624"><span class="lineNum">    2624 </span>            :         {</a>
<a name="2625"><span class="lineNum">    2625 </span><span class="lineNoCov">          0 :                 solAssert(!isVariadic, &quot;&quot;);</span></a>
<a name="2626"><span class="lineNum">    2626 </span><span class="lineNoCov">          0 :                 solAssert(parameterTypes.size() == arguments.size(), &quot;&quot;);</span></a>
<a name="2627"><span class="lineNum">    2627 </span><span class="lineNoCov">          0 :                 solAssert(!_functionType-&gt;isBareCall(), &quot;&quot;);</span></a>
<a name="2628"><span class="lineNum">    2628 </span><span class="lineNoCov">          0 :                 solAssert(*_functionCall.annotation().kind == FunctionCallKind::FunctionCall, &quot;&quot;);</span></a>
<a name="2629"><span class="lineNum">    2629 </span>            : </a>
<a name="2630"><span class="lineNum">    2630 </span><span class="lineNoCov">          0 :                 for (size_t i = 0; i &lt; parameterTypes.size(); ++i)</span></a>
<a name="2631"><span class="lineNum">    2631 </span>            :                 {</a>
<a name="2632"><span class="lineNum">    2632 </span><span class="lineNoCov">          0 :                         solAssert(parameterTypes[i], &quot;&quot;);</span></a>
<a name="2633"><span class="lineNum">    2633 </span>            : </a>
<a name="2634"><span class="lineNum">    2634 </span><span class="lineNoCov">          0 :                         if (!typeSupportedByOldABIEncoder(*parameterTypes[i], isLibraryCall))</span></a>
<a name="2635"><span class="lineNum">    2635 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2636"><span class="lineNum">    2636 </span>            :                                         2443_error,</a>
<a name="2637"><span class="lineNum">    2637 </span><span class="lineNoCov">          0 :                                         paramArgMap[i]-&gt;location(),</span></a>
<a name="2638"><span class="lineNum">    2638 </span><span class="lineNoCov">          0 :                                         &quot;The type of this parameter, &quot; + parameterTypes[i]-&gt;humanReadableName() + &quot;, &quot;</span></a>
<a name="2639"><span class="lineNum">    2639 </span>            :                                         &quot;is only supported in ABI coder v2. &quot;</a>
<a name="2640"><span class="lineNum">    2640 </span>            :                                         &quot;Use \&quot;pragma abicoder v2;\&quot; to enable the feature.&quot;</a>
<a name="2641"><span class="lineNum">    2641 </span>            :                                 );</a>
<a name="2642"><span class="lineNum">    2642 </span>            :                 }</a>
<a name="2643"><span class="lineNum">    2643 </span>            : </a>
<a name="2644"><span class="lineNum">    2644 </span><span class="lineNoCov">          0 :                 for (size_t i = 0; i &lt; returnParameterTypes.size(); ++i)</span></a>
<a name="2645"><span class="lineNum">    2645 </span>            :                 {</a>
<a name="2646"><span class="lineNum">    2646 </span><span class="lineNoCov">          0 :                         solAssert(returnParameterTypes[i], &quot;&quot;);</span></a>
<a name="2647"><span class="lineNum">    2647 </span>            : </a>
<a name="2648"><span class="lineNum">    2648 </span><span class="lineNoCov">          0 :                         if (!typeSupportedByOldABIEncoder(*returnParameterTypes[i], isLibraryCall))</span></a>
<a name="2649"><span class="lineNum">    2649 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2650"><span class="lineNum">    2650 </span>            :                                         2428_error,</a>
<a name="2651"><span class="lineNum">    2651 </span><span class="lineNoCov">          0 :                                         _functionCall.location(),</span></a>
<a name="2652"><span class="lineNum">    2652 </span><span class="lineNoCov">          0 :                                         &quot;The type of return parameter &quot; + toString(i + 1) + &quot;, &quot; + returnParameterTypes[i]-&gt;humanReadableName() + &quot;, &quot;</span></a>
<a name="2653"><span class="lineNum">    2653 </span>            :                                         &quot;is only supported in ABI coder v2. &quot;</a>
<a name="2654"><span class="lineNum">    2654 </span>            :                                         &quot;Use \&quot;pragma abicoder v2;\&quot; to enable the feature.&quot;</a>
<a name="2655"><span class="lineNum">    2655 </span>            :                                 );</a>
<a name="2656"><span class="lineNum">    2656 </span>            :                 }</a>
<a name="2657"><span class="lineNum">    2657 </span>            :         }</a>
<a name="2658"><span class="lineNum">    2658 </span>            : }</a>
<a name="2659"><span class="lineNum">    2659 </span>            : </a>
<a name="2660"><span class="lineNum">    2660 </span><span class="lineCov">       4845 : bool TypeChecker::visit(FunctionCall const&amp; _functionCall)</span></a>
<a name="2661"><span class="lineNum">    2661 </span>            : {</a>
<a name="2662"><span class="lineNum">    2662 </span><span class="lineCov">       5035 :         std::vector&lt;ASTPointer&lt;Expression const&gt;&gt; const&amp; arguments = _functionCall.arguments();</span></a>
<a name="2663"><span class="lineNum">    2663 </span><span class="lineCov">       4845 :         bool argumentsArePure = true;</span></a>
<a name="2664"><span class="lineNum">    2664 </span>            : </a>
<a name="2665"><span class="lineNum">    2665 </span>            :         // We need to check arguments' type first as they will be needed for overload resolution.</a>
<a name="2666"><span class="lineNum">    2666 </span><span class="lineCov">       9763 :         for (ASTPointer&lt;Expression const&gt; const&amp; argument: arguments)</span></a>
<a name="2667"><span class="lineNum">    2667 </span>            :         {</a>
<a name="2668"><span class="lineNum">    2668 </span><span class="lineCov">       4949 :                 argument-&gt;accept(*this);</span></a>
<a name="2669"><span class="lineNum">    2669 </span><span class="lineCov">       4918 :                 if (!*argument-&gt;annotation().isPure)</span></a>
<a name="2670"><span class="lineNum">    2670 </span><span class="lineCov">       2707 :                         argumentsArePure = false;</span></a>
<a name="2671"><span class="lineNum">    2671 </span>            :         }</a>
<a name="2672"><span class="lineNum">    2672 </span>            : </a>
<a name="2673"><span class="lineNum">    2673 </span>            :         // Store argument types - and names if given - for overload resolution</a>
<a name="2674"><span class="lineNum">    2674 </span>            :         {</a>
<a name="2675"><span class="lineNum">    2675 </span><span class="lineCov">       9628 :                 FuncCallArguments funcCallArgs;</span></a>
<a name="2676"><span class="lineNum">    2676 </span>            : </a>
<a name="2677"><span class="lineNum">    2677 </span><span class="lineCov">       4814 :                 funcCallArgs.names = _functionCall.names();</span></a>
<a name="2678"><span class="lineNum">    2678 </span>            : </a>
<a name="2679"><span class="lineNum">    2679 </span><span class="lineCov">       9730 :                 for (ASTPointer&lt;Expression const&gt; const&amp; argument: arguments)</span></a>
<a name="2680"><span class="lineNum">    2680 </span><span class="lineCov">       4916 :                         funcCallArgs.types.push_back(type(*argument));</span></a>
<a name="2681"><span class="lineNum">    2681 </span>            : </a>
<a name="2682"><span class="lineNum">    2682 </span><span class="lineCov">       4814 :                 _functionCall.expression().annotation().arguments = std::move(funcCallArgs);</span></a>
<a name="2683"><span class="lineNum">    2683 </span>            :         }</a>
<a name="2684"><span class="lineNum">    2684 </span>            : </a>
<a name="2685"><span class="lineNum">    2685 </span><span class="lineCov">       4814 :         _functionCall.expression().accept(*this);</span></a>
<a name="2686"><span class="lineNum">    2686 </span>            : </a>
<a name="2687"><span class="lineNum">    2687 </span><span class="lineCov">       4676 :         Type const* expressionType = type(_functionCall.expression());</span></a>
<a name="2688"><span class="lineNum">    2688 </span>            : </a>
<a name="2689"><span class="lineNum">    2689 </span>            :         // Determine function call kind and function type for this FunctionCall node</a>
<a name="2690"><span class="lineNum">    2690 </span><span class="lineCov">       4676 :         FunctionCallAnnotation&amp; funcCallAnno = _functionCall.annotation();</span></a>
<a name="2691"><span class="lineNum">    2691 </span><span class="lineCov">       4676 :         FunctionTypePointer functionType = nullptr;</span></a>
<a name="2692"><span class="lineNum">    2692 </span><span class="lineCov">       4676 :         funcCallAnno.isConstant = false;</span></a>
<a name="2693"><span class="lineNum">    2693 </span>            : </a>
<a name="2694"><span class="lineNum">    2694 </span><span class="lineCov">       4676 :         bool isLValue = false;</span></a>
<a name="2695"><span class="lineNum">    2695 </span>            : </a>
<a name="2696"><span class="lineNum">    2696 </span>            :         // Determine and assign function call kind, lvalue, purity and function type for this FunctionCall node</a>
<a name="2697"><span class="lineNum">    2697 </span><span class="lineCov">       4676 :         switch (expressionType-&gt;category())</span></a>
<a name="2698"><span class="lineNum">    2698 </span>            :         {</a>
<a name="2699"><span class="lineNum">    2699 </span><span class="lineCov">       2464 :         case Type::Category::Function:</span></a>
<a name="2700"><span class="lineNum">    2700 </span><span class="lineCov">       2464 :                 functionType = dynamic_cast&lt;FunctionType const*&gt;(expressionType);</span></a>
<a name="2701"><span class="lineNum">    2701 </span><span class="lineCov">       2464 :                 funcCallAnno.kind = FunctionCallKind::FunctionCall;</span></a>
<a name="2702"><span class="lineNum">    2702 </span>            : </a>
<a name="2703"><span class="lineNum">    2703 </span><span class="lineCov">       2464 :                 if (auto memberAccess = dynamic_cast&lt;MemberAccess const*&gt;(&amp;_functionCall.expression()))</span></a>
<a name="2704"><span class="lineNum">    2704 </span>            :                 {</a>
<a name="2705"><span class="lineNum">    2705 </span><span class="lineCov">        243 :                         if (dynamic_cast&lt;FunctionDefinition const*&gt;(memberAccess-&gt;annotation().referencedDeclaration))</span></a>
<a name="2706"><span class="lineNum">    2706 </span><span class="lineCov">        150 :                                 _functionCall.expression().annotation().calledDirectly = true;</span></a>
<a name="2707"><span class="lineNum">    2707 </span>            :                 }</a>
<a name="2708"><span class="lineNum">    2708 </span><span class="lineCov">       2221 :                 else if (auto identifier = dynamic_cast&lt;Identifier const*&gt;(&amp;_functionCall.expression()))</span></a>
<a name="2709"><span class="lineNum">    2709 </span><span class="lineCov">       2063 :                         if (dynamic_cast&lt;FunctionDefinition const*&gt;(identifier-&gt;annotation().referencedDeclaration))</span></a>
<a name="2710"><span class="lineNum">    2710 </span><span class="lineCov">        677 :                                 _functionCall.expression().annotation().calledDirectly = true;</span></a>
<a name="2711"><span class="lineNum">    2711 </span>            : </a>
<a name="2712"><span class="lineNum">    2712 </span>            :                 // Purity for function calls also depends upon the callee and its FunctionType</a>
<a name="2713"><span class="lineNum">    2713 </span>            :                 funcCallAnno.isPure =</a>
<a name="2714"><span class="lineNum">    2714 </span><span class="lineCov">       1171 :                         argumentsArePure &amp;&amp;</span></a>
<a name="2715"><span class="lineNum">    2715 </span><span class="lineCov">       3048 :                         *_functionCall.expression().annotation().isPure &amp;&amp;</span></a>
<a name="2716"><span class="lineNum">    2716 </span><span class="lineCov">       3048 :                         functionType-&gt;isPure();</span></a>
<a name="2717"><span class="lineNum">    2717 </span>            : </a>
<a name="2718"><span class="lineNum">    2718 </span><span class="lineCov">       2464 :                 if (functionType-&gt;kind() == FunctionType::Kind::ArrayPush)</span></a>
<a name="2719"><span class="lineNum">    2719 </span><span class="lineCov">         35 :                         isLValue = functionType-&gt;parameterTypes().empty();</span></a>
<a name="2720"><span class="lineNum">    2720 </span>            : </a>
<a name="2721"><span class="lineNum">    2721 </span><span class="lineCov">       2464 :                 break;</span></a>
<a name="2722"><span class="lineNum">    2722 </span>            : </a>
<a name="2723"><span class="lineNum">    2723 </span><span class="lineCov">       2194 :         case Type::Category::TypeType:</span></a>
<a name="2724"><span class="lineNum">    2724 </span>            :         {</a>
<a name="2725"><span class="lineNum">    2725 </span>            :                 // Determine type for type conversion or struct construction expressions</a>
<a name="2726"><span class="lineNum">    2726 </span><span class="lineCov">       2194 :                 Type const* actualType = dynamic_cast&lt;TypeType const&amp;&gt;(*expressionType).actualType();</span></a>
<a name="2727"><span class="lineNum">    2727 </span><span class="lineCov">       2194 :                 solAssert(!!actualType, &quot;&quot;);</span></a>
<a name="2728"><span class="lineNum">    2728 </span>            : </a>
<a name="2729"><span class="lineNum">    2729 </span><span class="lineCov">       2194 :                 if (actualType-&gt;category() == Type::Category::Struct)</span></a>
<a name="2730"><span class="lineNum">    2730 </span>            :                 {</a>
<a name="2731"><span class="lineNum">    2731 </span><span class="lineCov">         17 :                         if (actualType-&gt;containsNestedMapping())</span></a>
<a name="2732"><span class="lineNum">    2732 </span><span class="lineCov">          4 :                                 m_errorReporter.fatalTypeError(</span></a>
<a name="2733"><span class="lineNum">    2733 </span>            :                                         9515_error,</a>
<a name="2734"><span class="lineNum">    2734 </span><span class="lineCov">          1 :                                         _functionCall.location(),</span></a>
<a name="2735"><span class="lineNum">    2735 </span>            :                                         &quot;Struct containing a (nested) mapping cannot be constructed.&quot;</a>
<a name="2736"><span class="lineNum">    2736 </span>            :                                 );</a>
<a name="2737"><span class="lineNum">    2737 </span><span class="lineCov">         16 :                         functionType = dynamic_cast&lt;StructType const&amp;&gt;(*actualType).constructorType();</span></a>
<a name="2738"><span class="lineNum">    2738 </span><span class="lineCov">         16 :                         funcCallAnno.kind = FunctionCallKind::StructConstructorCall;</span></a>
<a name="2739"><span class="lineNum">    2739 </span>            :                 }</a>
<a name="2740"><span class="lineNum">    2740 </span>            :                 else</a>
<a name="2741"><span class="lineNum">    2741 </span>            :                 {</a>
<a name="2742"><span class="lineNum">    2742 </span><span class="lineCov">       2177 :                         if (auto const* contractType = dynamic_cast&lt;ContractType const*&gt;(actualType))</span></a>
<a name="2743"><span class="lineNum">    2743 </span><span class="lineCov">         54 :                                 if (contractType-&gt;isSuper())</span></a>
<a name="2744"><span class="lineNum">    2744 </span><span class="lineNoCov">          0 :                                         m_errorReporter.fatalTypeError(</span></a>
<a name="2745"><span class="lineNum">    2745 </span>            :                                                 1744_error,</a>
<a name="2746"><span class="lineNum">    2746 </span><span class="lineNoCov">          0 :                                                 _functionCall.location(),</span></a>
<a name="2747"><span class="lineNum">    2747 </span>            :                                                 &quot;Cannot convert to the super type.&quot;</a>
<a name="2748"><span class="lineNum">    2748 </span>            :                                         );</a>
<a name="2749"><span class="lineNum">    2749 </span><span class="lineCov">       2177 :                         funcCallAnno.kind = FunctionCallKind::TypeConversion;</span></a>
<a name="2750"><span class="lineNum">    2750 </span>            :                 }</a>
<a name="2751"><span class="lineNum">    2751 </span>            : </a>
<a name="2752"><span class="lineNum">    2752 </span><span class="lineCov">       2193 :                 funcCallAnno.isPure = argumentsArePure;</span></a>
<a name="2753"><span class="lineNum">    2753 </span>            : </a>
<a name="2754"><span class="lineNum">    2754 </span><span class="lineCov">       2193 :                 break;</span></a>
<a name="2755"><span class="lineNum">    2755 </span>            :         }</a>
<a name="2756"><span class="lineNum">    2756 </span>            : </a>
<a name="2757"><span class="lineNum">    2757 </span><span class="lineCov">         18 :         default:</span></a>
<a name="2758"><span class="lineNum">    2758 </span><span class="lineCov">         54 :                 m_errorReporter.fatalTypeError(5704_error, _functionCall.location(), &quot;This expression is not callable.&quot;);</span></a>
<a name="2759"><span class="lineNum">    2759 </span>            :                 // Unreachable, because fatalTypeError throws. We don't set kind, but that's okay because the switch below</a>
<a name="2760"><span class="lineNum">    2760 </span>            :                 // is never reached. And, even if it was, SetOnce would trigger an assertion violation and not UB.</a>
<a name="2761"><span class="lineNum">    2761 </span><span class="lineNoCov">          0 :                 funcCallAnno.isPure = argumentsArePure;</span></a>
<a name="2762"><span class="lineNum">    2762 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="2763"><span class="lineNum">    2763 </span>            :         }</a>
<a name="2764"><span class="lineNum">    2764 </span>            : </a>
<a name="2765"><span class="lineNum">    2765 </span><span class="lineCov">       4657 :         funcCallAnno.isLValue = isLValue;</span></a>
<a name="2766"><span class="lineNum">    2766 </span>            : </a>
<a name="2767"><span class="lineNum">    2767 </span>            :         // Determine return types</a>
<a name="2768"><span class="lineNum">    2768 </span><span class="lineCov">       4657 :         switch (*funcCallAnno.kind)</span></a>
<a name="2769"><span class="lineNum">    2769 </span>            :         {</a>
<a name="2770"><span class="lineNum">    2770 </span><span class="lineCov">       2177 :         case FunctionCallKind::TypeConversion:</span></a>
<a name="2771"><span class="lineNum">    2771 </span><span class="lineCov">       2177 :                 funcCallAnno.type = typeCheckTypeConversionAndRetrieveReturnType(_functionCall);</span></a>
<a name="2772"><span class="lineNum">    2772 </span><span class="lineCov">       2177 :                 break;</span></a>
<a name="2773"><span class="lineNum">    2773 </span>            : </a>
<a name="2774"><span class="lineNum">    2774 </span><span class="lineCov">       2480 :         case FunctionCallKind::StructConstructorCall: // fall-through</span></a>
<a name="2775"><span class="lineNum">    2775 </span>            :         case FunctionCallKind::FunctionCall:</a>
<a name="2776"><span class="lineNum">    2776 </span>            :         {</a>
<a name="2777"><span class="lineNum">    2777 </span><span class="lineCov">       4960 :                 TypePointers returnTypes;</span></a>
<a name="2778"><span class="lineNum">    2778 </span>            : </a>
<a name="2779"><span class="lineNum">    2779 </span><span class="lineCov">       2480 :                 switch (functionType-&gt;kind())</span></a>
<a name="2780"><span class="lineNum">    2780 </span>            :                 {</a>
<a name="2781"><span class="lineNum">    2781 </span><span class="lineCov">          4 :                 case FunctionType::Kind::ABIDecode:</span></a>
<a name="2782"><span class="lineNum">    2782 </span>            :                 {</a>
<a name="2783"><span class="lineNum">    2783 </span><span class="lineCov">          4 :                         returnTypes = typeCheckABIDecodeAndRetrieveReturnType(</span></a>
<a name="2784"><span class="lineNum">    2784 </span>            :                                 _functionCall,</a>
<a name="2785"><span class="lineNum">    2785 </span><span class="lineCov">          4 :                                 useABICoderV2()</span></a>
<a name="2786"><span class="lineNum">    2786 </span><span class="lineCov">          4 :                         );</span></a>
<a name="2787"><span class="lineNum">    2787 </span><span class="lineCov">          4 :                         break;</span></a>
<a name="2788"><span class="lineNum">    2788 </span>            :                 }</a>
<a name="2789"><span class="lineNum">    2789 </span><span class="lineCov">         37 :                 case FunctionType::Kind::ABIEncode:</span></a>
<a name="2790"><span class="lineNum">    2790 </span>            :                 case FunctionType::Kind::ABIEncodePacked:</a>
<a name="2791"><span class="lineNum">    2791 </span>            :                 case FunctionType::Kind::ABIEncodeWithSelector:</a>
<a name="2792"><span class="lineNum">    2792 </span>            :                 case FunctionType::Kind::ABIEncodeWithSignature:</a>
<a name="2793"><span class="lineNum">    2793 </span>            :                 case FunctionType::Kind::ABIEncodeCall:</a>
<a name="2794"><span class="lineNum">    2794 </span>            :                 {</a>
<a name="2795"><span class="lineNum">    2795 </span><span class="lineCov">         37 :                         typeCheckABIEncodeFunctions(_functionCall, functionType);</span></a>
<a name="2796"><span class="lineNum">    2796 </span><span class="lineCov">         37 :                         returnTypes = functionType-&gt;returnParameterTypes();</span></a>
<a name="2797"><span class="lineNum">    2797 </span><span class="lineCov">         37 :                         break;</span></a>
<a name="2798"><span class="lineNum">    2798 </span>            :                 }</a>
<a name="2799"><span class="lineNum">    2799 </span><span class="lineCov">         27 :                 case FunctionType::Kind::MetaType:</span></a>
<a name="2800"><span class="lineNum">    2800 </span><span class="lineCov">         27 :                         returnTypes = typeCheckMetaTypeFunctionAndRetrieveReturnType(_functionCall);</span></a>
<a name="2801"><span class="lineNum">    2801 </span><span class="lineCov">         25 :                         break;</span></a>
<a name="2802"><span class="lineNum">    2802 </span><span class="lineCov">          1 :                 case FunctionType::Kind::BytesConcat:</span></a>
<a name="2803"><span class="lineNum">    2803 </span>            :                 {</a>
<a name="2804"><span class="lineNum">    2804 </span><span class="lineCov">          1 :                         typeCheckBytesConcatFunction(_functionCall, functionType);</span></a>
<a name="2805"><span class="lineNum">    2805 </span><span class="lineCov">          1 :                         returnTypes = functionType-&gt;returnParameterTypes();</span></a>
<a name="2806"><span class="lineNum">    2806 </span><span class="lineCov">          1 :                         break;</span></a>
<a name="2807"><span class="lineNum">    2807 </span>            :                 }</a>
<a name="2808"><span class="lineNum">    2808 </span><span class="lineNoCov">          0 :                 case FunctionType::Kind::StringConcat:</span></a>
<a name="2809"><span class="lineNum">    2809 </span>            :                 {</a>
<a name="2810"><span class="lineNum">    2810 </span><span class="lineNoCov">          0 :                         typeCheckStringConcatFunction(_functionCall, functionType);</span></a>
<a name="2811"><span class="lineNum">    2811 </span><span class="lineNoCov">          0 :                         returnTypes = functionType-&gt;returnParameterTypes();</span></a>
<a name="2812"><span class="lineNum">    2812 </span><span class="lineNoCov">          0 :                         break;</span></a>
<a name="2813"><span class="lineNum">    2813 </span>            :                 }</a>
<a name="2814"><span class="lineNum">    2814 </span><span class="lineNoCov">          0 :                 case FunctionType::Kind::Wrap:</span></a>
<a name="2815"><span class="lineNum">    2815 </span>            :                 case FunctionType::Kind::Unwrap:</a>
<a name="2816"><span class="lineNum">    2816 </span>            :                 {</a>
<a name="2817"><span class="lineNum">    2817 </span><span class="lineNoCov">          0 :                         typeCheckFunctionGeneralChecks(_functionCall, functionType);</span></a>
<a name="2818"><span class="lineNum">    2818 </span><span class="lineNoCov">          0 :                         returnTypes = functionType-&gt;returnParameterTypes();</span></a>
<a name="2819"><span class="lineNum">    2819 </span><span class="lineNoCov">          0 :                         break;</span></a>
<a name="2820"><span class="lineNum">    2820 </span>            :                 }</a>
<a name="2821"><span class="lineNum">    2821 </span><span class="lineCov">       2411 :                 default:</span></a>
<a name="2822"><span class="lineNum">    2822 </span>            :                 {</a>
<a name="2823"><span class="lineNum">    2823 </span><span class="lineCov">       2411 :                         typeCheckFunctionCall(_functionCall, functionType);</span></a>
<a name="2824"><span class="lineNum">    2824 </span><span class="lineCov">       7233 :                         returnTypes = m_evmVersion.supportsReturndata() ?</span></a>
<a name="2825"><span class="lineNum">    2825 </span><span class="lineCov">       2411 :                                 functionType-&gt;returnParameterTypes() :</span></a>
<a name="2826"><span class="lineNum">    2826 </span><span class="lineCov">       2411 :                                 functionType-&gt;returnParameterTypesWithoutDynamicTypes();</span></a>
<a name="2827"><span class="lineNum">    2827 </span><span class="lineCov">       2411 :                         break;</span></a>
<a name="2828"><span class="lineNum">    2828 </span>            :                 }</a>
<a name="2829"><span class="lineNum">    2829 </span>            :                 }</a>
<a name="2830"><span class="lineNum">    2830 </span>            : </a>
<a name="2831"><span class="lineNum">    2831 </span><span class="lineCov">       3161 :                 funcCallAnno.type = returnTypes.size() == 1 ?</span></a>
<a name="2832"><span class="lineNum">    2832 </span><span class="lineCov">        683 :                         std::move(returnTypes.front()) :</span></a>
<a name="2833"><span class="lineNum">    2833 </span><span class="lineCov">       2478 :                         TypeProvider::tuple(std::move(returnTypes));</span></a>
<a name="2834"><span class="lineNum">    2834 </span>            : </a>
<a name="2835"><span class="lineNum">    2835 </span><span class="lineCov">       2478 :                 break;</span></a>
<a name="2836"><span class="lineNum">    2836 </span>            :         }</a>
<a name="2837"><span class="lineNum">    2837 </span>            : </a>
<a name="2838"><span class="lineNum">    2838 </span><span class="lineNoCov">          0 :         default:</span></a>
<a name="2839"><span class="lineNum">    2839 </span>            :                 // for non-callables, ensure error reported and annotate node to void function</a>
<a name="2840"><span class="lineNum">    2840 </span><span class="lineNoCov">          0 :                 solAssert(m_errorReporter.hasErrors(), &quot;&quot;);</span></a>
<a name="2841"><span class="lineNum">    2841 </span><span class="lineNoCov">          0 :                 funcCallAnno.kind = FunctionCallKind::FunctionCall;</span></a>
<a name="2842"><span class="lineNum">    2842 </span><span class="lineNoCov">          0 :                 funcCallAnno.type = TypeProvider::emptyTuple();</span></a>
<a name="2843"><span class="lineNum">    2843 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="2844"><span class="lineNum">    2844 </span>            :         }</a>
<a name="2845"><span class="lineNum">    2845 </span>            : </a>
<a name="2846"><span class="lineNum">    2846 </span><span class="lineCov">       9310 :         return false;</span></a>
<a name="2847"><span class="lineNum">    2847 </span>            : }</a>
<a name="2848"><span class="lineNum">    2848 </span>            : </a>
<a name="2849"><span class="lineNum">    2849 </span><span class="lineCov">         20 : bool TypeChecker::visit(FunctionCallOptions const&amp; _functionCallOptions)</span></a>
<a name="2850"><span class="lineNum">    2850 </span>            : {</a>
<a name="2851"><span class="lineNum">    2851 </span><span class="lineCov">         20 :         solAssert(_functionCallOptions.options().size() == _functionCallOptions.names().size(), &quot;Lengths of name &amp; value arrays differ!&quot;);</span></a>
<a name="2852"><span class="lineNum">    2852 </span>            : </a>
<a name="2853"><span class="lineNum">    2853 </span><span class="lineCov">         20 :         _functionCallOptions.expression().annotation().arguments = _functionCallOptions.annotation().arguments;</span></a>
<a name="2854"><span class="lineNum">    2854 </span>            : </a>
<a name="2855"><span class="lineNum">    2855 </span><span class="lineCov">         20 :         _functionCallOptions.expression().accept(*this);</span></a>
<a name="2856"><span class="lineNum">    2856 </span>            : </a>
<a name="2857"><span class="lineNum">    2857 </span><span class="lineCov">         20 :         _functionCallOptions.annotation().isPure = false;</span></a>
<a name="2858"><span class="lineNum">    2858 </span><span class="lineCov">         20 :         _functionCallOptions.annotation().isConstant = false;</span></a>
<a name="2859"><span class="lineNum">    2859 </span><span class="lineCov">         20 :         _functionCallOptions.annotation().isLValue = false;</span></a>
<a name="2860"><span class="lineNum">    2860 </span>            : </a>
<a name="2861"><span class="lineNum">    2861 </span><span class="lineCov">         20 :         auto expressionFunctionType = dynamic_cast&lt;FunctionType const*&gt;(type(_functionCallOptions.expression()));</span></a>
<a name="2862"><span class="lineNum">    2862 </span><span class="lineCov">         20 :         if (!expressionFunctionType)</span></a>
<a name="2863"><span class="lineNum">    2863 </span>            :         {</a>
<a name="2864"><span class="lineNum">    2864 </span><span class="lineNoCov">          0 :                 m_errorReporter.fatalTypeError(2622_error, _functionCallOptions.location(), &quot;Expected callable expression before call options.&quot;);</span></a>
<a name="2865"><span class="lineNum">    2865 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="2866"><span class="lineNum">    2866 </span>            :         }</a>
<a name="2867"><span class="lineNum">    2867 </span>            : </a>
<a name="2868"><span class="lineNum">    2868 </span><span class="lineCov">         20 :         bool setSalt = false;</span></a>
<a name="2869"><span class="lineNum">    2869 </span><span class="lineCov">         20 :         bool setValue = false;</span></a>
<a name="2870"><span class="lineNum">    2870 </span><span class="lineCov">         20 :         bool setGas = false;</span></a>
<a name="2871"><span class="lineNum">    2871 </span>            : </a>
<a name="2872"><span class="lineNum">    2872 </span><span class="lineCov">         20 :         FunctionType::Kind kind = expressionFunctionType-&gt;kind();</span></a>
<a name="2873"><span class="lineNum">    2873 </span><span class="lineCov">         20 :         if (</span></a>
<a name="2874"><span class="lineNum">    2874 </span><span class="lineCov">         20 :                 kind != FunctionType::Kind::Creation &amp;&amp;</span></a>
<a name="2875"><span class="lineNum">    2875 </span><span class="lineCov">         20 :                 kind != FunctionType::Kind::External &amp;&amp;</span></a>
<a name="2876"><span class="lineNum">    2876 </span><span class="lineNoCov">          0 :                 kind != FunctionType::Kind::BareCall &amp;&amp;</span></a>
<a name="2877"><span class="lineNum">    2877 </span><span class="lineNoCov">          0 :                 kind != FunctionType::Kind::BareCallCode &amp;&amp;</span></a>
<a name="2878"><span class="lineNum">    2878 </span><span class="lineNoCov">          0 :                 kind != FunctionType::Kind::BareDelegateCall &amp;&amp;</span></a>
<a name="2879"><span class="lineNum">    2879 </span>            :                 kind != FunctionType::Kind::BareStaticCall</a>
<a name="2880"><span class="lineNum">    2880 </span>            :         )</a>
<a name="2881"><span class="lineNum">    2881 </span>            :         {</a>
<a name="2882"><span class="lineNum">    2882 </span><span class="lineNoCov">          0 :                 m_errorReporter.fatalTypeError(</span></a>
<a name="2883"><span class="lineNum">    2883 </span>            :                         2193_error,</a>
<a name="2884"><span class="lineNum">    2884 </span><span class="lineNoCov">          0 :                         _functionCallOptions.location(),</span></a>
<a name="2885"><span class="lineNum">    2885 </span>            :                         &quot;Function call options can only be set on external function calls or contract creations.&quot;</a>
<a name="2886"><span class="lineNum">    2886 </span>            :                 );</a>
<a name="2887"><span class="lineNum">    2887 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="2888"><span class="lineNum">    2888 </span>            :         }</a>
<a name="2889"><span class="lineNum">    2889 </span>            : </a>
<a name="2890"><span class="lineNum">    2890 </span><span class="lineCov">         20 :         if (</span></a>
<a name="2891"><span class="lineNum">    2891 </span><span class="lineCov">         40 :                 expressionFunctionType-&gt;valueSet() ||</span></a>
<a name="2892"><span class="lineNum">    2892 </span><span class="lineCov">         40 :                 expressionFunctionType-&gt;gasSet() ||</span></a>
<a name="2893"><span class="lineNum">    2893 </span><span class="lineCov">         20 :                 expressionFunctionType-&gt;saltSet()</span></a>
<a name="2894"><span class="lineNum">    2894 </span>            :         )</a>
<a name="2895"><span class="lineNum">    2895 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="2896"><span class="lineNum">    2896 </span>            :                         1645_error,</a>
<a name="2897"><span class="lineNum">    2897 </span><span class="lineNoCov">          0 :                         _functionCallOptions.location(),</span></a>
<a name="2898"><span class="lineNum">    2898 </span>            :                         &quot;Function call options have already been set, you have to combine them into a single &quot;</a>
<a name="2899"><span class="lineNum">    2899 </span>            :                         &quot;{...}-option.&quot;</a>
<a name="2900"><span class="lineNum">    2900 </span>            :                 );</a>
<a name="2901"><span class="lineNum">    2901 </span>            : </a>
<a name="2902"><span class="lineNum">    2902 </span><span class="lineCov">         19 :         auto setCheckOption = [&amp;](bool&amp; _option, std::string const&amp; _name)</span></a>
<a name="2903"><span class="lineNum">    2903 </span>            :         {</a>
<a name="2904"><span class="lineNum">    2904 </span><span class="lineCov">         19 :                 if (_option)</span></a>
<a name="2905"><span class="lineNum">    2905 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2906"><span class="lineNum">    2906 </span>            :                                 9886_error,</a>
<a name="2907"><span class="lineNum">    2907 </span><span class="lineNoCov">          0 :                                 _functionCallOptions.location(),</span></a>
<a name="2908"><span class="lineNum">    2908 </span><span class="lineNoCov">          0 :                                 &quot;Duplicate option \&quot;&quot; + std::move(_name) + &quot;\&quot;.&quot;</span></a>
<a name="2909"><span class="lineNum">    2909 </span>            :                         );</a>
<a name="2910"><span class="lineNum">    2910 </span>            : </a>
<a name="2911"><span class="lineNum">    2911 </span><span class="lineCov">         19 :                 _option = true;</span></a>
<a name="2912"><span class="lineNum">    2912 </span><span class="lineCov">         19 :         };</span></a>
<a name="2913"><span class="lineNum">    2913 </span>            : </a>
<a name="2914"><span class="lineNum">    2914 </span><span class="lineCov">         39 :         for (size_t i = 0; i &lt; _functionCallOptions.names().size(); ++i)</span></a>
<a name="2915"><span class="lineNum">    2915 </span>            :         {</a>
<a name="2916"><span class="lineNum">    2916 </span><span class="lineCov">         20 :                 std::string const&amp; name = *(_functionCallOptions.names()[i]);</span></a>
<a name="2917"><span class="lineNum">    2917 </span><span class="lineCov">         20 :                 if (name == &quot;salt&quot;)</span></a>
<a name="2918"><span class="lineNum">    2918 </span>            :                 {</a>
<a name="2919"><span class="lineNum">    2919 </span><span class="lineNoCov">          0 :                         if (kind == FunctionType::Kind::Creation)</span></a>
<a name="2920"><span class="lineNum">    2920 </span>            :                         {</a>
<a name="2921"><span class="lineNum">    2921 </span><span class="lineNoCov">          0 :                                 setCheckOption(setSalt, &quot;salt&quot;);</span></a>
<a name="2922"><span class="lineNum">    2922 </span><span class="lineNoCov">          0 :                                 expectType(*_functionCallOptions.options()[i], *TypeProvider::fixedBytes(32));</span></a>
<a name="2923"><span class="lineNum">    2923 </span>            :                         }</a>
<a name="2924"><span class="lineNum">    2924 </span>            :                         else</a>
<a name="2925"><span class="lineNum">    2925 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2926"><span class="lineNum">    2926 </span>            :                                         2721_error,</a>
<a name="2927"><span class="lineNum">    2927 </span><span class="lineNoCov">          0 :                                         _functionCallOptions.location(),</span></a>
<a name="2928"><span class="lineNum">    2928 </span>            :                                         &quot;Function call option \&quot;salt\&quot; can only be used with \&quot;new\&quot;.&quot;</a>
<a name="2929"><span class="lineNum">    2929 </span>            :                                 );</a>
<a name="2930"><span class="lineNum">    2930 </span>            :                 }</a>
<a name="2931"><span class="lineNum">    2931 </span><span class="lineCov">         20 :                 else if (name == &quot;value&quot;)</span></a>
<a name="2932"><span class="lineNum">    2932 </span>            :                 {</a>
<a name="2933"><span class="lineNum">    2933 </span><span class="lineCov">         20 :                         if (kind == FunctionType::Kind::BareDelegateCall)</span></a>
<a name="2934"><span class="lineNum">    2934 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2935"><span class="lineNum">    2935 </span>            :                                         6189_error,</a>
<a name="2936"><span class="lineNum">    2936 </span><span class="lineNoCov">          0 :                                         _functionCallOptions.location(),</span></a>
<a name="2937"><span class="lineNum">    2937 </span>            :                                         &quot;Cannot set option \&quot;value\&quot; for delegatecall.&quot;</a>
<a name="2938"><span class="lineNum">    2938 </span>            :                                 );</a>
<a name="2939"><span class="lineNum">    2939 </span><span class="lineCov">         20 :                         else if (kind == FunctionType::Kind::BareStaticCall)</span></a>
<a name="2940"><span class="lineNum">    2940 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2941"><span class="lineNum">    2941 </span>            :                                         2842_error,</a>
<a name="2942"><span class="lineNum">    2942 </span><span class="lineNoCov">          0 :                                         _functionCallOptions.location(),</span></a>
<a name="2943"><span class="lineNum">    2943 </span>            :                                         &quot;Cannot set option \&quot;value\&quot; for staticcall.&quot;</a>
<a name="2944"><span class="lineNum">    2944 </span>            :                                 );</a>
<a name="2945"><span class="lineNum">    2945 </span><span class="lineCov">         20 :                         else if (!expressionFunctionType-&gt;isPayable())</span></a>
<a name="2946"><span class="lineNum">    2946 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2947"><span class="lineNum">    2947 </span>            :                                         7006_error,</a>
<a name="2948"><span class="lineNum">    2948 </span><span class="lineNoCov">          0 :                                         _functionCallOptions.location(),</span></a>
<a name="2949"><span class="lineNum">    2949 </span><span class="lineNoCov">          0 :                                         kind == FunctionType::Kind::Creation ?</span></a>
<a name="2950"><span class="lineNum">    2950 </span><span class="lineNoCov">          0 :                                                 &quot;Cannot set option \&quot;value\&quot;, since the constructor of &quot; +</span></a>
<a name="2951"><span class="lineNum">    2951 </span><span class="lineNoCov">          0 :                                                 expressionFunctionType-&gt;returnParameterTypes().front()-&gt;humanReadableName() +</span></a>
<a name="2952"><span class="lineNum">    2952 </span>            :                                                 &quot; is not payable.&quot; :</a>
<a name="2953"><span class="lineNum">    2953 </span>            :                                                 &quot;Cannot set option \&quot;value\&quot; on a non-payable function type.&quot;</a>
<a name="2954"><span class="lineNum">    2954 </span>            :                                 );</a>
<a name="2955"><span class="lineNum">    2955 </span>            :                         else</a>
<a name="2956"><span class="lineNum">    2956 </span>            :                         {</a>
<a name="2957"><span class="lineNum">    2957 </span><span class="lineCov">         21 :                                 expectType(*_functionCallOptions.options()[i], *TypeProvider::uint256());</span></a>
<a name="2958"><span class="lineNum">    2958 </span>            : </a>
<a name="2959"><span class="lineNum">    2959 </span><span class="lineCov">         19 :                                 setCheckOption(setValue, &quot;value&quot;);</span></a>
<a name="2960"><span class="lineNum">    2960 </span>            :                         }</a>
<a name="2961"><span class="lineNum">    2961 </span>            :                 }</a>
<a name="2962"><span class="lineNum">    2962 </span><span class="lineNoCov">          0 :                 else if (name == &quot;gas&quot;)</span></a>
<a name="2963"><span class="lineNum">    2963 </span>            :                 {</a>
<a name="2964"><span class="lineNum">    2964 </span><span class="lineNoCov">          0 :                         if (kind == FunctionType::Kind::Creation)</span></a>
<a name="2965"><span class="lineNum">    2965 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="2966"><span class="lineNum">    2966 </span>            :                                         9903_error,</a>
<a name="2967"><span class="lineNum">    2967 </span><span class="lineNoCov">          0 :                                         _functionCallOptions.location(),</span></a>
<a name="2968"><span class="lineNum">    2968 </span>            :                                         &quot;Function call option \&quot;gas\&quot; cannot be used with \&quot;new\&quot;.&quot;</a>
<a name="2969"><span class="lineNum">    2969 </span>            :                                 );</a>
<a name="2970"><span class="lineNum">    2970 </span>            :                         else</a>
<a name="2971"><span class="lineNum">    2971 </span>            :                         {</a>
<a name="2972"><span class="lineNum">    2972 </span><span class="lineNoCov">          0 :                                 expectType(*_functionCallOptions.options()[i], *TypeProvider::uint256());</span></a>
<a name="2973"><span class="lineNum">    2973 </span>            : </a>
<a name="2974"><span class="lineNum">    2974 </span><span class="lineNoCov">          0 :                                 setCheckOption(setGas, &quot;gas&quot;);</span></a>
<a name="2975"><span class="lineNum">    2975 </span>            :                         }</a>
<a name="2976"><span class="lineNum">    2976 </span>            :                 }</a>
<a name="2977"><span class="lineNum">    2977 </span>            :                 else</a>
<a name="2978"><span class="lineNum">    2978 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="2979"><span class="lineNum">    2979 </span>            :                                 9318_error,</a>
<a name="2980"><span class="lineNum">    2980 </span><span class="lineNoCov">          0 :                                 _functionCallOptions.location(),</span></a>
<a name="2981"><span class="lineNum">    2981 </span><span class="lineNoCov">          0 :                                 &quot;Unknown call option \&quot;&quot; + name + &quot;\&quot;. Valid options are \&quot;salt\&quot;, \&quot;value\&quot; and \&quot;gas\&quot;.&quot;</span></a>
<a name="2982"><span class="lineNum">    2982 </span>            :                         );</a>
<a name="2983"><span class="lineNum">    2983 </span>            :         }</a>
<a name="2984"><span class="lineNum">    2984 </span>            : </a>
<a name="2985"><span class="lineNum">    2985 </span><span class="lineCov">         19 :         if (setSalt &amp;&amp; !m_evmVersion.hasCreate2())</span></a>
<a name="2986"><span class="lineNum">    2986 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="2987"><span class="lineNum">    2987 </span>            :                         5189_error,</a>
<a name="2988"><span class="lineNum">    2988 </span><span class="lineNoCov">          0 :                         _functionCallOptions.location(),</span></a>
<a name="2989"><span class="lineNum">    2989 </span>            :                         &quot;Unsupported call option \&quot;salt\&quot; (requires Constantinople-compatible VMs).&quot;</a>
<a name="2990"><span class="lineNum">    2990 </span>            :                 );</a>
<a name="2991"><span class="lineNum">    2991 </span>            : </a>
<a name="2992"><span class="lineNum">    2992 </span><span class="lineCov">         19 :         _functionCallOptions.annotation().type = expressionFunctionType-&gt;copyAndSetCallOptions(setGas, setValue, setSalt);</span></a>
<a name="2993"><span class="lineNum">    2993 </span><span class="lineCov">         19 :         return false;</span></a>
<a name="2994"><span class="lineNum">    2994 </span>            : }</a>
<a name="2995"><span class="lineNum">    2995 </span>            : </a>
<a name="2996"><span class="lineNum">    2996 </span><span class="lineCov">        150 : void TypeChecker::endVisit(NewExpression const&amp; _newExpression)</span></a>
<a name="2997"><span class="lineNum">    2997 </span>            : {</a>
<a name="2998"><span class="lineNum">    2998 </span><span class="lineCov">        150 :         Type const* type = _newExpression.typeName().annotation().type;</span></a>
<a name="2999"><span class="lineNum">    2999 </span><span class="lineCov">        150 :         solAssert(!!type, &quot;Type name not resolved.&quot;);</span></a>
<a name="3000"><span class="lineNum">    3000 </span>            : </a>
<a name="3001"><span class="lineNum">    3001 </span><span class="lineCov">        150 :         _newExpression.annotation().isConstant = false;</span></a>
<a name="3002"><span class="lineNum">    3002 </span><span class="lineCov">        150 :         _newExpression.annotation().isLValue = false;</span></a>
<a name="3003"><span class="lineNum">    3003 </span>            : </a>
<a name="3004"><span class="lineNum">    3004 </span><span class="lineCov">        150 :         if (auto contractName = dynamic_cast&lt;UserDefinedTypeName const*&gt;(&amp;_newExpression.typeName()))</span></a>
<a name="3005"><span class="lineNum">    3005 </span>            :         {</a>
<a name="3006"><span class="lineNum">    3006 </span><span class="lineCov">         33 :                 auto contract = dynamic_cast&lt;ContractDefinition const*&gt;(&amp;dereference(contractName-&gt;pathNode()));</span></a>
<a name="3007"><span class="lineNum">    3007 </span>            : </a>
<a name="3008"><span class="lineNum">    3008 </span><span class="lineCov">         33 :                 if (!contract)</span></a>
<a name="3009"><span class="lineNum">    3009 </span><span class="lineCov">          6 :                         m_errorReporter.fatalTypeError(5540_error, _newExpression.location(), &quot;Identifier is not a contract.&quot;);</span></a>
<a name="3010"><span class="lineNum">    3010 </span><span class="lineCov">         31 :                 if (contract-&gt;isInterface())</span></a>
<a name="3011"><span class="lineNum">    3011 </span><span class="lineNoCov">          0 :                         m_errorReporter.fatalTypeError(2971_error, _newExpression.location(), &quot;Cannot instantiate an interface.&quot;);</span></a>
<a name="3012"><span class="lineNum">    3012 </span><span class="lineCov">         31 :                 if (contract-&gt;abstract())</span></a>
<a name="3013"><span class="lineNum">    3013 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(4614_error, _newExpression.location(), &quot;Cannot instantiate an abstract contract.&quot;);</span></a>
<a name="3014"><span class="lineNum">    3014 </span>            : </a>
<a name="3015"><span class="lineNum">    3015 </span><span class="lineCov">         31 :                 _newExpression.annotation().type = FunctionType::newExpressionType(*contract);</span></a>
<a name="3016"><span class="lineNum">    3016 </span><span class="lineCov">         31 :                 _newExpression.annotation().isPure = false;</span></a>
<a name="3017"><span class="lineNum">    3017 </span>            :         }</a>
<a name="3018"><span class="lineNum">    3018 </span><span class="lineCov">        117 :         else if (type-&gt;category() == Type::Category::Array)</span></a>
<a name="3019"><span class="lineNum">    3019 </span>            :         {</a>
<a name="3020"><span class="lineNum">    3020 </span><span class="lineCov">        115 :                 if (type-&gt;containsNestedMapping())</span></a>
<a name="3021"><span class="lineNum">    3021 </span><span class="lineNoCov">          0 :                         m_errorReporter.fatalTypeError(</span></a>
<a name="3022"><span class="lineNum">    3022 </span>            :                                 1164_error,</a>
<a name="3023"><span class="lineNum">    3023 </span><span class="lineNoCov">          0 :                                 _newExpression.typeName().location(),</span></a>
<a name="3024"><span class="lineNum">    3024 </span>            :                                 &quot;Array containing a (nested) mapping cannot be constructed in memory.&quot;</a>
<a name="3025"><span class="lineNum">    3025 </span>            :                         );</a>
<a name="3026"><span class="lineNum">    3026 </span><span class="lineCov">        115 :                 if (!type-&gt;isDynamicallySized())</span></a>
<a name="3027"><span class="lineNum">    3027 </span><span class="lineCov">         10 :                         m_errorReporter.typeError(</span></a>
<a name="3028"><span class="lineNum">    3028 </span>            :                                 3904_error,</a>
<a name="3029"><span class="lineNum">    3029 </span><span class="lineCov">          5 :                                 _newExpression.typeName().location(),</span></a>
<a name="3030"><span class="lineNum">    3030 </span>            :                                 &quot;Length has to be placed in parentheses after the array type for new expression.&quot;</a>
<a name="3031"><span class="lineNum">    3031 </span>            :                         );</a>
<a name="3032"><span class="lineNum">    3032 </span><span class="lineCov">        115 :                 type = TypeProvider::withLocationIfReference(DataLocation::Memory, type);</span></a>
<a name="3033"><span class="lineNum">    3033 </span><span class="lineCov">        115 :                 _newExpression.annotation().type = TypeProvider::function(</span></a>
<a name="3034"><span class="lineNum">    3034 </span><span class="lineCov">        230 :                         TypePointers{TypeProvider::uint256()},</span></a>
<a name="3035"><span class="lineNum">    3035 </span><span class="lineCov">        230 :                         TypePointers{type},</span></a>
<a name="3036"><span class="lineNum">    3036 </span><span class="lineCov">        230 :                         strings(1, &quot;&quot;),</span></a>
<a name="3037"><span class="lineNum">    3037 </span><span class="lineCov">        230 :                         strings(1, &quot;&quot;),</span></a>
<a name="3038"><span class="lineNum">    3038 </span>            :                         FunctionType::Kind::ObjectCreation,</a>
<a name="3039"><span class="lineNum">    3039 </span>            :                         StateMutability::Pure</a>
<a name="3040"><span class="lineNum">    3040 </span>            :                 );</a>
<a name="3041"><span class="lineNum">    3041 </span><span class="lineCov">        115 :                 _newExpression.annotation().isPure = true;</span></a>
<a name="3042"><span class="lineNum">    3042 </span>            :         }</a>
<a name="3043"><span class="lineNum">    3043 </span>            :         else</a>
<a name="3044"><span class="lineNum">    3044 </span>            :         {</a>
<a name="3045"><span class="lineNum">    3045 </span><span class="lineCov">          2 :                 _newExpression.annotation().isPure = false;</span></a>
<a name="3046"><span class="lineNum">    3046 </span><span class="lineCov">          4 :                 m_errorReporter.fatalTypeError(8807_error, _newExpression.location(), &quot;Contract or array type expected.&quot;);</span></a>
<a name="3047"><span class="lineNum">    3047 </span>            :         }</a>
<a name="3048"><span class="lineNum">    3048 </span><span class="lineCov">        146 : }</span></a>
<a name="3049"><span class="lineNum">    3049 </span>            : </a>
<a name="3050"><span class="lineNum">    3050 </span><span class="lineCov">        923 : bool TypeChecker::visit(MemberAccess const&amp; _memberAccess)</span></a>
<a name="3051"><span class="lineNum">    3051 </span>            : {</a>
<a name="3052"><span class="lineNum">    3052 </span><span class="lineCov">        923 :         _memberAccess.expression().accept(*this);</span></a>
<a name="3053"><span class="lineNum">    3053 </span><span class="lineCov">        854 :         Type const* exprType = type(_memberAccess.expression());</span></a>
<a name="3054"><span class="lineNum">    3054 </span><span class="lineCov">        854 :         ASTString const&amp; memberName = _memberAccess.memberName();</span></a>
<a name="3055"><span class="lineNum">    3055 </span>            : </a>
<a name="3056"><span class="lineNum">    3056 </span><span class="lineCov">        854 :         auto&amp; annotation = _memberAccess.annotation();</span></a>
<a name="3057"><span class="lineNum">    3057 </span>            : </a>
<a name="3058"><span class="lineNum">    3058 </span>            :         // Retrieve the types of the arguments if this is used to call a function.</a>
<a name="3059"><span class="lineNum">    3059 </span><span class="lineCov">        854 :         auto const&amp; arguments = annotation.arguments;</span></a>
<a name="3060"><span class="lineNum">    3060 </span><span class="lineCov">        992 :         MemberList::MemberMap possibleMembers = exprType-&gt;members(currentDefinitionScope()).membersByName(memberName);</span></a>
<a name="3061"><span class="lineNum">    3061 </span><span class="lineCov">        854 :         size_t const initialMemberCount = possibleMembers.size();</span></a>
<a name="3062"><span class="lineNum">    3062 </span><span class="lineCov">        854 :         if (initialMemberCount &gt; 1 &amp;&amp; arguments)</span></a>
<a name="3063"><span class="lineNum">    3063 </span>            :         {</a>
<a name="3064"><span class="lineNum">    3064 </span>            :                 // do overload resolution</a>
<a name="3065"><span class="lineNum">    3065 </span><span class="lineCov">        120 :                 for (auto it = possibleMembers.begin(); it != possibleMembers.end();)</span></a>
<a name="3066"><span class="lineNum">    3066 </span><span class="lineCov">         80 :                         if (</span></a>
<a name="3067"><span class="lineNum">    3067 </span><span class="lineCov">        160 :                                 it-&gt;type-&gt;category() == Type::Category::Function &amp;&amp;</span></a>
<a name="3068"><span class="lineNum">    3068 </span><span class="lineCov">         80 :                                 !dynamic_cast&lt;FunctionType const&amp;&gt;(*it-&gt;type).canTakeArguments(*arguments, exprType)</span></a>
<a name="3069"><span class="lineNum">    3069 </span>            :                         )</a>
<a name="3070"><span class="lineNum">    3070 </span><span class="lineCov">         44 :                                 it = possibleMembers.erase(it);</span></a>
<a name="3071"><span class="lineNum">    3071 </span>            :                         else</a>
<a name="3072"><span class="lineNum">    3072 </span><span class="lineCov">         36 :                                 ++it;</span></a>
<a name="3073"><span class="lineNum">    3073 </span>            :         }</a>
<a name="3074"><span class="lineNum">    3074 </span>            : </a>
<a name="3075"><span class="lineNum">    3075 </span><span class="lineCov">        854 :         annotation.isConstant = false;</span></a>
<a name="3076"><span class="lineNum">    3076 </span>            : </a>
<a name="3077"><span class="lineNum">    3077 </span><span class="lineCov">        854 :         if (possibleMembers.empty())</span></a>
<a name="3078"><span class="lineNum">    3078 </span>            :         {</a>
<a name="3079"><span class="lineNum">    3079 </span><span class="lineCov">        138 :                 if (initialMemberCount == 0 &amp;&amp; !dynamic_cast&lt;ArraySliceType const*&gt;(exprType))</span></a>
<a name="3080"><span class="lineNum">    3080 </span>            :                 {</a>
<a name="3081"><span class="lineNum">    3081 </span>            :                         // Try to see if the member was removed because it is only available for storage types.</a>
<a name="3082"><span class="lineNum">    3082 </span><span class="lineCov">        134 :                         auto storageType = TypeProvider::withLocationIfReference(</span></a>
<a name="3083"><span class="lineNum">    3083 </span>            :                                 DataLocation::Storage,</a>
<a name="3084"><span class="lineNum">    3084 </span>            :                                 exprType</a>
<a name="3085"><span class="lineNum">    3085 </span>            :                         );</a>
<a name="3086"><span class="lineNum">    3086 </span><span class="lineCov">        134 :                         if (!storageType-&gt;members(currentDefinitionScope()).membersByName(memberName).empty())</span></a>
<a name="3087"><span class="lineNum">    3087 </span><span class="lineCov">          6 :                                 m_errorReporter.fatalTypeError(</span></a>
<a name="3088"><span class="lineNum">    3088 </span>            :                                         4994_error,</a>
<a name="3089"><span class="lineNum">    3089 </span><span class="lineCov">          6 :                                         _memberAccess.location(),</span></a>
<a name="3090"><span class="lineNum">    3090 </span><span class="lineCov">         30 :                                         &quot;Member \&quot;&quot; + memberName + &quot;\&quot; is not available in &quot; +</span></a>
<a name="3091"><span class="lineNum">    3091 </span><span class="lineCov">         36 :                                         exprType-&gt;humanReadableName() +</span></a>
<a name="3092"><span class="lineNum">    3092 </span>            :                                         &quot; outside of storage.&quot;</a>
<a name="3093"><span class="lineNum">    3093 </span>            :                                 );</a>
<a name="3094"><span class="lineNum">    3094 </span>            :                 }</a>
<a name="3095"><span class="lineNum">    3095 </span>            : </a>
<a name="3096"><span class="lineNum">    3096 </span><span class="lineCov">        132 :                 auto [errorId, description] = [&amp;]() -&gt; std::tuple&lt;ErrorId, std::string&gt; {</span></a>
<a name="3097"><span class="lineNum">    3097 </span><span class="lineCov">        264 :                         std::string errorMsg = &quot;Member \&quot;&quot; + memberName + &quot;\&quot; not found or not visible &quot;</span></a>
<a name="3098"><span class="lineNum">    3098 </span><span class="lineCov">        528 :                                 &quot;after argument-dependent lookup in &quot; + exprType-&gt;humanReadableName() + &quot;.&quot;;</span></a>
<a name="3099"><span class="lineNum">    3099 </span>            : </a>
<a name="3100"><span class="lineNum">    3100 </span><span class="lineCov">        132 :                         if (auto const* funType = dynamic_cast&lt;FunctionType const*&gt;(exprType))</span></a>
<a name="3101"><span class="lineNum">    3101 </span>            :                         {</a>
<a name="3102"><span class="lineNum">    3102 </span><span class="lineCov">          5 :                                 TypePointers const&amp; t = funType-&gt;returnParameterTypes();</span></a>
<a name="3103"><span class="lineNum">    3103 </span>            : </a>
<a name="3104"><span class="lineNum">    3104 </span><span class="lineCov">          5 :                                 if (memberName == &quot;value&quot;)</span></a>
<a name="3105"><span class="lineNum">    3105 </span>            :                                 {</a>
<a name="3106"><span class="lineNum">    3106 </span><span class="lineCov">          1 :                                         if (funType-&gt;kind() == FunctionType::Kind::Creation)</span></a>
<a name="3107"><span class="lineNum">    3107 </span>            :                                                 return {</a>
<a name="3108"><span class="lineNum">    3108 </span><span class="lineNoCov">          0 :                                                         8827_error,</span></a>
<a name="3109"><span class="lineNum">    3109 </span><span class="lineNoCov">          0 :                                                         &quot;Constructor for &quot; + t.front()-&gt;humanReadableName() + &quot; must be payable for member \&quot;value\&quot; to be available.&quot;</span></a>
<a name="3110"><span class="lineNum">    3110 </span><span class="lineNoCov">          0 :                                                 };</span></a>
<a name="3111"><span class="lineNum">    3111 </span><span class="lineCov">          1 :                                         else if (</span></a>
<a name="3112"><span class="lineNum">    3112 </span><span class="lineCov">          2 :                                                 funType-&gt;kind() == FunctionType::Kind::DelegateCall ||</span></a>
<a name="3113"><span class="lineNum">    3113 </span><span class="lineCov">          1 :                                                 funType-&gt;kind() == FunctionType::Kind::BareDelegateCall</span></a>
<a name="3114"><span class="lineNum">    3114 </span>            :                                         )</a>
<a name="3115"><span class="lineNum">    3115 </span><span class="lineNoCov">          0 :                                                 return { 8477_error, &quot;Member \&quot;value\&quot; is not allowed in delegated calls due to \&quot;msg.value\&quot; persisting.&quot; };</span></a>
<a name="3116"><span class="lineNum">    3116 </span>            :                                         else</a>
<a name="3117"><span class="lineNum">    3117 </span><span class="lineCov">          2 :                                                 return { 8820_error, &quot;Member \&quot;value\&quot; is only available for payable functions.&quot; };</span></a>
<a name="3118"><span class="lineNum">    3118 </span>            :                                 }</a>
<a name="3119"><span class="lineNum">    3119 </span><span class="lineCov">          4 :                                 else if (</span></a>
<a name="3120"><span class="lineNum">    3120 </span><span class="lineCov">          7 :                                         t.size() == 1 &amp;&amp; (</span></a>
<a name="3121"><span class="lineNum">    3121 </span><span class="lineCov">          3 :                                                 t.front()-&gt;category() == Type::Category::Struct ||</span></a>
<a name="3122"><span class="lineNum">    3122 </span><span class="lineCov">          3 :                                                 t.front()-&gt;category() == Type::Category::Contract</span></a>
<a name="3123"><span class="lineNum">    3123 </span>            :                                         )</a>
<a name="3124"><span class="lineNum">    3124 </span>            :                                 )</a>
<a name="3125"><span class="lineNum">    3125 </span><span class="lineNoCov">          0 :                                         return { 6005_error, errorMsg + &quot; Did you intend to call the function?&quot; };</span></a>
<a name="3126"><span class="lineNum">    3126 </span>            :                         }</a>
<a name="3127"><span class="lineNum">    3127 </span><span class="lineCov">        127 :                         else if (exprType-&gt;category() == Type::Category::Contract)</span></a>
<a name="3128"><span class="lineNum">    3128 </span>            :                         {</a>
<a name="3129"><span class="lineNum">    3129 </span><span class="lineCov">        234 :                                 for (MemberList::Member const&amp; addressMember: TypeProvider::payableAddress()-&gt;nativeMembers(nullptr))</span></a>
<a name="3130"><span class="lineNum">    3130 </span><span class="lineCov">        211 :                                         if (addressMember.name == memberName)</span></a>
<a name="3131"><span class="lineNum">    3131 </span>            :                                         {</a>
<a name="3132"><span class="lineNum">    3132 </span><span class="lineCov">          4 :                                                 auto const* var = dynamic_cast&lt;Identifier const*&gt;(&amp;_memberAccess.expression());</span></a>
<a name="3133"><span class="lineNum">    3133 </span><span class="lineCov">          4 :                                                 std::string varName = var ? var-&gt;name() : &quot;...&quot;;</span></a>
<a name="3134"><span class="lineNum">    3134 </span><span class="lineCov">          4 :                                                 errorMsg += &quot; Use \&quot;address(&quot; + varName + &quot;).&quot; + memberName + &quot;\&quot; to access this address member.&quot;;</span></a>
<a name="3135"><span class="lineNum">    3135 </span><span class="lineCov">          8 :                                                 return { 3125_error, errorMsg };</span></a>
<a name="3136"><span class="lineNum">    3136 </span>            :                                         }</a>
<a name="3137"><span class="lineNum">    3137 </span>            :                         }</a>
<a name="3138"><span class="lineNum">    3138 </span><span class="lineCov">        100 :                         else if (auto const* addressType = dynamic_cast&lt;AddressType const*&gt;(exprType))</span></a>
<a name="3139"><span class="lineNum">    3139 </span>            :                         {</a>
<a name="3140"><span class="lineNum">    3140 </span>            :                                 // Trigger error when using send or transfer with a non-payable fallback function.</a>
<a name="3141"><span class="lineNum">    3141 </span><span class="lineCov">         19 :                                 if (memberName == &quot;send&quot; || memberName == &quot;transfer&quot;)</span></a>
<a name="3142"><span class="lineNum">    3142 </span>            :                                 {</a>
<a name="3143"><span class="lineNum">    3143 </span><span class="lineCov">         13 :                                         solAssert(</span></a>
<a name="3144"><span class="lineNum">    3144 </span>            :                                                 addressType-&gt;stateMutability() != StateMutability::Payable,</a>
<a name="3145"><span class="lineNum">    3145 </span>            :                                                 &quot;Expected address not-payable as members were not found&quot;</a>
<a name="3146"><span class="lineNum">    3146 </span>            :                                         );</a>
<a name="3147"><span class="lineNum">    3147 </span>            : </a>
<a name="3148"><span class="lineNum">    3148 </span><span class="lineCov">         26 :                                         return { 9862_error, &quot;\&quot;send\&quot; and \&quot;transfer\&quot; are only available for objects of type \&quot;address payable\&quot;, not \&quot;&quot; + exprType-&gt;humanReadableName() + &quot;\&quot;.&quot; };</span></a>
<a name="3149"><span class="lineNum">    3149 </span>            :                                 }</a>
<a name="3150"><span class="lineNum">    3150 </span>            :                         }</a>
<a name="3151"><span class="lineNum">    3151 </span>            : </a>
<a name="3152"><span class="lineNum">    3152 </span><span class="lineCov">        228 :                         return { 9582_error, errorMsg };</span></a>
<a name="3153"><span class="lineNum">    3153 </span><span class="lineCov">        264 :                 }();</span></a>
<a name="3154"><span class="lineNum">    3154 </span>            : </a>
<a name="3155"><span class="lineNum">    3155 </span><span class="lineCov">        132 :                 m_errorReporter.fatalTypeError(</span></a>
<a name="3156"><span class="lineNum">    3156 </span>            :                         errorId,</a>
<a name="3157"><span class="lineNum">    3157 </span><span class="lineCov">        132 :                         _memberAccess.location(),</span></a>
<a name="3158"><span class="lineNum">    3158 </span>            :                         description</a>
<a name="3159"><span class="lineNum">    3159 </span>            :                 );</a>
<a name="3160"><span class="lineNum">    3160 </span>            :         }</a>
<a name="3161"><span class="lineNum">    3161 </span><span class="lineCov">        716 :         else if (possibleMembers.size() &gt; 1)</span></a>
<a name="3162"><span class="lineNum">    3162 </span><span class="lineNoCov">          0 :                 m_errorReporter.fatalTypeError(</span></a>
<a name="3163"><span class="lineNum">    3163 </span>            :                         6675_error,</a>
<a name="3164"><span class="lineNum">    3164 </span><span class="lineNoCov">          0 :                         _memberAccess.location(),</span></a>
<a name="3165"><span class="lineNum">    3165 </span><span class="lineNoCov">          0 :                         &quot;Member \&quot;&quot; + memberName + &quot;\&quot; not unique &quot;</span></a>
<a name="3166"><span class="lineNum">    3166 </span><span class="lineNoCov">          0 :                         &quot;after argument-dependent lookup in &quot; + exprType-&gt;humanReadableName() +</span></a>
<a name="3167"><span class="lineNum">    3167 </span><span class="lineNoCov">          0 :                         (memberName == &quot;value&quot; ? &quot; - did you forget the \&quot;payable\&quot; modifier?&quot; : &quot;.&quot;)</span></a>
<a name="3168"><span class="lineNum">    3168 </span>            :                 );</a>
<a name="3169"><span class="lineNum">    3169 </span>            : </a>
<a name="3170"><span class="lineNum">    3170 </span><span class="lineCov">        716 :         annotation.referencedDeclaration = possibleMembers.front().declaration;</span></a>
<a name="3171"><span class="lineNum">    3171 </span><span class="lineCov">        716 :         annotation.type = possibleMembers.front().type;</span></a>
<a name="3172"><span class="lineNum">    3172 </span>            : </a>
<a name="3173"><span class="lineNum">    3173 </span><span class="lineCov">        716 :         VirtualLookup requiredLookup = VirtualLookup::Static;</span></a>
<a name="3174"><span class="lineNum">    3174 </span>            : </a>
<a name="3175"><span class="lineNum">    3175 </span><span class="lineCov">        716 :         if (auto funType = dynamic_cast&lt;FunctionType const*&gt;(annotation.type))</span></a>
<a name="3176"><span class="lineNum">    3176 </span>            :         {</a>
<a name="3177"><span class="lineNum">    3177 </span><span class="lineCov">        288 :                 solAssert(</span></a>
<a name="3178"><span class="lineNum">    3178 </span>            :                         !funType-&gt;hasBoundFirstArgument() || exprType-&gt;isImplicitlyConvertibleTo(*funType-&gt;selfType()),</a>
<a name="3179"><span class="lineNum">    3179 </span>            :                         &quot;Function \&quot;&quot; + memberName + &quot;\&quot; cannot be called on an object of type &quot; +</a>
<a name="3180"><span class="lineNum">    3180 </span>            :                         exprType-&gt;humanReadableName() + &quot; (expected &quot; + funType-&gt;selfType()-&gt;humanReadableName() + &quot;).&quot;</a>
<a name="3181"><span class="lineNum">    3181 </span>            :                 );</a>
<a name="3182"><span class="lineNum">    3182 </span>            : </a>
<a name="3183"><span class="lineNum">    3183 </span><span class="lineCov">        288 :                 if (</span></a>
<a name="3184"><span class="lineNum">    3184 </span><span class="lineCov">        288 :                         dynamic_cast&lt;FunctionType const*&gt;(exprType) &amp;&amp;</span></a>
<a name="3185"><span class="lineNum">    3185 </span><span class="lineCov">        290 :                         !annotation.referencedDeclaration &amp;&amp;</span></a>
<a name="3186"><span class="lineNum">    3186 </span><span class="lineCov">          2 :                         (memberName == &quot;value&quot; || memberName == &quot;gas&quot;)</span></a>
<a name="3187"><span class="lineNum">    3187 </span>            :                 )</a>
<a name="3188"><span class="lineNum">    3188 </span><span class="lineCov">          2 :                         m_errorReporter.typeError(</span></a>
<a name="3189"><span class="lineNum">    3189 </span>            :                                 1621_error,</a>
<a name="3190"><span class="lineNum">    3190 </span><span class="lineCov">          2 :                                 _memberAccess.location(),</span></a>
<a name="3191"><span class="lineNum">    3191 </span><span class="lineCov">          4 :                                 &quot;Using \&quot;.&quot; + memberName + &quot;(...)\&quot; is deprecated. Use \&quot;{&quot; + memberName + &quot;: ...}\&quot; instead.&quot;</span></a>
<a name="3192"><span class="lineNum">    3192 </span>            :                         );</a>
<a name="3193"><span class="lineNum">    3193 </span>            : </a>
<a name="3194"><span class="lineNum">    3194 </span><span class="lineCov">        288 :                 if (</span></a>
<a name="3195"><span class="lineNum">    3195 </span><span class="lineCov">        323 :                         funType-&gt;kind() == FunctionType::Kind::ArrayPush &amp;&amp;</span></a>
<a name="3196"><span class="lineNum">    3196 </span><span class="lineCov">        323 :                         arguments.value().numArguments() != 0 &amp;&amp;</span></a>
<a name="3197"><span class="lineNum">    3197 </span><span class="lineCov">         35 :                         exprType-&gt;containsNestedMapping()</span></a>
<a name="3198"><span class="lineNum">    3198 </span>            :                 )</a>
<a name="3199"><span class="lineNum">    3199 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="3200"><span class="lineNum">    3200 </span>            :                                 8871_error,</a>
<a name="3201"><span class="lineNum">    3201 </span><span class="lineNoCov">          0 :                                 _memberAccess.location(),</span></a>
<a name="3202"><span class="lineNum">    3202 </span>            :                                 &quot;Storage arrays with nested mappings do not support .push(&lt;arg&gt;).&quot;</a>
<a name="3203"><span class="lineNum">    3203 </span>            :                         );</a>
<a name="3204"><span class="lineNum">    3204 </span>            : </a>
<a name="3205"><span class="lineNum">    3205 </span><span class="lineCov">        288 :                 if (!funType-&gt;hasBoundFirstArgument())</span></a>
<a name="3206"><span class="lineNum">    3206 </span><span class="lineCov">        252 :                         if (auto typeType = dynamic_cast&lt;TypeType const*&gt;(exprType))</span></a>
<a name="3207"><span class="lineNum">    3207 </span>            :                         {</a>
<a name="3208"><span class="lineNum">    3208 </span><span class="lineCov">         59 :                                 auto contractType = dynamic_cast&lt;ContractType const*&gt;(typeType-&gt;actualType());</span></a>
<a name="3209"><span class="lineNum">    3209 </span><span class="lineCov">         59 :                                 if (contractType &amp;&amp; contractType-&gt;isSuper())</span></a>
<a name="3210"><span class="lineNum">    3210 </span><span class="lineNoCov">          0 :                                         requiredLookup = VirtualLookup::Super;</span></a>
<a name="3211"><span class="lineNum">    3211 </span>            :                         }</a>
<a name="3212"><span class="lineNum">    3212 </span>            :         }</a>
<a name="3213"><span class="lineNum">    3213 </span>            : </a>
<a name="3214"><span class="lineNum">    3214 </span><span class="lineCov">        716 :         annotation.requiredLookup = requiredLookup;</span></a>
<a name="3215"><span class="lineNum">    3215 </span>            : </a>
<a name="3216"><span class="lineNum">    3216 </span><span class="lineCov">        716 :         if (auto const* structType = dynamic_cast&lt;StructType const*&gt;(exprType))</span></a>
<a name="3217"><span class="lineNum">    3217 </span><span class="lineCov">        117 :                 annotation.isLValue = !structType-&gt;dataStoredIn(DataLocation::CallData);</span></a>
<a name="3218"><span class="lineNum">    3218 </span><span class="lineCov">        599 :         else if (exprType-&gt;category() == Type::Category::Array)</span></a>
<a name="3219"><span class="lineNum">    3219 </span><span class="lineCov">         91 :                 annotation.isLValue = false;</span></a>
<a name="3220"><span class="lineNum">    3220 </span><span class="lineCov">        508 :         else if (exprType-&gt;category() == Type::Category::FixedBytes)</span></a>
<a name="3221"><span class="lineNum">    3221 </span><span class="lineCov">          3 :                 annotation.isLValue = false;</span></a>
<a name="3222"><span class="lineNum">    3222 </span><span class="lineCov">        505 :         else if (TypeType const* typeType = dynamic_cast&lt;decltype(typeType)&gt;(exprType))</span></a>
<a name="3223"><span class="lineNum">    3223 </span>            :         {</a>
<a name="3224"><span class="lineNum">    3224 </span><span class="lineCov">         70 :                 if (ContractType const* contractType = dynamic_cast&lt;decltype(contractType)&gt;(typeType-&gt;actualType()))</span></a>
<a name="3225"><span class="lineNum">    3225 </span>            :                 {</a>
<a name="3226"><span class="lineNum">    3226 </span><span class="lineCov">         65 :                         annotation.isLValue = annotation.referencedDeclaration-&gt;isLValue();</span></a>
<a name="3227"><span class="lineNum">    3227 </span><span class="lineCov">         65 :                         if (</span></a>
<a name="3228"><span class="lineNum">    3228 </span><span class="lineCov">         65 :                                 auto const* functionType = dynamic_cast&lt;FunctionType const*&gt;(annotation.type);</span></a>
<a name="3229"><span class="lineNum">    3229 </span><span class="lineCov">        123 :                                 functionType &amp;&amp;</span></a>
<a name="3230"><span class="lineNum">    3230 </span><span class="lineCov">         58 :                                 functionType-&gt;kind() == FunctionType::Kind::Declaration</span></a>
<a name="3231"><span class="lineNum">    3231 </span>            :                         )</a>
<a name="3232"><span class="lineNum">    3232 </span><span class="lineCov">          6 :                                 annotation.isPure = *_memberAccess.expression().annotation().isPure;</span></a>
<a name="3233"><span class="lineNum">    3233 </span>            :                 }</a>
<a name="3234"><span class="lineNum">    3234 </span>            :                 else</a>
<a name="3235"><span class="lineNum">    3235 </span><span class="lineCov">          5 :                         annotation.isLValue = false;</span></a>
<a name="3236"><span class="lineNum">    3236 </span>            :         }</a>
<a name="3237"><span class="lineNum">    3237 </span><span class="lineCov">        435 :         else if (exprType-&gt;category() == Type::Category::Module)</span></a>
<a name="3238"><span class="lineNum">    3238 </span>            :         {</a>
<a name="3239"><span class="lineNum">    3239 </span><span class="lineNoCov">          0 :                 annotation.isPure = *_memberAccess.expression().annotation().isPure;</span></a>
<a name="3240"><span class="lineNum">    3240 </span><span class="lineNoCov">          0 :                 annotation.isLValue = false;</span></a>
<a name="3241"><span class="lineNum">    3241 </span>            :         }</a>
<a name="3242"><span class="lineNum">    3242 </span>            :         else</a>
<a name="3243"><span class="lineNum">    3243 </span><span class="lineCov">        435 :                 annotation.isLValue = false;</span></a>
<a name="3244"><span class="lineNum">    3244 </span>            : </a>
<a name="3245"><span class="lineNum">    3245 </span>            :         // TODO some members might be pure, but for example `address(0x123).balance` is not pure</a>
<a name="3246"><span class="lineNum">    3246 </span>            :         // although every subexpression is, so leaving this limited for now.</a>
<a name="3247"><span class="lineNum">    3247 </span><span class="lineCov">        716 :         if (auto tt = dynamic_cast&lt;TypeType const*&gt;(exprType))</span></a>
<a name="3248"><span class="lineNum">    3248 </span><span class="lineCov">         70 :                 if (</span></a>
<a name="3249"><span class="lineNum">    3249 </span><span class="lineCov">        136 :                         tt-&gt;actualType()-&gt;category() == Type::Category::Enum ||</span></a>
<a name="3250"><span class="lineNum">    3250 </span><span class="lineCov">         66 :                         tt-&gt;actualType()-&gt;category() == Type::Category::UserDefinedValueType</span></a>
<a name="3251"><span class="lineNum">    3251 </span>            :                 )</a>
<a name="3252"><span class="lineNum">    3252 </span><span class="lineCov">          4 :                         annotation.isPure = true;</span></a>
<a name="3253"><span class="lineNum">    3253 </span><span class="lineCov">        716 :         if (</span></a>
<a name="3254"><span class="lineNum">    3254 </span><span class="lineCov">        716 :                 auto const* functionType = dynamic_cast&lt;FunctionType const*&gt;(exprType);</span></a>
<a name="3255"><span class="lineNum">    3255 </span><span class="lineCov">          3 :                 functionType &amp;&amp;</span></a>
<a name="3256"><span class="lineNum">    3256 </span><span class="lineCov">          4 :                 functionType-&gt;hasDeclaration() &amp;&amp;</span></a>
<a name="3257"><span class="lineNum">    3257 </span><span class="lineCov">        720 :                 dynamic_cast&lt;FunctionDefinition const*&gt;(&amp;functionType-&gt;declaration()) &amp;&amp;</span></a>
<a name="3258"><span class="lineNum">    3258 </span><span class="lineCov">          1 :                 memberName == &quot;selector&quot;</span></a>
<a name="3259"><span class="lineNum">    3259 </span>            :         )</a>
<a name="3260"><span class="lineNum">    3260 </span><span class="lineCov">          1 :                 if (auto const* parentAccess = dynamic_cast&lt;MemberAccess const*&gt;(&amp;_memberAccess.expression()))</span></a>
<a name="3261"><span class="lineNum">    3261 </span>            :                 {</a>
<a name="3262"><span class="lineNum">    3262 </span><span class="lineCov">          1 :                         bool isPure = *parentAccess-&gt;expression().annotation().isPure;</span></a>
<a name="3263"><span class="lineNum">    3263 </span><span class="lineCov">          1 :                         if (auto const* exprInt = dynamic_cast&lt;Identifier const*&gt;(&amp;parentAccess-&gt;expression()))</span></a>
<a name="3264"><span class="lineNum">    3264 </span><span class="lineCov">          1 :                                 if (exprInt-&gt;name() == &quot;this&quot; || exprInt-&gt;name() == &quot;super&quot;)</span></a>
<a name="3265"><span class="lineNum">    3265 </span><span class="lineNoCov">          0 :                                         isPure = true;</span></a>
<a name="3266"><span class="lineNum">    3266 </span>            : </a>
<a name="3267"><span class="lineNum">    3267 </span><span class="lineCov">          1 :                         annotation.isPure = isPure;</span></a>
<a name="3268"><span class="lineNum">    3268 </span>            :                 }</a>
<a name="3269"><span class="lineNum">    3269 </span><span class="lineCov">        716 :         if (</span></a>
<a name="3270"><span class="lineNum">    3270 </span><span class="lineCov">        716 :                 auto const* varDecl = dynamic_cast&lt;VariableDeclaration const*&gt;(annotation.referencedDeclaration);</span></a>
<a name="3271"><span class="lineNum">    3271 </span><span class="lineCov">       1421 :                 !annotation.isPure.set() &amp;&amp;</span></a>
<a name="3272"><span class="lineNum">    3272 </span><span class="lineCov">       1421 :                 varDecl &amp;&amp;</span></a>
<a name="3273"><span class="lineNum">    3273 </span><span class="lineCov">        143 :                 varDecl-&gt;isConstant()</span></a>
<a name="3274"><span class="lineNum">    3274 </span>            :         )</a>
<a name="3275"><span class="lineNum">    3275 </span><span class="lineCov">          4 :                 annotation.isPure = true;</span></a>
<a name="3276"><span class="lineNum">    3276 </span>            : </a>
<a name="3277"><span class="lineNum">    3277 </span><span class="lineCov">        716 :         if (auto magicType = dynamic_cast&lt;MagicType const*&gt;(exprType))</span></a>
<a name="3278"><span class="lineNum">    3278 </span>            :         {</a>
<a name="3279"><span class="lineNum">    3279 </span><span class="lineCov">        263 :                 if (magicType-&gt;kind() == MagicType::Kind::ABI)</span></a>
<a name="3280"><span class="lineNum">    3280 </span><span class="lineCov">         41 :                         annotation.isPure = true;</span></a>
<a name="3281"><span class="lineNum">    3281 </span><span class="lineCov">        272 :                 else if (magicType-&gt;kind() == MagicType::Kind::MetaType &amp;&amp; (</span></a>
<a name="3282"><span class="lineNum">    3282 </span><span class="lineCov">         50 :                         memberName == &quot;creationCode&quot; || memberName == &quot;runtimeCode&quot;</span></a>
<a name="3283"><span class="lineNum">    3283 </span>            :                 ))</a>
<a name="3284"><span class="lineNum">    3284 </span>            :                 {</a>
<a name="3285"><span class="lineNum">    3285 </span><span class="lineNoCov">          0 :                         annotation.isPure = true;</span></a>
<a name="3286"><span class="lineNum">    3286 </span><span class="lineNoCov">          0 :                         ContractType const&amp; accessedContractType = dynamic_cast&lt;ContractType const&amp;&gt;(*magicType-&gt;typeArgument());</span></a>
<a name="3287"><span class="lineNum">    3287 </span><span class="lineNoCov">          0 :                         solAssert(!accessedContractType.isSuper(), &quot;&quot;);</span></a>
<a name="3288"><span class="lineNum">    3288 </span><span class="lineNoCov">          0 :                         if (</span></a>
<a name="3289"><span class="lineNum">    3289 </span><span class="lineNoCov">          0 :                                 memberName == &quot;runtimeCode&quot; &amp;&amp;</span></a>
<a name="3290"><span class="lineNum">    3290 </span><span class="lineNoCov">          0 :                                 !accessedContractType.immutableVariables().empty()</span></a>
<a name="3291"><span class="lineNum">    3291 </span>            :                         )</a>
<a name="3292"><span class="lineNum">    3292 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3293"><span class="lineNum">    3293 </span>            :                                         9274_error,</a>
<a name="3294"><span class="lineNum">    3294 </span><span class="lineNoCov">          0 :                                         _memberAccess.location(),</span></a>
<a name="3295"><span class="lineNum">    3295 </span>            :                                         &quot;\&quot;runtimeCode\&quot; is not available for contracts containing immutable variables.&quot;</a>
<a name="3296"><span class="lineNum">    3296 </span>            :                                 );</a>
<a name="3297"><span class="lineNum">    3297 </span>            :                 }</a>
<a name="3298"><span class="lineNum">    3298 </span><span class="lineCov">        222 :                 else if (magicType-&gt;kind() == MagicType::Kind::MetaType &amp;&amp; memberName == &quot;name&quot;)</span></a>
<a name="3299"><span class="lineNum">    3299 </span><span class="lineNoCov">          0 :                         annotation.isPure = true;</span></a>
<a name="3300"><span class="lineNum">    3300 </span><span class="lineCov">        222 :                 else if (magicType-&gt;kind() == MagicType::Kind::MetaType &amp;&amp; memberName == &quot;interfaceId&quot;)</span></a>
<a name="3301"><span class="lineNum">    3301 </span><span class="lineNoCov">          0 :                         annotation.isPure = true;</span></a>
<a name="3302"><span class="lineNum">    3302 </span><span class="lineCov">        222 :                 else if (</span></a>
<a name="3303"><span class="lineNum">    3303 </span><span class="lineCov">        272 :                         magicType-&gt;kind() == MagicType::Kind::MetaType &amp;&amp;</span></a>
<a name="3304"><span class="lineNum">    3304 </span><span class="lineCov">         50 :                         (memberName == &quot;min&quot; || memberName == &quot;max&quot;)</span></a>
<a name="3305"><span class="lineNum">    3305 </span>            :                 )</a>
<a name="3306"><span class="lineNum">    3306 </span><span class="lineCov">         25 :                         annotation.isPure = true;</span></a>
<a name="3307"><span class="lineNum">    3307 </span><span class="lineCov">        197 :                 else if (magicType-&gt;kind() == MagicType::Kind::Block)</span></a>
<a name="3308"><span class="lineNum">    3308 </span>            :                 {</a>
<a name="3309"><span class="lineNum">    3309 </span><span class="lineCov">          2 :                         if (memberName == &quot;chainid&quot; &amp;&amp; !m_evmVersion.hasChainID())</span></a>
<a name="3310"><span class="lineNum">    3310 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3311"><span class="lineNum">    3311 </span>            :                                         3081_error,</a>
<a name="3312"><span class="lineNum">    3312 </span><span class="lineNoCov">          0 :                                         _memberAccess.location(),</span></a>
<a name="3313"><span class="lineNum">    3313 </span>            :                                         &quot;\&quot;chainid\&quot; is not supported by the VM version.&quot;</a>
<a name="3314"><span class="lineNum">    3314 </span>            :                                 );</a>
<a name="3315"><span class="lineNum">    3315 </span><span class="lineCov">          2 :                         else if (memberName == &quot;basefee&quot; &amp;&amp; !m_evmVersion.hasBaseFee())</span></a>
<a name="3316"><span class="lineNum">    3316 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3317"><span class="lineNum">    3317 </span>            :                                         5921_error,</a>
<a name="3318"><span class="lineNum">    3318 </span><span class="lineNoCov">          0 :                                         _memberAccess.location(),</span></a>
<a name="3319"><span class="lineNum">    3319 </span>            :                                         &quot;\&quot;basefee\&quot; is not supported by the VM version.&quot;</a>
<a name="3320"><span class="lineNum">    3320 </span>            :                                 );</a>
<a name="3321"><span class="lineNum">    3321 </span><span class="lineCov">          2 :                         else if (memberName == &quot;blobbasefee&quot; &amp;&amp; !m_evmVersion.hasBlobBaseFee())</span></a>
<a name="3322"><span class="lineNum">    3322 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3323"><span class="lineNum">    3323 </span>            :                                         1006_error,</a>
<a name="3324"><span class="lineNum">    3324 </span><span class="lineNoCov">          0 :                                         _memberAccess.location(),</span></a>
<a name="3325"><span class="lineNum">    3325 </span>            :                                         &quot;\&quot;blobbasefee\&quot; is not supported by the VM version.&quot;</a>
<a name="3326"><span class="lineNum">    3326 </span>            :                                 );</a>
<a name="3327"><span class="lineNum">    3327 </span><span class="lineCov">          2 :                         else if (memberName == &quot;prevrandao&quot; &amp;&amp; !m_evmVersion.hasPrevRandao())</span></a>
<a name="3328"><span class="lineNum">    3328 </span><span class="lineNoCov">          0 :                                 m_errorReporter.warning(</span></a>
<a name="3329"><span class="lineNum">    3329 </span>            :                                         9432_error,</a>
<a name="3330"><span class="lineNum">    3330 </span><span class="lineNoCov">          0 :                                         _memberAccess.location(),</span></a>
<a name="3331"><span class="lineNum">    3331 </span>            :                                         &quot;\&quot;prevrandao\&quot; is not supported by the VM version and will be treated as \&quot;difficulty\&quot;.&quot;</a>
<a name="3332"><span class="lineNum">    3332 </span>            :                                 );</a>
<a name="3333"><span class="lineNum">    3333 </span><span class="lineCov">          2 :                         else if (memberName == &quot;difficulty&quot; &amp;&amp; m_evmVersion.hasPrevRandao())</span></a>
<a name="3334"><span class="lineNum">    3334 </span><span class="lineNoCov">          0 :                                 m_errorReporter.warning(</span></a>
<a name="3335"><span class="lineNum">    3335 </span>            :                                         8417_error,</a>
<a name="3336"><span class="lineNum">    3336 </span><span class="lineNoCov">          0 :                                         _memberAccess.location(),</span></a>
<a name="3337"><span class="lineNum">    3337 </span>            :                                         &quot;Since the VM version paris, \&quot;difficulty\&quot; was replaced by \&quot;prevrandao\&quot;, which now returns a random number based on the beacon chain.&quot;</a>
<a name="3338"><span class="lineNum">    3338 </span>            :                                 );</a>
<a name="3339"><span class="lineNum">    3339 </span>            :                 }</a>
<a name="3340"><span class="lineNum">    3340 </span>            :         }</a>
<a name="3341"><span class="lineNum">    3341 </span>            : </a>
<a name="3342"><span class="lineNum">    3342 </span><span class="lineCov">        716 :         if (</span></a>
<a name="3343"><span class="lineNum">    3343 </span><span class="lineCov">        769 :                 _memberAccess.expression().annotation().type-&gt;category() == Type::Category::Address &amp;&amp;</span></a>
<a name="3344"><span class="lineNum">    3344 </span><span class="lineCov">        769 :                 memberName == &quot;codehash&quot; &amp;&amp;</span></a>
<a name="3345"><span class="lineNum">    3345 </span><span class="lineNoCov">          0 :                 !m_evmVersion.hasExtCodeHash()</span></a>
<a name="3346"><span class="lineNum">    3346 </span>            :         )</a>
<a name="3347"><span class="lineNum">    3347 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="3348"><span class="lineNum">    3348 </span>            :                         7598_error,</a>
<a name="3349"><span class="lineNum">    3349 </span><span class="lineNoCov">          0 :                         _memberAccess.location(),</span></a>
<a name="3350"><span class="lineNum">    3350 </span>            :                         &quot;\&quot;codehash\&quot; is not supported by the VM version.&quot;</a>
<a name="3351"><span class="lineNum">    3351 </span>            :                 );</a>
<a name="3352"><span class="lineNum">    3352 </span>            : </a>
<a name="3353"><span class="lineNum">    3353 </span><span class="lineCov">        716 :         if (!annotation.isPure.set())</span></a>
<a name="3354"><span class="lineNum">    3354 </span><span class="lineCov">        635 :                 annotation.isPure = false;</span></a>
<a name="3355"><span class="lineNum">    3355 </span>            : </a>
<a name="3356"><span class="lineNum">    3356 </span><span class="lineCov">       1432 :         return false;</span></a>
<a name="3357"><span class="lineNum">    3357 </span>            : }</a>
<a name="3358"><span class="lineNum">    3358 </span>            : </a>
<a name="3359"><span class="lineNum">    3359 </span><span class="lineCov">        692 : bool TypeChecker::visit(IndexAccess const&amp; _access)</span></a>
<a name="3360"><span class="lineNum">    3360 </span>            : {</a>
<a name="3361"><span class="lineNum">    3361 </span><span class="lineCov">        692 :         _access.annotation().isConstant = false;</span></a>
<a name="3362"><span class="lineNum">    3362 </span><span class="lineCov">        692 :         _access.baseExpression().accept(*this);</span></a>
<a name="3363"><span class="lineNum">    3363 </span><span class="lineCov">        690 :         Type const* baseType = type(_access.baseExpression());</span></a>
<a name="3364"><span class="lineNum">    3364 </span><span class="lineCov">        690 :         Type const* resultType = nullptr;</span></a>
<a name="3365"><span class="lineNum">    3365 </span><span class="lineCov">        690 :         bool isLValue = false;</span></a>
<a name="3366"><span class="lineNum">    3366 </span><span class="lineCov">        690 :         bool isPure = *_access.baseExpression().annotation().isPure;</span></a>
<a name="3367"><span class="lineNum">    3367 </span><span class="lineCov">        690 :         Expression const* index = _access.indexExpression();</span></a>
<a name="3368"><span class="lineNum">    3368 </span><span class="lineCov">        690 :         switch (baseType-&gt;category())</span></a>
<a name="3369"><span class="lineNum">    3369 </span>            :         {</a>
<a name="3370"><span class="lineNum">    3370 </span><span class="lineNoCov">          0 :         case Type::Category::ArraySlice:</span></a>
<a name="3371"><span class="lineNum">    3371 </span>            :         {</a>
<a name="3372"><span class="lineNum">    3372 </span><span class="lineNoCov">          0 :                 auto const&amp; arrayType = dynamic_cast&lt;ArraySliceType const&amp;&gt;(*baseType).arrayType();</span></a>
<a name="3373"><span class="lineNum">    3373 </span><span class="lineNoCov">          0 :                 if (arrayType.location() != DataLocation::CallData || !arrayType.isDynamicallySized())</span></a>
<a name="3374"><span class="lineNum">    3374 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(4802_error, _access.location(), &quot;Index access is only implemented for slices of dynamic calldata arrays.&quot;);</span></a>
<a name="3375"><span class="lineNum">    3375 </span><span class="lineNoCov">          0 :                 baseType = &amp;arrayType;</span></a>
<a name="3376"><span class="lineNum">    3376 </span>            :                 [[fallthrough]];</a>
<a name="3377"><span class="lineNum">    3377 </span>            :         }</a>
<a name="3378"><span class="lineNum">    3378 </span><span class="lineCov">        314 :         case Type::Category::Array:</span></a>
<a name="3379"><span class="lineNum">    3379 </span>            :         {</a>
<a name="3380"><span class="lineNum">    3380 </span><span class="lineCov">        314 :                 ArrayType const&amp; actualType = dynamic_cast&lt;ArrayType const&amp;&gt;(*baseType);</span></a>
<a name="3381"><span class="lineNum">    3381 </span><span class="lineCov">        314 :                 if (!index)</span></a>
<a name="3382"><span class="lineNum">    3382 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(9689_error, _access.location(), &quot;Index expression cannot be omitted.&quot;);</span></a>
<a name="3383"><span class="lineNum">    3383 </span><span class="lineCov">        314 :                 else if (actualType.isString())</span></a>
<a name="3384"><span class="lineNum">    3384 </span>            :                 {</a>
<a name="3385"><span class="lineNum">    3385 </span><span class="lineCov">          1 :                         m_errorReporter.typeError(9961_error, _access.location(), &quot;Index access for string is not possible.&quot;);</span></a>
<a name="3386"><span class="lineNum">    3386 </span><span class="lineCov">          1 :                         index-&gt;accept(*this);</span></a>
<a name="3387"><span class="lineNum">    3387 </span>            :                 }</a>
<a name="3388"><span class="lineNum">    3388 </span>            :                 else</a>
<a name="3389"><span class="lineNum">    3389 </span>            :                 {</a>
<a name="3390"><span class="lineNum">    3390 </span><span class="lineCov">        313 :                         expectType(*index, *TypeProvider::uint256());</span></a>
<a name="3391"><span class="lineNum">    3391 </span><span class="lineCov">        313 :                         if (!m_errorReporter.hasErrors())</span></a>
<a name="3392"><span class="lineNum">    3392 </span><span class="lineCov">        217 :                                 if (auto numberType = dynamic_cast&lt;RationalNumberType const*&gt;(type(*index)))</span></a>
<a name="3393"><span class="lineNum">    3393 </span>            :                                 {</a>
<a name="3394"><span class="lineNum">    3394 </span><span class="lineCov">        160 :                                         solAssert(!numberType-&gt;isFractional(), &quot;&quot;);</span></a>
<a name="3395"><span class="lineNum">    3395 </span><span class="lineCov">        160 :                                         if (!actualType.isDynamicallySized() &amp;&amp; actualType.length() &lt;= numberType-&gt;literalValue(nullptr))</span></a>
<a name="3396"><span class="lineNum">    3396 </span><span class="lineCov">          3 :                                                 m_errorReporter.typeError(3383_error, _access.location(), &quot;Out of bounds array access.&quot;);</span></a>
<a name="3397"><span class="lineNum">    3397 </span>            :                                 }</a>
<a name="3398"><span class="lineNum">    3398 </span>            :                 }</a>
<a name="3399"><span class="lineNum">    3399 </span><span class="lineCov">        314 :                 resultType = actualType.baseType();</span></a>
<a name="3400"><span class="lineNum">    3400 </span><span class="lineCov">        314 :                 isLValue = actualType.location() != DataLocation::CallData;</span></a>
<a name="3401"><span class="lineNum">    3401 </span><span class="lineCov">        314 :                 break;</span></a>
<a name="3402"><span class="lineNum">    3402 </span>            :         }</a>
<a name="3403"><span class="lineNum">    3403 </span><span class="lineCov">        358 :         case Type::Category::Mapping:</span></a>
<a name="3404"><span class="lineNum">    3404 </span>            :         {</a>
<a name="3405"><span class="lineNum">    3405 </span><span class="lineCov">        358 :                 MappingType const&amp; actualType = dynamic_cast&lt;MappingType const&amp;&gt;(*baseType);</span></a>
<a name="3406"><span class="lineNum">    3406 </span><span class="lineCov">        358 :                 if (!index)</span></a>
<a name="3407"><span class="lineNum">    3407 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(1267_error, _access.location(), &quot;Index expression cannot be omitted.&quot;);</span></a>
<a name="3408"><span class="lineNum">    3408 </span>            :                 else</a>
<a name="3409"><span class="lineNum">    3409 </span><span class="lineCov">        358 :                         expectType(*index, *actualType.keyType());</span></a>
<a name="3410"><span class="lineNum">    3410 </span><span class="lineCov">        357 :                 resultType = actualType.valueType();</span></a>
<a name="3411"><span class="lineNum">    3411 </span><span class="lineCov">        357 :                 isLValue = true;</span></a>
<a name="3412"><span class="lineNum">    3412 </span><span class="lineCov">        357 :                 break;</span></a>
<a name="3413"><span class="lineNum">    3413 </span>            :         }</a>
<a name="3414"><span class="lineNum">    3414 </span><span class="lineCov">          4 :         case Type::Category::TypeType:</span></a>
<a name="3415"><span class="lineNum">    3415 </span>            :         {</a>
<a name="3416"><span class="lineNum">    3416 </span><span class="lineCov">          4 :                 TypeType const&amp; typeType = dynamic_cast&lt;TypeType const&amp;&gt;(*baseType);</span></a>
<a name="3417"><span class="lineNum">    3417 </span><span class="lineCov">          4 :                 if (auto const* contractType = dynamic_cast&lt;ContractType const*&gt;(typeType.actualType()))</span></a>
<a name="3418"><span class="lineNum">    3418 </span><span class="lineCov">          1 :                         if (contractType-&gt;contractDefinition().isLibrary())</span></a>
<a name="3419"><span class="lineNum">    3419 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(2876_error, _access.location(), &quot;Index access for library types and arrays of libraries are not possible.&quot;);</span></a>
<a name="3420"><span class="lineNum">    3420 </span><span class="lineCov">          4 :                 if (!index)</span></a>
<a name="3421"><span class="lineNum">    3421 </span><span class="lineCov">          2 :                         resultType = TypeProvider::typeType(TypeProvider::array(DataLocation::Memory, typeType.actualType()));</span></a>
<a name="3422"><span class="lineNum">    3422 </span>            :                 else</a>
<a name="3423"><span class="lineNum">    3423 </span>            :                 {</a>
<a name="3424"><span class="lineNum">    3424 </span><span class="lineCov">          2 :                         u256 length = 1;</span></a>
<a name="3425"><span class="lineNum">    3425 </span><span class="lineCov">          2 :                         if (expectType(*index, *TypeProvider::uint256()))</span></a>
<a name="3426"><span class="lineNum">    3426 </span>            :                         {</a>
<a name="3427"><span class="lineNum">    3427 </span><span class="lineCov">          2 :                                 if (auto indexValue = dynamic_cast&lt;RationalNumberType const*&gt;(type(*index)))</span></a>
<a name="3428"><span class="lineNum">    3428 </span><span class="lineCov">          1 :                                         length = indexValue-&gt;literalValue(nullptr);</span></a>
<a name="3429"><span class="lineNum">    3429 </span>            :                                 else</a>
<a name="3430"><span class="lineNum">    3430 </span><span class="lineCov">          3 :                                         m_errorReporter.fatalTypeError(3940_error, index-&gt;location(), &quot;Integer constant expected.&quot;);</span></a>
<a name="3431"><span class="lineNum">    3431 </span>            :                         }</a>
<a name="3432"><span class="lineNum">    3432 </span>            :                         else</a>
<a name="3433"><span class="lineNum">    3433 </span><span class="lineNoCov">          0 :                                 solAssert(m_errorReporter.hasErrors(), &quot;Expected errors as expectType returned false&quot;);</span></a>
<a name="3434"><span class="lineNum">    3434 </span>            : </a>
<a name="3435"><span class="lineNum">    3435 </span><span class="lineCov">          1 :                         resultType = TypeProvider::typeType(TypeProvider::array(</span></a>
<a name="3436"><span class="lineNum">    3436 </span>            :                                 DataLocation::Memory,</a>
<a name="3437"><span class="lineNum">    3437 </span>            :                                 typeType.actualType(),</a>
<a name="3438"><span class="lineNum">    3438 </span>            :                                 length</a>
<a name="3439"><span class="lineNum">    3439 </span>            :                         ));</a>
<a name="3440"><span class="lineNum">    3440 </span>            :                 }</a>
<a name="3441"><span class="lineNum">    3441 </span><span class="lineCov">          3 :                 break;</span></a>
<a name="3442"><span class="lineNum">    3442 </span>            :         }</a>
<a name="3443"><span class="lineNum">    3443 </span><span class="lineCov">          1 :         case Type::Category::FixedBytes:</span></a>
<a name="3444"><span class="lineNum">    3444 </span>            :         {</a>
<a name="3445"><span class="lineNum">    3445 </span><span class="lineCov">          1 :                 FixedBytesType const&amp; bytesType = dynamic_cast&lt;FixedBytesType const&amp;&gt;(*baseType);</span></a>
<a name="3446"><span class="lineNum">    3446 </span><span class="lineCov">          1 :                 if (!index)</span></a>
<a name="3447"><span class="lineNum">    3447 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(8830_error, _access.location(), &quot;Index expression cannot be omitted.&quot;);</span></a>
<a name="3448"><span class="lineNum">    3448 </span>            :                 else</a>
<a name="3449"><span class="lineNum">    3449 </span>            :                 {</a>
<a name="3450"><span class="lineNum">    3450 </span><span class="lineCov">          1 :                         if (!expectType(*index, *TypeProvider::uint256()))</span></a>
<a name="3451"><span class="lineNum">    3451 </span><span class="lineNoCov">          0 :                                 m_errorReporter.fatalTypeError(6318_error, _access.location(), &quot;Index expression cannot be represented as an unsigned integer.&quot;);</span></a>
<a name="3452"><span class="lineNum">    3452 </span><span class="lineCov">          1 :                         if (auto integerType = dynamic_cast&lt;RationalNumberType const*&gt;(type(*index)))</span></a>
<a name="3453"><span class="lineNum">    3453 </span><span class="lineCov">          1 :                                 if (bytesType.numBytes() &lt;= integerType-&gt;literalValue(nullptr))</span></a>
<a name="3454"><span class="lineNum">    3454 </span><span class="lineCov">          1 :                                         m_errorReporter.typeError(1859_error, _access.location(), &quot;Out of bounds array access.&quot;);</span></a>
<a name="3455"><span class="lineNum">    3455 </span>            :                 }</a>
<a name="3456"><span class="lineNum">    3456 </span><span class="lineCov">          1 :                 resultType = TypeProvider::fixedBytes(1);</span></a>
<a name="3457"><span class="lineNum">    3457 </span><span class="lineCov">          1 :                 isLValue = false; // @todo this heavily depends on how it is embedded</span></a>
<a name="3458"><span class="lineNum">    3458 </span><span class="lineCov">          1 :                 break;</span></a>
<a name="3459"><span class="lineNum">    3459 </span>            :         }</a>
<a name="3460"><span class="lineNum">    3460 </span><span class="lineCov">         13 :         default:</span></a>
<a name="3461"><span class="lineNum">    3461 </span><span class="lineCov">         13 :                 m_errorReporter.fatalTypeError(</span></a>
<a name="3462"><span class="lineNum">    3462 </span>            :                         2614_error,</a>
<a name="3463"><span class="lineNum">    3463 </span><span class="lineCov">         13 :                         _access.baseExpression().location(),</span></a>
<a name="3464"><span class="lineNum">    3464 </span><span class="lineCov">         52 :                         &quot;Indexed expression has to be a type, mapping or array (is &quot; + baseType-&gt;humanReadableName() + &quot;)&quot;</span></a>
<a name="3465"><span class="lineNum">    3465 </span>            :                 );</a>
<a name="3466"><span class="lineNum">    3466 </span>            :         }</a>
<a name="3467"><span class="lineNum">    3467 </span><span class="lineCov">        675 :         _access.annotation().type = resultType;</span></a>
<a name="3468"><span class="lineNum">    3468 </span><span class="lineCov">        675 :         _access.annotation().isLValue = isLValue;</span></a>
<a name="3469"><span class="lineNum">    3469 </span><span class="lineCov">        675 :         if (index &amp;&amp; !*index-&gt;annotation().isPure)</span></a>
<a name="3470"><span class="lineNum">    3470 </span><span class="lineCov">        277 :                 isPure = false;</span></a>
<a name="3471"><span class="lineNum">    3471 </span><span class="lineCov">        675 :         _access.annotation().isPure = isPure;</span></a>
<a name="3472"><span class="lineNum">    3472 </span>            : </a>
<a name="3473"><span class="lineNum">    3473 </span><span class="lineCov">        675 :         return false;</span></a>
<a name="3474"><span class="lineNum">    3474 </span>            : }</a>
<a name="3475"><span class="lineNum">    3475 </span>            : </a>
<a name="3476"><span class="lineNum">    3476 </span><span class="lineNoCov">          0 : bool TypeChecker::visit(IndexRangeAccess const&amp; _access)</span></a>
<a name="3477"><span class="lineNum">    3477 </span>            : {</a>
<a name="3478"><span class="lineNum">    3478 </span><span class="lineNoCov">          0 :         _access.annotation().isConstant = false;</span></a>
<a name="3479"><span class="lineNum">    3479 </span><span class="lineNoCov">          0 :         _access.baseExpression().accept(*this);</span></a>
<a name="3480"><span class="lineNum">    3480 </span>            : </a>
<a name="3481"><span class="lineNum">    3481 </span><span class="lineNoCov">          0 :         bool isLValue = false; // TODO: set this correctly when implementing slices for memory and storage arrays</span></a>
<a name="3482"><span class="lineNum">    3482 </span><span class="lineNoCov">          0 :         bool isPure = *_access.baseExpression().annotation().isPure;</span></a>
<a name="3483"><span class="lineNum">    3483 </span>            : </a>
<a name="3484"><span class="lineNum">    3484 </span><span class="lineNoCov">          0 :         if (Expression const* start = _access.startExpression())</span></a>
<a name="3485"><span class="lineNum">    3485 </span>            :         {</a>
<a name="3486"><span class="lineNum">    3486 </span><span class="lineNoCov">          0 :                 expectType(*start, *TypeProvider::uint256());</span></a>
<a name="3487"><span class="lineNum">    3487 </span><span class="lineNoCov">          0 :                 if (!*start-&gt;annotation().isPure)</span></a>
<a name="3488"><span class="lineNum">    3488 </span><span class="lineNoCov">          0 :                         isPure = false;</span></a>
<a name="3489"><span class="lineNum">    3489 </span>            :         }</a>
<a name="3490"><span class="lineNum">    3490 </span><span class="lineNoCov">          0 :         if (Expression const* end = _access.endExpression())</span></a>
<a name="3491"><span class="lineNum">    3491 </span>            :         {</a>
<a name="3492"><span class="lineNum">    3492 </span><span class="lineNoCov">          0 :                 expectType(*end, *TypeProvider::uint256());</span></a>
<a name="3493"><span class="lineNum">    3493 </span><span class="lineNoCov">          0 :                 if (!*end-&gt;annotation().isPure)</span></a>
<a name="3494"><span class="lineNum">    3494 </span><span class="lineNoCov">          0 :                         isPure = false;</span></a>
<a name="3495"><span class="lineNum">    3495 </span>            :         }</a>
<a name="3496"><span class="lineNum">    3496 </span>            : </a>
<a name="3497"><span class="lineNum">    3497 </span><span class="lineNoCov">          0 :         _access.annotation().isLValue = isLValue;</span></a>
<a name="3498"><span class="lineNum">    3498 </span><span class="lineNoCov">          0 :         _access.annotation().isPure = isPure;</span></a>
<a name="3499"><span class="lineNum">    3499 </span>            : </a>
<a name="3500"><span class="lineNum">    3500 </span><span class="lineNoCov">          0 :         Type const* exprType = type(_access.baseExpression());</span></a>
<a name="3501"><span class="lineNum">    3501 </span><span class="lineNoCov">          0 :         if (exprType-&gt;category() == Type::Category::TypeType)</span></a>
<a name="3502"><span class="lineNum">    3502 </span>            :         {</a>
<a name="3503"><span class="lineNum">    3503 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(1760_error, _access.location(), &quot;Types cannot be sliced.&quot;);</span></a>
<a name="3504"><span class="lineNum">    3504 </span><span class="lineNoCov">          0 :                 _access.annotation().type = exprType;</span></a>
<a name="3505"><span class="lineNum">    3505 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="3506"><span class="lineNum">    3506 </span>            :         }</a>
<a name="3507"><span class="lineNum">    3507 </span>            : </a>
<a name="3508"><span class="lineNum">    3508 </span><span class="lineNoCov">          0 :         ArrayType const* arrayType = nullptr;</span></a>
<a name="3509"><span class="lineNum">    3509 </span><span class="lineNoCov">          0 :         if (auto const* arraySlice = dynamic_cast&lt;ArraySliceType const*&gt;(exprType))</span></a>
<a name="3510"><span class="lineNum">    3510 </span><span class="lineNoCov">          0 :                 arrayType = &amp;arraySlice-&gt;arrayType();</span></a>
<a name="3511"><span class="lineNum">    3511 </span><span class="lineNoCov">          0 :         else if (!(arrayType = dynamic_cast&lt;ArrayType const*&gt;(exprType)))</span></a>
<a name="3512"><span class="lineNum">    3512 </span><span class="lineNoCov">          0 :                 m_errorReporter.fatalTypeError(4781_error, _access.location(), &quot;Index range access is only possible for arrays and array slices.&quot;);</span></a>
<a name="3513"><span class="lineNum">    3513 </span>            : </a>
<a name="3514"><span class="lineNum">    3514 </span><span class="lineNoCov">          0 :         if (arrayType-&gt;location() != DataLocation::CallData || !arrayType-&gt;isDynamicallySized())</span></a>
<a name="3515"><span class="lineNum">    3515 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(1227_error, _access.location(), &quot;Index range access is only supported for dynamic calldata arrays.&quot;);</span></a>
<a name="3516"><span class="lineNum">    3516 </span><span class="lineNoCov">          0 :         else if (arrayType-&gt;baseType()-&gt;isDynamicallyEncoded())</span></a>
<a name="3517"><span class="lineNum">    3517 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(2148_error, _access.location(), &quot;Index range access is not supported for arrays with dynamically encoded base types.&quot;);</span></a>
<a name="3518"><span class="lineNum">    3518 </span><span class="lineNoCov">          0 :         _access.annotation().type = TypeProvider::arraySlice(*arrayType);</span></a>
<a name="3519"><span class="lineNum">    3519 </span>            : </a>
<a name="3520"><span class="lineNum">    3520 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="3521"><span class="lineNum">    3521 </span>            : }</a>
<a name="3522"><span class="lineNum">    3522 </span>            : </a>
<a name="3523"><span class="lineNum">    3523 </span><span class="lineCov">        750 : std::vector&lt;Declaration const*&gt; TypeChecker::cleanOverloadedDeclarations(</span></a>
<a name="3524"><span class="lineNum">    3524 </span>            :         Identifier const&amp; _identifier,</a>
<a name="3525"><span class="lineNum">    3525 </span>            :         std::vector&lt;Declaration const*&gt; const&amp; _candidates</a>
<a name="3526"><span class="lineNum">    3526 </span>            : )</a>
<a name="3527"><span class="lineNum">    3527 </span>            : {</a>
<a name="3528"><span class="lineNum">    3528 </span><span class="lineCov">        750 :         solAssert(_candidates.size() &gt; 1, &quot;&quot;);</span></a>
<a name="3529"><span class="lineNum">    3529 </span><span class="lineCov">        750 :         std::vector&lt;Declaration const*&gt; uniqueDeclarations;</span></a>
<a name="3530"><span class="lineNum">    3530 </span>            : </a>
<a name="3531"><span class="lineNum">    3531 </span><span class="lineCov">       2881 :         for (Declaration const* declaration: _candidates)</span></a>
<a name="3532"><span class="lineNum">    3532 </span>            :         {</a>
<a name="3533"><span class="lineNum">    3533 </span><span class="lineCov">       2131 :                 solAssert(declaration, &quot;&quot;);</span></a>
<a name="3534"><span class="lineNum">    3534 </span>            :                 // the declaration is functionDefinition, eventDefinition or a VariableDeclaration while declarations &gt; 1</a>
<a name="3535"><span class="lineNum">    3535 </span><span class="lineCov">       2131 :                 solAssert(</span></a>
<a name="3536"><span class="lineNum">    3536 </span>            :                         dynamic_cast&lt;FunctionDefinition const*&gt;(declaration) ||</a>
<a name="3537"><span class="lineNum">    3537 </span>            :                         dynamic_cast&lt;EventDefinition const*&gt;(declaration) ||</a>
<a name="3538"><span class="lineNum">    3538 </span>            :                         dynamic_cast&lt;VariableDeclaration const*&gt;(declaration) ||</a>
<a name="3539"><span class="lineNum">    3539 </span>            :                         dynamic_cast&lt;MagicVariableDeclaration const*&gt;(declaration),</a>
<a name="3540"><span class="lineNum">    3540 </span>            :                         &quot;Found overloading involving something not a function, event or a (magic) variable.&quot;</a>
<a name="3541"><span class="lineNum">    3541 </span>            :                 );</a>
<a name="3542"><span class="lineNum">    3542 </span>            : </a>
<a name="3543"><span class="lineNum">    3543 </span><span class="lineCov">       2131 :                 FunctionTypePointer functionType {declaration-&gt;functionType(false)};</span></a>
<a name="3544"><span class="lineNum">    3544 </span><span class="lineCov">       2131 :                 if (!functionType)</span></a>
<a name="3545"><span class="lineNum">    3545 </span><span class="lineCov">         28 :                         functionType = declaration-&gt;functionType(true);</span></a>
<a name="3546"><span class="lineNum">    3546 </span><span class="lineCov">       2131 :                 solAssert(functionType, &quot;Failed to determine the function type of the overloaded.&quot;);</span></a>
<a name="3547"><span class="lineNum">    3547 </span>            : </a>
<a name="3548"><span class="lineNum">    3548 </span><span class="lineCov">       5089 :                 for (Type const* parameter: functionType-&gt;parameterTypes() + functionType-&gt;returnParameterTypes())</span></a>
<a name="3549"><span class="lineNum">    3549 </span><span class="lineCov">       2958 :                         if (!parameter)</span></a>
<a name="3550"><span class="lineNum">    3550 </span><span class="lineNoCov">          0 :                                 m_errorReporter.fatalDeclarationError(3893_error, _identifier.location(), &quot;Function type can not be used in this context.&quot;);</span></a>
<a name="3551"><span class="lineNum">    3551 </span>            : </a>
<a name="3552"><span class="lineNum">    3552 </span><span class="lineCov">       2131 :                 if (uniqueDeclarations.end() == find_if(</span></a>
<a name="3553"><span class="lineNum">    3553 </span>            :                         uniqueDeclarations.begin(),</a>
<a name="3554"><span class="lineNum">    3554 </span>            :                         uniqueDeclarations.end(),</a>
<a name="3555"><span class="lineNum">    3555 </span><span class="lineCov">       1921 :                         [&amp;](Declaration const* d)</span></a>
<a name="3556"><span class="lineNum">    3556 </span>            :                         {</a>
<a name="3557"><span class="lineNum">    3557 </span><span class="lineCov">       1921 :                                 FunctionType const* newFunctionType = d-&gt;functionType(false);</span></a>
<a name="3558"><span class="lineNum">    3558 </span><span class="lineCov">       1921 :                                 if (!newFunctionType)</span></a>
<a name="3559"><span class="lineNum">    3559 </span><span class="lineCov">        111 :                                         newFunctionType = d-&gt;functionType(true);</span></a>
<a name="3560"><span class="lineNum">    3560 </span><span class="lineCov">       1921 :                                 return newFunctionType &amp;&amp; functionType-&gt;hasEqualParameterTypes(*newFunctionType);</span></a>
<a name="3561"><span class="lineNum">    3561 </span>            :                         }</a>
<a name="3562"><span class="lineNum">    3562 </span><span class="lineCov">       2131 :                 ))</span></a>
<a name="3563"><span class="lineNum">    3563 </span><span class="lineCov">       2005 :                         uniqueDeclarations.push_back(declaration);</span></a>
<a name="3564"><span class="lineNum">    3564 </span>            :         }</a>
<a name="3565"><span class="lineNum">    3565 </span><span class="lineCov">        750 :         return uniqueDeclarations;</span></a>
<a name="3566"><span class="lineNum">    3566 </span>            : }</a>
<a name="3567"><span class="lineNum">    3567 </span>            : </a>
<a name="3568"><span class="lineNum">    3568 </span><span class="lineCov">      23517 : bool TypeChecker::visit(Identifier const&amp; _identifier)</span></a>
<a name="3569"><span class="lineNum">    3569 </span>            : {</a>
<a name="3570"><span class="lineNum">    3570 </span><span class="lineCov">      23517 :         IdentifierAnnotation&amp; annotation = _identifier.annotation();</span></a>
<a name="3571"><span class="lineNum">    3571 </span>            : </a>
<a name="3572"><span class="lineNum">    3572 </span><span class="lineCov">      23517 :         if (!annotation.referencedDeclaration)</span></a>
<a name="3573"><span class="lineNum">    3573 </span>            :         {</a>
<a name="3574"><span class="lineNum">    3574 </span><span class="lineCov">        750 :                 annotation.overloadedDeclarations = cleanOverloadedDeclarations(_identifier, annotation.candidateDeclarations);</span></a>
<a name="3575"><span class="lineNum">    3575 </span><span class="lineCov">        750 :                 if (annotation.overloadedDeclarations.empty())</span></a>
<a name="3576"><span class="lineNum">    3576 </span><span class="lineNoCov">          0 :                         m_errorReporter.fatalTypeError(7593_error, _identifier.location(), &quot;No candidates for overload resolution found.&quot;);</span></a>
<a name="3577"><span class="lineNum">    3577 </span><span class="lineCov">        750 :                 else if (annotation.overloadedDeclarations.size() == 1)</span></a>
<a name="3578"><span class="lineNum">    3578 </span><span class="lineCov">         33 :                         annotation.referencedDeclaration = *annotation.overloadedDeclarations.begin();</span></a>
<a name="3579"><span class="lineNum">    3579 </span><span class="lineCov">        717 :                 else if (!annotation.arguments)</span></a>
<a name="3580"><span class="lineNum">    3580 </span>            :                 {</a>
<a name="3581"><span class="lineNum">    3581 </span>            :                         // The identifier should be a public state variable shadowing other functions</a>
<a name="3582"><span class="lineNum">    3582 </span><span class="lineCov">          6 :                         std::vector&lt;Declaration const*&gt; candidates;</span></a>
<a name="3583"><span class="lineNum">    3583 </span>            : </a>
<a name="3584"><span class="lineNum">    3584 </span><span class="lineCov">          9 :                         for (Declaration const* declaration: annotation.overloadedDeclarations)</span></a>
<a name="3585"><span class="lineNum">    3585 </span>            :                         {</a>
<a name="3586"><span class="lineNum">    3586 </span><span class="lineCov">          6 :                                 if (VariableDeclaration const* variableDeclaration = dynamic_cast&lt;decltype(variableDeclaration)&gt;(declaration))</span></a>
<a name="3587"><span class="lineNum">    3587 </span><span class="lineNoCov">          0 :                                         candidates.push_back(declaration);</span></a>
<a name="3588"><span class="lineNum">    3588 </span>            :                         }</a>
<a name="3589"><span class="lineNum">    3589 </span><span class="lineCov">          3 :                         if (candidates.empty())</span></a>
<a name="3590"><span class="lineNum">    3590 </span><span class="lineCov">          9 :                                 m_errorReporter.fatalTypeError(2144_error, _identifier.location(), &quot;No matching declaration found after variable lookup.&quot;);</span></a>
<a name="3591"><span class="lineNum">    3591 </span><span class="lineNoCov">          0 :                         else if (candidates.size() == 1)</span></a>
<a name="3592"><span class="lineNum">    3592 </span><span class="lineNoCov">          0 :                                 annotation.referencedDeclaration = candidates.front();</span></a>
<a name="3593"><span class="lineNum">    3593 </span>            :                         else</a>
<a name="3594"><span class="lineNum">    3594 </span><span class="lineNoCov">          0 :                                 m_errorReporter.fatalTypeError(7589_error, _identifier.location(), &quot;No unique declaration found after variable lookup.&quot;);</span></a>
<a name="3595"><span class="lineNum">    3595 </span>            :                 }</a>
<a name="3596"><span class="lineNum">    3596 </span>            :                 else</a>
<a name="3597"><span class="lineNum">    3597 </span>            :                 {</a>
<a name="3598"><span class="lineNum">    3598 </span><span class="lineCov">       1428 :                         std::vector&lt;Declaration const*&gt; candidates;</span></a>
<a name="3599"><span class="lineNum">    3599 </span>            : </a>
<a name="3600"><span class="lineNum">    3600 </span><span class="lineCov">       2680 :                         for (Declaration const* declaration: annotation.overloadedDeclarations)</span></a>
<a name="3601"><span class="lineNum">    3601 </span>            :                         {</a>
<a name="3602"><span class="lineNum">    3602 </span><span class="lineCov">       1966 :                                 FunctionTypePointer functionType = declaration-&gt;functionType(true);</span></a>
<a name="3603"><span class="lineNum">    3603 </span><span class="lineCov">       1966 :                                 solAssert(!!functionType, &quot;Requested type not present.&quot;);</span></a>
<a name="3604"><span class="lineNum">    3604 </span><span class="lineCov">       1966 :                                 if (functionType-&gt;canTakeArguments(*annotation.arguments))</span></a>
<a name="3605"><span class="lineNum">    3605 </span><span class="lineCov">        694 :                                         candidates.push_back(declaration);</span></a>
<a name="3606"><span class="lineNum">    3606 </span>            :                         }</a>
<a name="3607"><span class="lineNum">    3607 </span><span class="lineCov">        714 :                         if (candidates.size() == 1)</span></a>
<a name="3608"><span class="lineNum">    3608 </span><span class="lineCov">        694 :                                 annotation.referencedDeclaration = candidates.front();</span></a>
<a name="3609"><span class="lineNum">    3609 </span>            :                         else</a>
<a name="3610"><span class="lineNum">    3610 </span>            :                         {</a>
<a name="3611"><span class="lineNum">    3611 </span><span class="lineCov">         40 :                                 SecondarySourceLocation ssl;</span></a>
<a name="3612"><span class="lineNum">    3612 </span>            : </a>
<a name="3613"><span class="lineNum">    3613 </span><span class="lineCov">         71 :                                 for (Declaration const* declaration: annotation.overloadedDeclarations)</span></a>
<a name="3614"><span class="lineNum">    3614 </span><span class="lineCov">         51 :                                         if (!declaration-&gt;location().isValid())</span></a>
<a name="3615"><span class="lineNum">    3615 </span>            :                                         {</a>
<a name="3616"><span class="lineNum">    3616 </span>            :                                                 // Try to re-construct function definition</a>
<a name="3617"><span class="lineNum">    3617 </span><span class="lineCov">         46 :                                                 std::string description;</span></a>
<a name="3618"><span class="lineNum">    3618 </span><span class="lineCov">        104 :                                                 for (auto const&amp; param: declaration-&gt;functionType(true)-&gt;parameterTypes())</span></a>
<a name="3619"><span class="lineNum">    3619 </span><span class="lineCov">         58 :                                                         description += (description.empty() ? &quot;&quot; : &quot;, &quot;) + param-&gt;humanReadableName();</span></a>
<a name="3620"><span class="lineNum">    3620 </span><span class="lineCov">         46 :                                                 description = &quot;function &quot; + _identifier.name() + &quot;(&quot; + description + &quot;)&quot;;</span></a>
<a name="3621"><span class="lineNum">    3621 </span>            : </a>
<a name="3622"><span class="lineNum">    3622 </span><span class="lineCov">         46 :                                                 ssl.append(&quot;Candidate: &quot; + description, declaration-&gt;location());</span></a>
<a name="3623"><span class="lineNum">    3623 </span>            :                                         }</a>
<a name="3624"><span class="lineNum">    3624 </span>            :                                         else</a>
<a name="3625"><span class="lineNum">    3625 </span><span class="lineCov">          5 :                                                 ssl.append(&quot;Candidate:&quot;, declaration-&gt;location());</span></a>
<a name="3626"><span class="lineNum">    3626 </span><span class="lineCov">         20 :                                 if (candidates.empty())</span></a>
<a name="3627"><span class="lineNum">    3627 </span><span class="lineCov">         60 :                                         m_errorReporter.fatalTypeError(9322_error, _identifier.location(), ssl, &quot;No matching declaration found after argument-dependent lookup.&quot;);</span></a>
<a name="3628"><span class="lineNum">    3628 </span>            :                                 else</a>
<a name="3629"><span class="lineNum">    3629 </span><span class="lineNoCov">          0 :                                         m_errorReporter.fatalTypeError(4487_error, _identifier.location(), ssl, &quot;No unique declaration found after argument-dependent lookup.&quot;);</span></a>
<a name="3630"><span class="lineNum">    3630 </span>            :                         }</a>
<a name="3631"><span class="lineNum">    3631 </span>            :                 }</a>
<a name="3632"><span class="lineNum">    3632 </span>            :         }</a>
<a name="3633"><span class="lineNum">    3633 </span><span class="lineCov">      23494 :         solAssert(</span></a>
<a name="3634"><span class="lineNum">    3634 </span>            :                 !!annotation.referencedDeclaration,</a>
<a name="3635"><span class="lineNum">    3635 </span>            :                 &quot;Referenced declaration is null after overload resolution.&quot;</a>
<a name="3636"><span class="lineNum">    3636 </span>            :         );</a>
<a name="3637"><span class="lineNum">    3637 </span><span class="lineCov">      23494 :         bool isConstant = false;</span></a>
<a name="3638"><span class="lineNum">    3638 </span><span class="lineCov">      23494 :         annotation.isLValue = annotation.referencedDeclaration-&gt;isLValue();</span></a>
<a name="3639"><span class="lineNum">    3639 </span><span class="lineCov">      23494 :         annotation.type = annotation.referencedDeclaration-&gt;type();</span></a>
<a name="3640"><span class="lineNum">    3640 </span><span class="lineCov">      23494 :         solAssert(annotation.type, &quot;Declaration referenced before type could be determined.&quot;);</span></a>
<a name="3641"><span class="lineNum">    3641 </span><span class="lineCov">      23494 :         if (auto variableDeclaration = dynamic_cast&lt;VariableDeclaration const*&gt;(annotation.referencedDeclaration))</span></a>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineCov">      20821 :                 annotation.isPure = isConstant = variableDeclaration-&gt;isConstant();</span></a>
<a name="3643"><span class="lineNum">    3643 </span><span class="lineCov">       2673 :         else if (dynamic_cast&lt;MagicVariableDeclaration const*&gt;(annotation.referencedDeclaration))</span></a>
<a name="3644"><span class="lineNum">    3644 </span><span class="lineCov">       1595 :                 annotation.isPure = dynamic_cast&lt;FunctionType const*&gt;(annotation.type);</span></a>
<a name="3645"><span class="lineNum">    3645 </span><span class="lineCov">       1078 :         else if (dynamic_cast&lt;TypeType const*&gt;(annotation.type))</span></a>
<a name="3646"><span class="lineNum">    3646 </span><span class="lineCov">        156 :                 annotation.isPure = true;</span></a>
<a name="3647"><span class="lineNum">    3647 </span><span class="lineCov">        922 :         else if (dynamic_cast&lt;ModuleType const*&gt;(annotation.type))</span></a>
<a name="3648"><span class="lineNum">    3648 </span><span class="lineNoCov">          0 :                 annotation.isPure = true;</span></a>
<a name="3649"><span class="lineNum">    3649 </span>            :         else</a>
<a name="3650"><span class="lineNum">    3650 </span><span class="lineCov">        922 :                 annotation.isPure = false;</span></a>
<a name="3651"><span class="lineNum">    3651 </span>            : </a>
<a name="3652"><span class="lineNum">    3652 </span><span class="lineCov">      23494 :         annotation.isConstant = isConstant;</span></a>
<a name="3653"><span class="lineNum">    3653 </span>            : </a>
<a name="3654"><span class="lineNum">    3654 </span>            :         annotation.requiredLookup =</a>
<a name="3655"><span class="lineNum">    3655 </span><span class="lineCov">      23494 :                 dynamic_cast&lt;CallableDeclaration const*&gt;(annotation.referencedDeclaration) ?</span></a>
<a name="3656"><span class="lineNum">    3656 </span><span class="lineCov">      23494 :                 VirtualLookup::Virtual : VirtualLookup::Static;</span></a>
<a name="3657"><span class="lineNum">    3657 </span>            : </a>
<a name="3658"><span class="lineNum">    3658 </span>            :         // Check for deprecated function names.</a>
<a name="3659"><span class="lineNum">    3659 </span>            :         // The check is done here for the case without an actual function call.</a>
<a name="3660"><span class="lineNum">    3660 </span><span class="lineCov">      23494 :         if (FunctionType const* fType = dynamic_cast&lt;FunctionType const*&gt;(_identifier.annotation().type))</span></a>
<a name="3661"><span class="lineNum">    3661 </span>            :         {</a>
<a name="3662"><span class="lineNum">    3662 </span><span class="lineCov">       2106 :                 if (_identifier.name() == &quot;sha3&quot; &amp;&amp; fType-&gt;kind() == FunctionType::Kind::KECCAK256)</span></a>
<a name="3663"><span class="lineNum">    3663 </span><span class="lineCov">          2 :                         m_errorReporter.typeError(</span></a>
<a name="3664"><span class="lineNum">    3664 </span>            :                                 3557_error,</a>
<a name="3665"><span class="lineNum">    3665 </span><span class="lineCov">          1 :                                 _identifier.location(),</span></a>
<a name="3666"><span class="lineNum">    3666 </span>            :                                 &quot;\&quot;sha3\&quot; has been deprecated in favour of \&quot;keccak256\&quot;.&quot;</a>
<a name="3667"><span class="lineNum">    3667 </span>            :                         );</a>
<a name="3668"><span class="lineNum">    3668 </span><span class="lineCov">       2105 :                 else if (_identifier.name() == &quot;suicide&quot; &amp;&amp; fType-&gt;kind() == FunctionType::Kind::Selfdestruct)</span></a>
<a name="3669"><span class="lineNum">    3669 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="3670"><span class="lineNum">    3670 </span>            :                                 8050_error,</a>
<a name="3671"><span class="lineNum">    3671 </span><span class="lineNoCov">          0 :                                 _identifier.location(),</span></a>
<a name="3672"><span class="lineNum">    3672 </span>            :                                 &quot;\&quot;suicide\&quot; has been deprecated in favour of \&quot;selfdestruct\&quot;.&quot;</a>
<a name="3673"><span class="lineNum">    3673 </span>            :                         );</a>
<a name="3674"><span class="lineNum">    3674 </span><span class="lineCov">       2105 :                 else if (_identifier.name() == &quot;selfdestruct&quot; &amp;&amp; fType-&gt;kind() == FunctionType::Kind::Selfdestruct)</span></a>
<a name="3675"><span class="lineNum">    3675 </span><span class="lineCov">          6 :                         m_errorReporter.warning(</span></a>
<a name="3676"><span class="lineNum">    3676 </span>            :                                 5159_error,</a>
<a name="3677"><span class="lineNum">    3677 </span><span class="lineCov">          3 :                                 _identifier.location(),</span></a>
<a name="3678"><span class="lineNum">    3678 </span>            :                                 &quot;\&quot;selfdestruct\&quot; has been deprecated. &quot;</a>
<a name="3679"><span class="lineNum">    3679 </span>            :                                 &quot;Note that, starting from the Cancun hard fork, the underlying opcode no longer deletes the code and &quot;</a>
<a name="3680"><span class="lineNum">    3680 </span>            :                                 &quot;data associated with an account and only transfers its Ether to the beneficiary, &quot;</a>
<a name="3681"><span class="lineNum">    3681 </span>            :                                 &quot;unless executed in the same transaction in which the contract was created (see EIP-6780). &quot;</a>
<a name="3682"><span class="lineNum">    3682 </span>            :                                 &quot;Any use in newly deployed contracts is strongly discouraged even if the new behavior is taken into account. &quot;</a>
<a name="3683"><span class="lineNum">    3683 </span>            :                                 &quot;Future changes to the EVM might further reduce the functionality of the opcode.&quot;</a>
<a name="3684"><span class="lineNum">    3684 </span>            :                         );</a>
<a name="3685"><span class="lineNum">    3685 </span>            :         }</a>
<a name="3686"><span class="lineNum">    3686 </span>            : </a>
<a name="3687"><span class="lineNum">    3687 </span><span class="lineCov">      23494 :         if (</span></a>
<a name="3688"><span class="lineNum">    3688 </span>            :                 MagicVariableDeclaration const* magicVar =</a>
<a name="3689"><span class="lineNum">    3689 </span><span class="lineCov">      23494 :                 dynamic_cast&lt;MagicVariableDeclaration const*&gt;(annotation.referencedDeclaration)</span></a>
<a name="3690"><span class="lineNum">    3690 </span>            :         )</a>
<a name="3691"><span class="lineNum">    3691 </span><span class="lineCov">       1595 :                 if (magicVar-&gt;type()-&gt;category() == Type::Category::Integer)</span></a>
<a name="3692"><span class="lineNum">    3692 </span>            :                 {</a>
<a name="3693"><span class="lineNum">    3693 </span><span class="lineNoCov">          0 :                         solAssert(_identifier.name() == &quot;now&quot;, &quot;&quot;);</span></a>
<a name="3694"><span class="lineNum">    3694 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="3695"><span class="lineNum">    3695 </span>            :                                 7359_error,</a>
<a name="3696"><span class="lineNum">    3696 </span><span class="lineNoCov">          0 :                                 _identifier.location(),</span></a>
<a name="3697"><span class="lineNum">    3697 </span>            :                                 &quot;\&quot;now\&quot; has been deprecated. Use \&quot;block.timestamp\&quot; instead.&quot;</a>
<a name="3698"><span class="lineNum">    3698 </span>            :                         );</a>
<a name="3699"><span class="lineNum">    3699 </span>            :                 }</a>
<a name="3700"><span class="lineNum">    3700 </span>            : </a>
<a name="3701"><span class="lineNum">    3701 </span><span class="lineCov">      23494 :         return false;</span></a>
<a name="3702"><span class="lineNum">    3702 </span>            : }</a>
<a name="3703"><span class="lineNum">    3703 </span>            : </a>
<a name="3704"><span class="lineNum">    3704 </span><span class="lineCov">        747 : void TypeChecker::endVisit(IdentifierPath const&amp; _identifierPath)</span></a>
<a name="3705"><span class="lineNum">    3705 </span>            : {</a>
<a name="3706"><span class="lineNum">    3706 </span><span class="lineCov">        747 :         if (</span></a>
<a name="3707"><span class="lineNum">    3707 </span><span class="lineCov">        863 :                 dynamic_cast&lt;CallableDeclaration const*&gt;(_identifierPath.annotation().referencedDeclaration) &amp;&amp;</span></a>
<a name="3708"><span class="lineNum">    3708 </span><span class="lineCov">        116 :                 _identifierPath.path().size() == 1</span></a>
<a name="3709"><span class="lineNum">    3709 </span>            :         )</a>
<a name="3710"><span class="lineNum">    3710 </span><span class="lineCov">        116 :                 _identifierPath.annotation().requiredLookup = VirtualLookup::Virtual;</span></a>
<a name="3711"><span class="lineNum">    3711 </span>            :         else</a>
<a name="3712"><span class="lineNum">    3712 </span><span class="lineCov">        631 :                 _identifierPath.annotation().requiredLookup = VirtualLookup::Static;</span></a>
<a name="3713"><span class="lineNum">    3713 </span><span class="lineCov">        747 : }</span></a>
<a name="3714"><span class="lineNum">    3714 </span>            : </a>
<a name="3715"><span class="lineNum">    3715 </span><span class="lineCov">        295 : void TypeChecker::endVisit(UserDefinedTypeName const&amp; _userDefinedTypeName)</span></a>
<a name="3716"><span class="lineNum">    3716 </span>            : {</a>
<a name="3717"><span class="lineNum">    3717 </span><span class="lineCov">        295 :         if (!_userDefinedTypeName.annotation().type)</span></a>
<a name="3718"><span class="lineNum">    3718 </span><span class="lineNoCov">          0 :                 _userDefinedTypeName.annotation().type = _userDefinedTypeName.pathNode().annotation().referencedDeclaration-&gt;type();</span></a>
<a name="3719"><span class="lineNum">    3719 </span><span class="lineCov">        295 : }</span></a>
<a name="3720"><span class="lineNum">    3720 </span>            : </a>
<a name="3721"><span class="lineNum">    3721 </span><span class="lineCov">       2186 : void TypeChecker::endVisit(ElementaryTypeNameExpression const&amp; _expr)</span></a>
<a name="3722"><span class="lineNum">    3722 </span>            : {</a>
<a name="3723"><span class="lineNum">    3723 </span><span class="lineCov">       2186 :         _expr.annotation().type = TypeProvider::typeType(TypeProvider::fromElementaryTypeName(_expr.type().typeName(), _expr.type().stateMutability()));</span></a>
<a name="3724"><span class="lineNum">    3724 </span><span class="lineCov">       2186 :         _expr.annotation().isPure = true;</span></a>
<a name="3725"><span class="lineNum">    3725 </span><span class="lineCov">       2186 :         _expr.annotation().isLValue = false;</span></a>
<a name="3726"><span class="lineNum">    3726 </span><span class="lineCov">       2186 :         _expr.annotation().isConstant = false;</span></a>
<a name="3727"><span class="lineNum">    3727 </span><span class="lineCov">       2186 : }</span></a>
<a name="3728"><span class="lineNum">    3728 </span>            : </a>
<a name="3729"><span class="lineNum">    3729 </span><span class="lineCov">      14338 : void TypeChecker::endVisit(Literal const&amp; _literal)</span></a>
<a name="3730"><span class="lineNum">    3730 </span>            : {</a>
<a name="3731"><span class="lineNum">    3731 </span><span class="lineCov">      14338 :         if (_literal.looksLikeAddress())</span></a>
<a name="3732"><span class="lineNum">    3732 </span>            :         {</a>
<a name="3733"><span class="lineNum">    3733 </span>            :                 // Assign type here if it even looks like an address. This prevents double errors for invalid addresses</a>
<a name="3734"><span class="lineNum">    3734 </span><span class="lineCov">         45 :                 _literal.annotation().type = TypeProvider::address();</span></a>
<a name="3735"><span class="lineNum">    3735 </span>            : </a>
<a name="3736"><span class="lineNum">    3736 </span><span class="lineCov">         90 :                 std::string msg;</span></a>
<a name="3737"><span class="lineNum">    3737 </span><span class="lineCov">         45 :                 if (_literal.valueWithoutUnderscores().length() != 42) // &quot;0x&quot; + 40 hex digits</span></a>
<a name="3738"><span class="lineNum">    3738 </span>            :                         // looksLikeAddress enforces that it is a hex literal starting with &quot;0x&quot;</a>
<a name="3739"><span class="lineNum">    3739 </span>            :                         msg =</a>
<a name="3740"><span class="lineNum">    3740 </span><span class="lineCov">          8 :                                 &quot;This looks like an address but is not exactly 40 hex digits. It is &quot; +</span></a>
<a name="3741"><span class="lineNum">    3741 </span><span class="lineCov">         24 :                                 std::to_string(_literal.valueWithoutUnderscores().length() - 2) +</span></a>
<a name="3742"><span class="lineNum">    3742 </span><span class="lineCov">          8 :                                 &quot; hex digits.&quot;;</span></a>
<a name="3743"><span class="lineNum">    3743 </span><span class="lineCov">         37 :                 else if (!_literal.passesAddressChecksum())</span></a>
<a name="3744"><span class="lineNum">    3744 </span>            :                 {</a>
<a name="3745"><span class="lineNum">    3745 </span><span class="lineCov">         34 :                         msg = &quot;This looks like an address but has an invalid checksum.&quot;;</span></a>
<a name="3746"><span class="lineNum">    3746 </span><span class="lineCov">         34 :                         if (!_literal.getChecksummedAddress().empty())</span></a>
<a name="3747"><span class="lineNum">    3747 </span><span class="lineCov">         34 :                                 msg += &quot; Correct checksummed address: \&quot;&quot; + _literal.getChecksummedAddress() + &quot;\&quot;.&quot;;</span></a>
<a name="3748"><span class="lineNum">    3748 </span>            :                 }</a>
<a name="3749"><span class="lineNum">    3749 </span>            : </a>
<a name="3750"><span class="lineNum">    3750 </span><span class="lineCov">         45 :                 if (!msg.empty())</span></a>
<a name="3751"><span class="lineNum">    3751 </span><span class="lineCov">         42 :                         m_errorReporter.syntaxError(</span></a>
<a name="3752"><span class="lineNum">    3752 </span>            :                                 9429_error,</a>
<a name="3753"><span class="lineNum">    3753 </span><span class="lineCov">         42 :                                 _literal.location(),</span></a>
<a name="3754"><span class="lineNum">    3754 </span><span class="lineCov">         84 :                                 msg +</span></a>
<a name="3755"><span class="lineNum">    3755 </span><span class="lineCov">         84 :                                 &quot; If this is not used as an address, please prepend '00'. &quot; +</span></a>
<a name="3756"><span class="lineNum">    3756 </span>            :                                 &quot;For more information please see https://docs.soliditylang.org/en/develop/types.html#address-literals&quot;</a>
<a name="3757"><span class="lineNum">    3757 </span>            :                         );</a>
<a name="3758"><span class="lineNum">    3758 </span>            :         }</a>
<a name="3759"><span class="lineNum">    3759 </span>            : </a>
<a name="3760"><span class="lineNum">    3760 </span><span class="lineCov">      14338 :         if (_literal.isHexNumber() &amp;&amp; _literal.subDenomination() != Literal::SubDenomination::None)</span></a>
<a name="3761"><span class="lineNum">    3761 </span><span class="lineCov">          4 :                 m_errorReporter.fatalTypeError(</span></a>
<a name="3762"><span class="lineNum">    3762 </span>            :                         5145_error,</a>
<a name="3763"><span class="lineNum">    3763 </span><span class="lineCov">          1 :                         _literal.location(),</span></a>
<a name="3764"><span class="lineNum">    3764 </span>            :                         &quot;Hexadecimal numbers cannot be used with unit denominations. &quot;</a>
<a name="3765"><span class="lineNum">    3765 </span>            :                         &quot;You can use an expression of the form \&quot;0x1234 * 1 days\&quot; instead.&quot;</a>
<a name="3766"><span class="lineNum">    3766 </span>            :                 );</a>
<a name="3767"><span class="lineNum">    3767 </span>            : </a>
<a name="3768"><span class="lineNum">    3768 </span><span class="lineCov">      14337 :         if (_literal.subDenomination() == Literal::SubDenomination::Year)</span></a>
<a name="3769"><span class="lineNum">    3769 </span><span class="lineNoCov">          0 :                 m_errorReporter.typeError(</span></a>
<a name="3770"><span class="lineNum">    3770 </span>            :                         4820_error,</a>
<a name="3771"><span class="lineNum">    3771 </span><span class="lineNoCov">          0 :                         _literal.location(),</span></a>
<a name="3772"><span class="lineNum">    3772 </span>            :                         &quot;Using \&quot;years\&quot; as a unit denomination is deprecated.&quot;</a>
<a name="3773"><span class="lineNum">    3773 </span>            :                 );</a>
<a name="3774"><span class="lineNum">    3774 </span>            : </a>
<a name="3775"><span class="lineNum">    3775 </span><span class="lineCov">      14337 :         if (!_literal.annotation().type)</span></a>
<a name="3776"><span class="lineNum">    3776 </span><span class="lineCov">      14292 :                 _literal.annotation().type = TypeProvider::forLiteral(_literal);</span></a>
<a name="3777"><span class="lineNum">    3777 </span>            : </a>
<a name="3778"><span class="lineNum">    3778 </span><span class="lineCov">      14337 :         if (!_literal.annotation().type)</span></a>
<a name="3779"><span class="lineNum">    3779 </span><span class="lineNoCov">          0 :                 m_errorReporter.fatalTypeError(2826_error, _literal.location(), &quot;Invalid literal value.&quot;);</span></a>
<a name="3780"><span class="lineNum">    3780 </span>            : </a>
<a name="3781"><span class="lineNum">    3781 </span><span class="lineCov">      14337 :         _literal.annotation().isPure = true;</span></a>
<a name="3782"><span class="lineNum">    3782 </span><span class="lineCov">      14337 :         _literal.annotation().isLValue = false;</span></a>
<a name="3783"><span class="lineNum">    3783 </span><span class="lineCov">      14337 :         _literal.annotation().isConstant = false;</span></a>
<a name="3784"><span class="lineNum">    3784 </span><span class="lineCov">      14337 : }</span></a>
<a name="3785"><span class="lineNum">    3785 </span>            : </a>
<a name="3786"><span class="lineNum">    3786 </span><span class="lineCov">          2 : void TypeChecker::endVisit(UsingForDirective const&amp; _usingFor)</span></a>
<a name="3787"><span class="lineNum">    3787 </span>            : {</a>
<a name="3788"><span class="lineNum">    3788 </span><span class="lineCov">          2 :         if (_usingFor.global())</span></a>
<a name="3789"><span class="lineNum">    3789 </span>            :         {</a>
<a name="3790"><span class="lineNum">    3790 </span><span class="lineNoCov">          0 :                 if (m_currentContract || !_usingFor.typeName())</span></a>
<a name="3791"><span class="lineNum">    3791 </span>            :                 {</a>
<a name="3792"><span class="lineNum">    3792 </span><span class="lineNoCov">          0 :                         solAssert(m_errorReporter.hasErrors());</span></a>
<a name="3793"><span class="lineNum">    3793 </span><span class="lineNoCov">          0 :                         return;</span></a>
<a name="3794"><span class="lineNum">    3794 </span>            :                 }</a>
<a name="3795"><span class="lineNum">    3795 </span><span class="lineNoCov">          0 :                 Type const* usingForType = _usingFor.typeName()-&gt;annotation().type;</span></a>
<a name="3796"><span class="lineNum">    3796 </span><span class="lineNoCov">          0 :                 solAssert(usingForType);</span></a>
<a name="3797"><span class="lineNum">    3797 </span><span class="lineNoCov">          0 :                 if (Declaration const* typeDefinition = usingForType-&gt;typeDefinition())</span></a>
<a name="3798"><span class="lineNum">    3798 </span>            :                 {</a>
<a name="3799"><span class="lineNum">    3799 </span><span class="lineNoCov">          0 :                         if (typeDefinition-&gt;scope() != m_currentSourceUnit)</span></a>
<a name="3800"><span class="lineNum">    3800 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3801"><span class="lineNum">    3801 </span>            :                                         4117_error,</a>
<a name="3802"><span class="lineNum">    3802 </span><span class="lineNoCov">          0 :                                         _usingFor.location(),</span></a>
<a name="3803"><span class="lineNum">    3803 </span>            :                                         &quot;Can only use \&quot;global\&quot; with types defined in the same source unit at file level.&quot;</a>
<a name="3804"><span class="lineNum">    3804 </span>            :                                 );</a>
<a name="3805"><span class="lineNum">    3805 </span>            :                 }</a>
<a name="3806"><span class="lineNum">    3806 </span>            :                 else</a>
<a name="3807"><span class="lineNum">    3807 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="3808"><span class="lineNum">    3808 </span>            :                                 8841_error,</a>
<a name="3809"><span class="lineNum">    3809 </span><span class="lineNoCov">          0 :                                 _usingFor.location(),</span></a>
<a name="3810"><span class="lineNum">    3810 </span>            :                                 &quot;Can only use \&quot;global\&quot; with user-defined types.&quot;</a>
<a name="3811"><span class="lineNum">    3811 </span>            :                         );</a>
<a name="3812"><span class="lineNum">    3812 </span>            :         }</a>
<a name="3813"><span class="lineNum">    3813 </span>            : </a>
<a name="3814"><span class="lineNum">    3814 </span><span class="lineCov">          2 :         if (!_usingFor.usesBraces())</span></a>
<a name="3815"><span class="lineNum">    3815 </span>            :         {</a>
<a name="3816"><span class="lineNum">    3816 </span><span class="lineCov">          2 :                 solAssert(_usingFor.functionsOrLibrary().size() == 1);</span></a>
<a name="3817"><span class="lineNum">    3817 </span><span class="lineNoCov">          0 :                 ContractDefinition const* library = dynamic_cast&lt;ContractDefinition const*&gt;(</span></a>
<a name="3818"><span class="lineNum">    3818 </span><span class="lineCov">          2 :                         _usingFor.functionsOrLibrary().front()-&gt;annotation().referencedDeclaration</span></a>
<a name="3819"><span class="lineNum">    3819 </span><span class="lineCov">          2 :                 );</span></a>
<a name="3820"><span class="lineNum">    3820 </span><span class="lineCov">          2 :                 solAssert(library &amp;&amp; library-&gt;isLibrary());</span></a>
<a name="3821"><span class="lineNum">    3821 </span>            :                 // No type checking for libraries</a>
<a name="3822"><span class="lineNum">    3822 </span><span class="lineCov">          2 :                 return;</span></a>
<a name="3823"><span class="lineNum">    3823 </span>            :         }</a>
<a name="3824"><span class="lineNum">    3824 </span>            : </a>
<a name="3825"><span class="lineNum">    3825 </span><span class="lineNoCov">          0 :         if (!_usingFor.typeName())</span></a>
<a name="3826"><span class="lineNum">    3826 </span>            :         {</a>
<a name="3827"><span class="lineNum">    3827 </span><span class="lineNoCov">          0 :                 solAssert(m_errorReporter.hasErrors());</span></a>
<a name="3828"><span class="lineNum">    3828 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="3829"><span class="lineNum">    3829 </span>            :         }</a>
<a name="3830"><span class="lineNum">    3830 </span>            : </a>
<a name="3831"><span class="lineNum">    3831 </span><span class="lineNoCov">          0 :         Type const* usingForType = _usingFor.typeName()-&gt;annotation().type;</span></a>
<a name="3832"><span class="lineNum">    3832 </span><span class="lineNoCov">          0 :         solAssert(usingForType);</span></a>
<a name="3833"><span class="lineNum">    3833 </span>            : </a>
<a name="3834"><span class="lineNum">    3834 </span><span class="lineNoCov">          0 :         Type const* normalizedType = TypeProvider::withLocationIfReference(</span></a>
<a name="3835"><span class="lineNum">    3835 </span>            :                 DataLocation::Storage,</a>
<a name="3836"><span class="lineNum">    3836 </span>            :                 usingForType</a>
<a name="3837"><span class="lineNum">    3837 </span>            :         );</a>
<a name="3838"><span class="lineNum">    3838 </span><span class="lineNoCov">          0 :         solAssert(normalizedType);</span></a>
<a name="3839"><span class="lineNum">    3839 </span>            : </a>
<a name="3840"><span class="lineNum">    3840 </span><span class="lineNoCov">          0 :         for (auto const&amp; [path, operator_]: _usingFor.functionsAndOperators())</span></a>
<a name="3841"><span class="lineNum">    3841 </span>            :         {</a>
<a name="3842"><span class="lineNum">    3842 </span><span class="lineNoCov">          0 :                 solAssert(path-&gt;annotation().referencedDeclaration);</span></a>
<a name="3843"><span class="lineNum">    3843 </span>            :                 FunctionDefinition const&amp; functionDefinition =</a>
<a name="3844"><span class="lineNum">    3844 </span><span class="lineNoCov">          0 :                         dynamic_cast&lt;FunctionDefinition const&amp;&gt;(*path-&gt;annotation().referencedDeclaration);</span></a>
<a name="3845"><span class="lineNum">    3845 </span>            : </a>
<a name="3846"><span class="lineNum">    3846 </span><span class="lineNoCov">          0 :                 FunctionType const* functionType = dynamic_cast&lt;FunctionType const*&gt;(</span></a>
<a name="3847"><span class="lineNum">    3847 </span><span class="lineNoCov">          0 :                         functionDefinition.libraryFunction() ?</span></a>
<a name="3848"><span class="lineNum">    3848 </span><span class="lineNoCov">          0 :                                 functionDefinition.typeViaContractName() :</span></a>
<a name="3849"><span class="lineNum">    3849 </span><span class="lineNoCov">          0 :                                 functionDefinition.type()</span></a>
<a name="3850"><span class="lineNum">    3850 </span><span class="lineNoCov">          0 :                         );</span></a>
<a name="3851"><span class="lineNum">    3851 </span>            : </a>
<a name="3852"><span class="lineNum">    3852 </span><span class="lineNoCov">          0 :                 solAssert(functionType);</span></a>
<a name="3853"><span class="lineNum">    3853 </span>            : </a>
<a name="3854"><span class="lineNum">    3854 </span><span class="lineNoCov">          0 :                 if (functionDefinition.parameters().empty())</span></a>
<a name="3855"><span class="lineNum">    3855 </span><span class="lineNoCov">          0 :                         m_errorReporter.fatalTypeError(</span></a>
<a name="3856"><span class="lineNum">    3856 </span>            :                                 4731_error,</a>
<a name="3857"><span class="lineNum">    3857 </span><span class="lineNoCov">          0 :                                 path-&gt;location(),</span></a>
<a name="3858"><span class="lineNum">    3858 </span><span class="lineNoCov">          0 :                                 SecondarySourceLocation().append(</span></a>
<a name="3859"><span class="lineNum">    3859 </span>            :                                         &quot;Function defined here:&quot;,</a>
<a name="3860"><span class="lineNum">    3860 </span><span class="lineNoCov">          0 :                                         functionDefinition.location()</span></a>
<a name="3861"><span class="lineNum">    3861 </span><span class="lineNoCov">          0 :                                 ),</span></a>
<a name="3862"><span class="lineNum">    3862 </span><span class="lineNoCov">          0 :                                 fmt::format(</span></a>
<a name="3863"><span class="lineNum">    3863 </span>            :                                         &quot;The function \&quot;{}\&quot; does not have any parameters, and therefore cannot be attached to the type \&quot;{}\&quot;.&quot;,</a>
<a name="3864"><span class="lineNum">    3864 </span><span class="lineNoCov">          0 :                                         joinHumanReadable(path-&gt;path(), &quot;.&quot;),</span></a>
<a name="3865"><span class="lineNum">    3865 </span><span class="lineNoCov">          0 :                                         normalizedType ? normalizedType-&gt;toString(true /* withoutDataLocation */) : &quot;*&quot;</span></a>
<a name="3866"><span class="lineNum">    3866 </span>            :                                 )</a>
<a name="3867"><span class="lineNum">    3867 </span>            :                         );</a>
<a name="3868"><span class="lineNum">    3868 </span>            : </a>
<a name="3869"><span class="lineNum">    3869 </span><span class="lineNoCov">          0 :                 if (</span></a>
<a name="3870"><span class="lineNum">    3870 </span><span class="lineNoCov">          0 :                         functionDefinition.visibility() == Visibility::Private &amp;&amp;</span></a>
<a name="3871"><span class="lineNum">    3871 </span><span class="lineNoCov">          0 :                         functionDefinition.scope() != m_currentContract</span></a>
<a name="3872"><span class="lineNum">    3872 </span>            :                 )</a>
<a name="3873"><span class="lineNum">    3873 </span>            :                 {</a>
<a name="3874"><span class="lineNum">    3874 </span><span class="lineNoCov">          0 :                         solAssert(functionDefinition.libraryFunction());</span></a>
<a name="3875"><span class="lineNum">    3875 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="3876"><span class="lineNum">    3876 </span>            :                                 6772_error,</a>
<a name="3877"><span class="lineNum">    3877 </span><span class="lineNoCov">          0 :                                 path-&gt;location(),</span></a>
<a name="3878"><span class="lineNum">    3878 </span><span class="lineNoCov">          0 :                                 SecondarySourceLocation().append(</span></a>
<a name="3879"><span class="lineNum">    3879 </span>            :                                         &quot;Function defined here:&quot;,</a>
<a name="3880"><span class="lineNum">    3880 </span><span class="lineNoCov">          0 :                                         functionDefinition.location()</span></a>
<a name="3881"><span class="lineNum">    3881 </span><span class="lineNoCov">          0 :                                 ),</span></a>
<a name="3882"><span class="lineNum">    3882 </span><span class="lineNoCov">          0 :                                 fmt::format(</span></a>
<a name="3883"><span class="lineNum">    3883 </span>            :                                         &quot;Function \&quot;{}\&quot; is private and therefore cannot be attached&quot;</a>
<a name="3884"><span class="lineNum">    3884 </span>            :                                         &quot; to a type outside of the library where it is defined.&quot;,</a>
<a name="3885"><span class="lineNum">    3885 </span><span class="lineNoCov">          0 :                                         joinHumanReadable(path-&gt;path(), &quot;.&quot;)</span></a>
<a name="3886"><span class="lineNum">    3886 </span>            :                                 )</a>
<a name="3887"><span class="lineNum">    3887 </span>            :                         );</a>
<a name="3888"><span class="lineNum">    3888 </span>            :                 }</a>
<a name="3889"><span class="lineNum">    3889 </span>            : </a>
<a name="3890"><span class="lineNum">    3890 </span><span class="lineNoCov">          0 :                 FunctionType const* functionTypeWithBoundFirstArgument = functionType-&gt;withBoundFirstArgument();</span></a>
<a name="3891"><span class="lineNum">    3891 </span><span class="lineNoCov">          0 :                 solAssert(functionTypeWithBoundFirstArgument &amp;&amp; functionTypeWithBoundFirstArgument-&gt;selfType(), &quot;&quot;);</span></a>
<a name="3892"><span class="lineNum">    3892 </span>            :                 BoolResult result = normalizedType-&gt;isImplicitlyConvertibleTo(</a>
<a name="3893"><span class="lineNum">    3893 </span><span class="lineNoCov">          0 :                         *TypeProvider::withLocationIfReference(DataLocation::Storage, functionTypeWithBoundFirstArgument-&gt;selfType())</span></a>
<a name="3894"><span class="lineNum">    3894 </span><span class="lineNoCov">          0 :                 );</span></a>
<a name="3895"><span class="lineNum">    3895 </span><span class="lineNoCov">          0 :                 if (!result &amp;&amp; !operator_)</span></a>
<a name="3896"><span class="lineNum">    3896 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="3897"><span class="lineNum">    3897 </span>            :                                 3100_error,</a>
<a name="3898"><span class="lineNum">    3898 </span><span class="lineNoCov">          0 :                                 path-&gt;location(),</span></a>
<a name="3899"><span class="lineNum">    3899 </span><span class="lineNoCov">          0 :                                 SecondarySourceLocation().append(</span></a>
<a name="3900"><span class="lineNum">    3900 </span>            :                                         &quot;Function defined here:&quot;,</a>
<a name="3901"><span class="lineNum">    3901 </span><span class="lineNoCov">          0 :                                         functionDefinition.location()</span></a>
<a name="3902"><span class="lineNum">    3902 </span><span class="lineNoCov">          0 :                                 ),</span></a>
<a name="3903"><span class="lineNum">    3903 </span><span class="lineNoCov">          0 :                                 fmt::format(</span></a>
<a name="3904"><span class="lineNum">    3904 </span>            :                                         &quot;The function \&quot;{}\&quot; cannot be attached to the type \&quot;{}\&quot; because the type cannot &quot;</a>
<a name="3905"><span class="lineNum">    3905 </span>            :                                         &quot;be implicitly converted to the first argument of the function (\&quot;{}\&quot;){}&quot;,</a>
<a name="3906"><span class="lineNum">    3906 </span><span class="lineNoCov">          0 :                                         joinHumanReadable(path-&gt;path(), &quot;.&quot;),</span></a>
<a name="3907"><span class="lineNum">    3907 </span><span class="lineNoCov">          0 :                                         usingForType-&gt;toString(true /* withoutDataLocation */),</span></a>
<a name="3908"><span class="lineNum">    3908 </span><span class="lineNoCov">          0 :                                         functionTypeWithBoundFirstArgument-&gt;selfType()-&gt;humanReadableName(),</span></a>
<a name="3909"><span class="lineNum">    3909 </span><span class="lineNoCov">          0 :                                         result.message().empty() ? &quot;.&quot; : &quot;: &quot; +  result.message()</span></a>
<a name="3910"><span class="lineNum">    3910 </span>            :                                 )</a>
<a name="3911"><span class="lineNum">    3911 </span>            :                         );</a>
<a name="3912"><span class="lineNum">    3912 </span><span class="lineNoCov">          0 :                 else if (operator_.has_value())</span></a>
<a name="3913"><span class="lineNum">    3913 </span>            :                 {</a>
<a name="3914"><span class="lineNum">    3914 </span><span class="lineNoCov">          0 :                         if (!_usingFor.global())</span></a>
<a name="3915"><span class="lineNum">    3915 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3916"><span class="lineNum">    3916 </span>            :                                         3320_error,</a>
<a name="3917"><span class="lineNum">    3917 </span><span class="lineNoCov">          0 :                                         path-&gt;location(),</span></a>
<a name="3918"><span class="lineNum">    3918 </span>            :                                         &quot;Operators can only be defined in a global 'using for' directive.&quot;</a>
<a name="3919"><span class="lineNum">    3919 </span>            :                                 );</a>
<a name="3920"><span class="lineNum">    3920 </span>            : </a>
<a name="3921"><span class="lineNum">    3921 </span><span class="lineNoCov">          0 :                         if (</span></a>
<a name="3922"><span class="lineNum">    3922 </span><span class="lineNoCov">          0 :                                 functionType-&gt;stateMutability() != StateMutability::Pure ||</span></a>
<a name="3923"><span class="lineNum">    3923 </span><span class="lineNoCov">          0 :                                 !functionDefinition.isFree()</span></a>
<a name="3924"><span class="lineNum">    3924 </span>            :                         )</a>
<a name="3925"><span class="lineNum">    3925 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3926"><span class="lineNum">    3926 </span>            :                                         7775_error,</a>
<a name="3927"><span class="lineNum">    3927 </span><span class="lineNoCov">          0 :                                         path-&gt;location(),</span></a>
<a name="3928"><span class="lineNum">    3928 </span><span class="lineNoCov">          0 :                                         SecondarySourceLocation().append(</span></a>
<a name="3929"><span class="lineNum">    3929 </span>            :                                                 &quot;Function defined as non-pure here:&quot;,</a>
<a name="3930"><span class="lineNum">    3930 </span><span class="lineNoCov">          0 :                                                 functionDefinition.location()</span></a>
<a name="3931"><span class="lineNum">    3931 </span><span class="lineNoCov">          0 :                                         ),</span></a>
<a name="3932"><span class="lineNum">    3932 </span>            :                                         &quot;Only pure free functions can be used to define operators.&quot;</a>
<a name="3933"><span class="lineNum">    3933 </span>            :                                 );</a>
<a name="3934"><span class="lineNum">    3934 </span>            : </a>
<a name="3935"><span class="lineNum">    3935 </span><span class="lineNoCov">          0 :                         solAssert(!functionType-&gt;hasBoundFirstArgument());</span></a>
<a name="3936"><span class="lineNum">    3936 </span><span class="lineNoCov">          0 :                         TypePointers const&amp; parameterTypes = functionType-&gt;parameterTypes();</span></a>
<a name="3937"><span class="lineNum">    3937 </span><span class="lineNoCov">          0 :                         size_t const parameterCount = parameterTypes.size();</span></a>
<a name="3938"><span class="lineNum">    3938 </span><span class="lineNoCov">          0 :                         if (usingForType-&gt;category() != Type::Category::UserDefinedValueType)</span></a>
<a name="3939"><span class="lineNum">    3939 </span>            :                         {</a>
<a name="3940"><span class="lineNum">    3940 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3941"><span class="lineNum">    3941 </span>            :                                         5332_error,</a>
<a name="3942"><span class="lineNum">    3942 </span><span class="lineNoCov">          0 :                                         path-&gt;location(),</span></a>
<a name="3943"><span class="lineNum">    3943 </span>            :                                         &quot;Operators can only be implemented for user-defined value types.&quot;</a>
<a name="3944"><span class="lineNum">    3944 </span>            :                                 );</a>
<a name="3945"><span class="lineNum">    3945 </span><span class="lineNoCov">          0 :                                 continue;</span></a>
<a name="3946"><span class="lineNum">    3946 </span>            :                         }</a>
<a name="3947"><span class="lineNum">    3947 </span><span class="lineNoCov">          0 :                         solAssert(usingForType-&gt;typeDefinition());</span></a>
<a name="3948"><span class="lineNum">    3948 </span>            : </a>
<a name="3949"><span class="lineNum">    3949 </span><span class="lineNoCov">          0 :                         bool identicalFirstTwoParameters = (parameterCount &lt; 2 || *parameterTypes.at(0) == *parameterTypes.at(1));</span></a>
<a name="3950"><span class="lineNum">    3950 </span><span class="lineNoCov">          0 :                         bool isUnaryOnlyOperator = (!TokenTraits::isBinaryOp(operator_.value()) &amp;&amp; TokenTraits::isUnaryOp(operator_.value()));</span></a>
<a name="3951"><span class="lineNum">    3951 </span><span class="lineNoCov">          0 :                         bool isBinaryOnlyOperator = (TokenTraits::isBinaryOp(operator_.value()) &amp;&amp; !TokenTraits::isUnaryOp(operator_.value()));</span></a>
<a name="3952"><span class="lineNum">    3952 </span><span class="lineNoCov">          0 :                         bool firstParameterMatchesUsingFor = parameterCount == 0 || *usingForType == *parameterTypes.front();</span></a>
<a name="3953"><span class="lineNum">    3953 </span>            : </a>
<a name="3954"><span class="lineNum">    3954 </span><span class="lineNoCov">          0 :                         std::optional&lt;std::string&gt; wrongParametersMessage;</span></a>
<a name="3955"><span class="lineNum">    3955 </span><span class="lineNoCov">          0 :                         if (isBinaryOnlyOperator &amp;&amp; (parameterCount != 2 || !identicalFirstTwoParameters))</span></a>
<a name="3956"><span class="lineNum">    3956 </span><span class="lineNoCov">          0 :                                 wrongParametersMessage = fmt::format(&quot;two parameters of type {} and the same data location&quot;, usingForType-&gt;canonicalName());</span></a>
<a name="3957"><span class="lineNum">    3957 </span><span class="lineNoCov">          0 :                         else if (isUnaryOnlyOperator &amp;&amp; (parameterCount != 1 || !firstParameterMatchesUsingFor))</span></a>
<a name="3958"><span class="lineNum">    3958 </span><span class="lineNoCov">          0 :                                 wrongParametersMessage = fmt::format(&quot;exactly one parameter of type {}&quot;, usingForType-&gt;canonicalName());</span></a>
<a name="3959"><span class="lineNum">    3959 </span><span class="lineNoCov">          0 :                         else if (parameterCount &gt;= 3 || !firstParameterMatchesUsingFor || !identicalFirstTwoParameters)</span></a>
<a name="3960"><span class="lineNum">    3960 </span><span class="lineNoCov">          0 :                                 wrongParametersMessage = fmt::format(&quot;one or two parameters of type {} and the same data location&quot;, usingForType-&gt;canonicalName());</span></a>
<a name="3961"><span class="lineNum">    3961 </span>            : </a>
<a name="3962"><span class="lineNum">    3962 </span><span class="lineNoCov">          0 :                         if (wrongParametersMessage.has_value())</span></a>
<a name="3963"><span class="lineNum">    3963 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3964"><span class="lineNum">    3964 </span>            :                                         1884_error,</a>
<a name="3965"><span class="lineNum">    3965 </span><span class="lineNoCov">          0 :                                         functionDefinition.parameterList().location(),</span></a>
<a name="3966"><span class="lineNum">    3966 </span><span class="lineNoCov">          0 :                                         SecondarySourceLocation().append(</span></a>
<a name="3967"><span class="lineNum">    3967 </span>            :                                                 &quot;Function was used to implement an operator here:&quot;,</a>
<a name="3968"><span class="lineNum">    3968 </span><span class="lineNoCov">          0 :                                                 path-&gt;location()</span></a>
<a name="3969"><span class="lineNum">    3969 </span><span class="lineNoCov">          0 :                                         ),</span></a>
<a name="3970"><span class="lineNum">    3970 </span><span class="lineNoCov">          0 :                                         fmt::format(</span></a>
<a name="3971"><span class="lineNum">    3971 </span>            :                                                 &quot;Wrong parameters in operator definition. &quot;</a>
<a name="3972"><span class="lineNum">    3972 </span>            :                                                 &quot;The function \&quot;{}\&quot; needs to have {} to be used for the operator {}.&quot;,</a>
<a name="3973"><span class="lineNum">    3973 </span><span class="lineNoCov">          0 :                                                 joinHumanReadable(path-&gt;path(), &quot;.&quot;),</span></a>
<a name="3974"><span class="lineNum">    3974 </span>            :                                                 wrongParametersMessage.value(),</a>
<a name="3975"><span class="lineNum">    3975 </span><span class="lineNoCov">          0 :                                                 TokenTraits::friendlyName(operator_.value())</span></a>
<a name="3976"><span class="lineNum">    3976 </span>            :                                         )</a>
<a name="3977"><span class="lineNum">    3977 </span>            :                                 );</a>
<a name="3978"><span class="lineNum">    3978 </span>            : </a>
<a name="3979"><span class="lineNum">    3979 </span>            :                         // This case is separately validated for all attached functions and is a fatal error</a>
<a name="3980"><span class="lineNum">    3980 </span><span class="lineNoCov">          0 :                         solAssert(parameterCount != 0);</span></a>
<a name="3981"><span class="lineNum">    3981 </span>            : </a>
<a name="3982"><span class="lineNum">    3982 </span><span class="lineNoCov">          0 :                         TypePointers const&amp; returnParameterTypes = functionType-&gt;returnParameterTypes();</span></a>
<a name="3983"><span class="lineNum">    3983 </span><span class="lineNoCov">          0 :                         size_t const returnParameterCount = returnParameterTypes.size();</span></a>
<a name="3984"><span class="lineNum">    3984 </span>            : </a>
<a name="3985"><span class="lineNum">    3985 </span><span class="lineNoCov">          0 :                         std::optional&lt;std::string&gt; wrongReturnParametersMessage;</span></a>
<a name="3986"><span class="lineNum">    3986 </span><span class="lineNoCov">          0 :                         if (!TokenTraits::isCompareOp(operator_.value()) &amp;&amp; operator_.value() != Token::Not)</span></a>
<a name="3987"><span class="lineNum">    3987 </span>            :                         {</a>
<a name="3988"><span class="lineNum">    3988 </span><span class="lineNoCov">          0 :                                 if (returnParameterCount != 1 || *usingForType != *returnParameterTypes.front())</span></a>
<a name="3989"><span class="lineNum">    3989 </span><span class="lineNoCov">          0 :                                         wrongReturnParametersMessage = &quot;exactly one value of type &quot; + usingForType-&gt;canonicalName();</span></a>
<a name="3990"><span class="lineNum">    3990 </span><span class="lineNoCov">          0 :                                 else if (*returnParameterTypes.front() != *parameterTypes.front())</span></a>
<a name="3991"><span class="lineNum">    3991 </span><span class="lineNoCov">          0 :                                         wrongReturnParametersMessage = &quot;a value of the same type and data location as its parameters&quot;;</span></a>
<a name="3992"><span class="lineNum">    3992 </span>            :                         }</a>
<a name="3993"><span class="lineNum">    3993 </span><span class="lineNoCov">          0 :                         else if (returnParameterCount != 1 || *returnParameterTypes.front() != *TypeProvider::boolean())</span></a>
<a name="3994"><span class="lineNum">    3994 </span><span class="lineNoCov">          0 :                                 wrongReturnParametersMessage = &quot;exactly one value of type bool&quot;;</span></a>
<a name="3995"><span class="lineNum">    3995 </span>            : </a>
<a name="3996"><span class="lineNum">    3996 </span><span class="lineNoCov">          0 :                         solAssert(functionDefinition.returnParameterList());</span></a>
<a name="3997"><span class="lineNum">    3997 </span><span class="lineNoCov">          0 :                         if (wrongReturnParametersMessage.has_value())</span></a>
<a name="3998"><span class="lineNum">    3998 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="3999"><span class="lineNum">    3999 </span>            :                                         7743_error,</a>
<a name="4000"><span class="lineNum">    4000 </span><span class="lineNoCov">          0 :                                         functionDefinition.returnParameterList()-&gt;location(),</span></a>
<a name="4001"><span class="lineNum">    4001 </span><span class="lineNoCov">          0 :                                         SecondarySourceLocation().append(</span></a>
<a name="4002"><span class="lineNum">    4002 </span>            :                                                 &quot;Function was used to implement an operator here:&quot;,</a>
<a name="4003"><span class="lineNum">    4003 </span><span class="lineNoCov">          0 :                                                 path-&gt;location()</span></a>
<a name="4004"><span class="lineNum">    4004 </span><span class="lineNoCov">          0 :                                         ),</span></a>
<a name="4005"><span class="lineNum">    4005 </span><span class="lineNoCov">          0 :                                         fmt::format(</span></a>
<a name="4006"><span class="lineNum">    4006 </span>            :                                                 &quot;Wrong return parameters in operator definition. &quot;</a>
<a name="4007"><span class="lineNum">    4007 </span>            :                                                 &quot;The function \&quot;{}\&quot; needs to return {} to be used for the operator {}.&quot;,</a>
<a name="4008"><span class="lineNum">    4008 </span><span class="lineNoCov">          0 :                                                 joinHumanReadable(path-&gt;path(), &quot;.&quot;),</span></a>
<a name="4009"><span class="lineNum">    4009 </span>            :                                                 wrongReturnParametersMessage.value(),</a>
<a name="4010"><span class="lineNum">    4010 </span><span class="lineNoCov">          0 :                                                 TokenTraits::friendlyName(operator_.value())</span></a>
<a name="4011"><span class="lineNum">    4011 </span>            :                                         )</a>
<a name="4012"><span class="lineNum">    4012 </span>            :                                 );</a>
<a name="4013"><span class="lineNum">    4013 </span>            : </a>
<a name="4014"><span class="lineNum">    4014 </span><span class="lineNoCov">          0 :                         if (parameterCount != 1 &amp;&amp; parameterCount != 2)</span></a>
<a name="4015"><span class="lineNum">    4015 </span><span class="lineNoCov">          0 :                                 solAssert(m_errorReporter.hasErrors());</span></a>
<a name="4016"><span class="lineNum">    4016 </span>            :                         else</a>
<a name="4017"><span class="lineNum">    4017 </span>            :                         {</a>
<a name="4018"><span class="lineNum">    4018 </span>            :                                 // TODO: This is pretty inefficient. For every operator binding we find, we're</a>
<a name="4019"><span class="lineNum">    4019 </span>            :                                 // traversing all bindings in all `using for` directives in the current scope.</a>
<a name="4020"><span class="lineNum">    4020 </span>            :                                 std::set&lt;FunctionDefinition const*, ASTNode::CompareByID&gt; matchingDefinitions = usingForType-&gt;operatorDefinitions(</a>
<a name="4021"><span class="lineNum">    4021 </span><span class="lineNoCov">          0 :                                         operator_.value(),</span></a>
<a name="4022"><span class="lineNum">    4022 </span><span class="lineNoCov">          0 :                                         *currentDefinitionScope(),</span></a>
<a name="4023"><span class="lineNum">    4023 </span>            :                                         parameterCount == 1 // _unary</a>
<a name="4024"><span class="lineNum">    4024 </span><span class="lineNoCov">          0 :                                 );</span></a>
<a name="4025"><span class="lineNum">    4025 </span>            : </a>
<a name="4026"><span class="lineNum">    4026 </span><span class="lineNoCov">          0 :                                 if (matchingDefinitions.size() &gt;= 2)</span></a>
<a name="4027"><span class="lineNum">    4027 </span>            :                                 {</a>
<a name="4028"><span class="lineNum">    4028 </span>            :                                         // TODO: We should point at other places that bind the operator rather than at</a>
<a name="4029"><span class="lineNum">    4029 </span>            :                                         // the definitions they bind.</a>
<a name="4030"><span class="lineNum">    4030 </span><span class="lineNoCov">          0 :                                         SecondarySourceLocation secondaryLocation;</span></a>
<a name="4031"><span class="lineNum">    4031 </span><span class="lineNoCov">          0 :                                         for (FunctionDefinition const* definition: matchingDefinitions)</span></a>
<a name="4032"><span class="lineNum">    4032 </span><span class="lineNoCov">          0 :                                                 if (functionDefinition != *definition)</span></a>
<a name="4033"><span class="lineNum">    4033 </span><span class="lineNoCov">          0 :                                                 secondaryLocation.append(&quot;Conflicting definition:&quot;, definition-&gt;location());</span></a>
<a name="4034"><span class="lineNum">    4034 </span>            : </a>
<a name="4035"><span class="lineNum">    4035 </span><span class="lineNoCov">          0 :                                         m_errorReporter.typeError(</span></a>
<a name="4036"><span class="lineNum">    4036 </span>            :                                                 4705_error,</a>
<a name="4037"><span class="lineNum">    4037 </span><span class="lineNoCov">          0 :                                                 path-&gt;location(),</span></a>
<a name="4038"><span class="lineNum">    4038 </span>            :                                                 secondaryLocation,</a>
<a name="4039"><span class="lineNum">    4039 </span><span class="lineNoCov">          0 :                                                 fmt::format(</span></a>
<a name="4040"><span class="lineNum">    4040 </span>            :                                                         &quot;User-defined {} operator {} has more than one definition matching the operand type visible in the current scope.&quot;,</a>
<a name="4041"><span class="lineNum">    4041 </span><span class="lineNoCov">          0 :                                                         parameterCount == 1 ? &quot;unary&quot; : &quot;binary&quot;,</span></a>
<a name="4042"><span class="lineNum">    4042 </span><span class="lineNoCov">          0 :                                                         TokenTraits::friendlyName(operator_.value())</span></a>
<a name="4043"><span class="lineNum">    4043 </span>            :                                                 )</a>
<a name="4044"><span class="lineNum">    4044 </span>            :                                         );</a>
<a name="4045"><span class="lineNum">    4045 </span>            :                                 }</a>
<a name="4046"><span class="lineNum">    4046 </span>            :                         }</a>
<a name="4047"><span class="lineNum">    4047 </span>            :                 }</a>
<a name="4048"><span class="lineNum">    4048 </span>            :         }</a>
<a name="4049"><span class="lineNum">    4049 </span>            : }</a>
<a name="4050"><span class="lineNum">    4050 </span>            : </a>
<a name="4051"><span class="lineNum">    4051 </span><span class="lineCov">        283 : void TypeChecker::checkErrorAndEventParameters(CallableDeclaration const&amp; _callable)</span></a>
<a name="4052"><span class="lineNum">    4052 </span>            : {</a>
<a name="4053"><span class="lineNum">    4053 </span><span class="lineCov">        566 :         std::string kind = dynamic_cast&lt;EventDefinition const*&gt;(&amp;_callable) ? &quot;event&quot; : &quot;error&quot;;</span></a>
<a name="4054"><span class="lineNum">    4054 </span><span class="lineCov">        698 :         for (ASTPointer&lt;VariableDeclaration&gt; const&amp; var: _callable.parameters())</span></a>
<a name="4055"><span class="lineNum">    4055 </span>            :         {</a>
<a name="4056"><span class="lineNum">    4056 </span><span class="lineCov">        415 :                 if (type(*var)-&gt;containsNestedMapping())</span></a>
<a name="4057"><span class="lineNum">    4057 </span><span class="lineNoCov">          0 :                         m_errorReporter.fatalTypeError(</span></a>
<a name="4058"><span class="lineNum">    4058 </span>            :                                 3448_error,</a>
<a name="4059"><span class="lineNum">    4059 </span><span class="lineNoCov">          0 :                                 var-&gt;location(),</span></a>
<a name="4060"><span class="lineNum">    4060 </span><span class="lineNoCov">          0 :                                 &quot;Type containing a (nested) mapping is not allowed as &quot; + kind + &quot; parameter type.&quot;</span></a>
<a name="4061"><span class="lineNum">    4061 </span>            :                         );</a>
<a name="4062"><span class="lineNum">    4062 </span><span class="lineCov">        415 :                 if (!type(*var)-&gt;interfaceType(false))</span></a>
<a name="4063"><span class="lineNum">    4063 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(3417_error, var-&gt;location(), &quot;Internal or recursive type is not allowed as &quot; + kind + &quot; parameter type.&quot;);</span></a>
<a name="4064"><span class="lineNum">    4064 </span><span class="lineCov">        415 :                 if (</span></a>
<a name="4065"><span class="lineNum">    4065 </span><span class="lineCov">        415 :                         !useABICoderV2() &amp;&amp;</span></a>
<a name="4066"><span class="lineNum">    4066 </span><span class="lineNoCov">          0 :                         !typeSupportedByOldABIEncoder(*type(*var), false /* isLibrary */)</span></a>
<a name="4067"><span class="lineNum">    4067 </span>            :                 )</a>
<a name="4068"><span class="lineNum">    4068 </span><span class="lineNoCov">          0 :                         m_errorReporter.typeError(</span></a>
<a name="4069"><span class="lineNum">    4069 </span>            :                                 3061_error,</a>
<a name="4070"><span class="lineNum">    4070 </span><span class="lineNoCov">          0 :                                 var-&gt;location(),</span></a>
<a name="4071"><span class="lineNum">    4071 </span>            :                                 &quot;This type is only supported in ABI coder v2. &quot;</a>
<a name="4072"><span class="lineNum">    4072 </span>            :                                 &quot;Use \&quot;pragma abicoder v2;\&quot; to enable the feature.&quot;</a>
<a name="4073"><span class="lineNum">    4073 </span>            :                         );</a>
<a name="4074"><span class="lineNum">    4074 </span>            :         }</a>
<a name="4075"><span class="lineNum">    4075 </span><span class="lineCov">        283 : }</span></a>
<a name="4076"><span class="lineNum">    4076 </span>            : </a>
<a name="4077"><span class="lineNum">    4077 </span><span class="lineNoCov">          0 : Declaration const&amp; TypeChecker::dereference(Identifier const&amp; _identifier) const</span></a>
<a name="4078"><span class="lineNum">    4078 </span>            : {</a>
<a name="4079"><span class="lineNum">    4079 </span><span class="lineNoCov">          0 :         solAssert(!!_identifier.annotation().referencedDeclaration, &quot;Declaration not stored.&quot;);</span></a>
<a name="4080"><span class="lineNum">    4080 </span><span class="lineNoCov">          0 :         return *_identifier.annotation().referencedDeclaration;</span></a>
<a name="4081"><span class="lineNum">    4081 </span>            : }</a>
<a name="4082"><span class="lineNum">    4082 </span>            : </a>
<a name="4083"><span class="lineNum">    4083 </span><span class="lineCov">        603 : Declaration const&amp; TypeChecker::dereference(IdentifierPath const&amp; _path) const</span></a>
<a name="4084"><span class="lineNum">    4084 </span>            : {</a>
<a name="4085"><span class="lineNum">    4085 </span><span class="lineCov">        603 :         solAssert(!!_path.annotation().referencedDeclaration, &quot;Declaration not stored.&quot;);</span></a>
<a name="4086"><span class="lineNum">    4086 </span><span class="lineCov">        603 :         return *_path.annotation().referencedDeclaration;</span></a>
<a name="4087"><span class="lineNum">    4087 </span>            : }</a>
<a name="4088"><span class="lineNum">    4088 </span>            : </a>
<a name="4089"><span class="lineNum">    4089 </span><span class="lineCov">       9286 : bool TypeChecker::expectType(Expression const&amp; _expression, Type const&amp; _expectedType)</span></a>
<a name="4090"><span class="lineNum">    4090 </span>            : {</a>
<a name="4091"><span class="lineNum">    4091 </span><span class="lineCov">       9286 :         _expression.accept(*this);</span></a>
<a name="4092"><span class="lineNum">    4092 </span><span class="lineCov">      18498 :         BoolResult result = type(_expression)-&gt;isImplicitlyConvertibleTo(_expectedType);</span></a>
<a name="4093"><span class="lineNum">    4093 </span><span class="lineCov">       9249 :         if (!result)</span></a>
<a name="4094"><span class="lineNum">    4094 </span>            :         {</a>
<a name="4095"><span class="lineNum">    4095 </span><span class="lineCov">        888 :                 auto errorMsg = &quot;Type &quot; +</span></a>
<a name="4096"><span class="lineNum">    4096 </span><span class="lineCov">       1776 :                         type(_expression)-&gt;humanReadableName() +</span></a>
<a name="4097"><span class="lineNum">    4097 </span>            :                         &quot; is not implicitly convertible to expected type &quot; +</a>
<a name="4098"><span class="lineNum">    4098 </span><span class="lineCov">        888 :                         _expectedType.humanReadableName();</span></a>
<a name="4099"><span class="lineNum">    4099 </span><span class="lineCov">        444 :                 if (</span></a>
<a name="4100"><span class="lineNum">    4100 </span><span class="lineCov">        444 :                         type(_expression)-&gt;category() == Type::Category::RationalNumber &amp;&amp;</span></a>
<a name="4101"><span class="lineNum">    4101 </span><span class="lineCov">        452 :                         dynamic_cast&lt;RationalNumberType const*&gt;(type(_expression))-&gt;isFractional() &amp;&amp;</span></a>
<a name="4102"><span class="lineNum">    4102 </span><span class="lineCov">          8 :                         type(_expression)-&gt;mobileType()</span></a>
<a name="4103"><span class="lineNum">    4103 </span>            :                 )</a>
<a name="4104"><span class="lineNum">    4104 </span>            :                 {</a>
<a name="4105"><span class="lineNum">    4105 </span><span class="lineCov">          8 :                         if (_expectedType.operator==(*type(_expression)-&gt;mobileType()))</span></a>
<a name="4106"><span class="lineNum">    4106 </span><span class="lineNoCov">          0 :                                 m_errorReporter.typeError(</span></a>
<a name="4107"><span class="lineNum">    4107 </span>            :                                         4426_error,</a>
<a name="4108"><span class="lineNum">    4108 </span><span class="lineNoCov">          0 :                                         _expression.location(),</span></a>
<a name="4109"><span class="lineNum">    4109 </span><span class="lineNoCov">          0 :                                         errorMsg + &quot;, but it can be explicitly converted.&quot;</span></a>
<a name="4110"><span class="lineNum">    4110 </span>            :                                 );</a>
<a name="4111"><span class="lineNum">    4111 </span>            :                         else</a>
<a name="4112"><span class="lineNum">    4112 </span><span class="lineCov">          8 :                                 m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="4113"><span class="lineNum">    4113 </span>            :                                         2326_error,</a>
<a name="4114"><span class="lineNum">    4114 </span><span class="lineCov">          8 :                                         _expression.location(),</span></a>
<a name="4115"><span class="lineNum">    4115 </span><span class="lineCov">          8 :                                         errorMsg +</span></a>
<a name="4116"><span class="lineNum">    4116 </span><span class="lineCov">         16 :                                         &quot;. Try converting to type &quot; +</span></a>
<a name="4117"><span class="lineNum">    4117 </span><span class="lineCov">         32 :                                         type(_expression)-&gt;mobileType()-&gt;humanReadableName() +</span></a>
<a name="4118"><span class="lineNum">    4118 </span>            :                                         &quot; or use an explicit conversion.&quot;,</a>
<a name="4119"><span class="lineNum">    4119 </span><span class="lineCov">          8 :                                         result.message()</span></a>
<a name="4120"><span class="lineNum">    4120 </span>            :                                 );</a>
<a name="4121"><span class="lineNum">    4121 </span>            :                 }</a>
<a name="4122"><span class="lineNum">    4122 </span>            :                 else</a>
<a name="4123"><span class="lineNum">    4123 </span><span class="lineCov">        436 :                         m_errorReporter.typeErrorConcatenateDescriptions(</span></a>
<a name="4124"><span class="lineNum">    4124 </span>            :                                 7407_error,</a>
<a name="4125"><span class="lineNum">    4125 </span><span class="lineCov">        436 :                                 _expression.location(),</span></a>
<a name="4126"><span class="lineNum">    4126 </span><span class="lineCov">        872 :                                 errorMsg + &quot;.&quot;,</span></a>
<a name="4127"><span class="lineNum">    4127 </span><span class="lineCov">        436 :                                 result.message()</span></a>
<a name="4128"><span class="lineNum">    4128 </span>            :                         );</a>
<a name="4129"><span class="lineNum">    4129 </span><span class="lineCov">        444 :                 return false;</span></a>
<a name="4130"><span class="lineNum">    4130 </span>            :         }</a>
<a name="4131"><span class="lineNum">    4131 </span><span class="lineCov">       8805 :         return true;</span></a>
<a name="4132"><span class="lineNum">    4132 </span>            : }</a>
<a name="4133"><span class="lineNum">    4133 </span>            : </a>
<a name="4134"><span class="lineNum">    4134 </span><span class="lineCov">       6997 : void TypeChecker::requireLValue(Expression const&amp; _expression, bool _ordinaryAssignment)</span></a>
<a name="4135"><span class="lineNum">    4135 </span>            : {</a>
<a name="4136"><span class="lineNum">    4136 </span><span class="lineCov">       6997 :         _expression.annotation().willBeWrittenTo = true;</span></a>
<a name="4137"><span class="lineNum">    4137 </span><span class="lineCov">       6997 :         _expression.annotation().lValueOfOrdinaryAssignment = _ordinaryAssignment;</span></a>
<a name="4138"><span class="lineNum">    4138 </span><span class="lineCov">       6997 :         _expression.accept(*this);</span></a>
<a name="4139"><span class="lineNum">    4139 </span>            : </a>
<a name="4140"><span class="lineNum">    4140 </span><span class="lineCov">       6973 :         if (*_expression.annotation().isLValue)</span></a>
<a name="4141"><span class="lineNum">    4141 </span><span class="lineCov">       6874 :                 return;</span></a>
<a name="4142"><span class="lineNum">    4142 </span>            : </a>
<a name="4143"><span class="lineNum">    4143 </span><span class="lineCov">         99 :         auto [errorId, description] = [&amp;]() -&gt; std::tuple&lt;ErrorId, std::string&gt; {</span></a>
<a name="4144"><span class="lineNum">    4144 </span><span class="lineCov">         99 :                 if (*_expression.annotation().isConstant)</span></a>
<a name="4145"><span class="lineNum">    4145 </span><span class="lineCov">         72 :                         return { 6520_error, &quot;Cannot assign to a constant variable.&quot; };</span></a>
<a name="4146"><span class="lineNum">    4146 </span>            : </a>
<a name="4147"><span class="lineNum">    4147 </span><span class="lineCov">         63 :                 if (auto indexAccess = dynamic_cast&lt;IndexAccess const*&gt;(&amp;_expression))</span></a>
<a name="4148"><span class="lineNum">    4148 </span>            :                 {</a>
<a name="4149"><span class="lineNum">    4149 </span><span class="lineCov">          1 :                         if (type(indexAccess-&gt;baseExpression())-&gt;category() == Type::Category::FixedBytes)</span></a>
<a name="4150"><span class="lineNum">    4150 </span><span class="lineCov">          2 :                                 return { 4360_error, &quot;Single bytes in fixed bytes arrays cannot be modified.&quot; };</span></a>
<a name="4151"><span class="lineNum">    4151 </span><span class="lineNoCov">          0 :                         else if (auto arrayType = dynamic_cast&lt;ArrayType const*&gt;(type(indexAccess-&gt;baseExpression())))</span></a>
<a name="4152"><span class="lineNum">    4152 </span><span class="lineNoCov">          0 :                                 if (arrayType-&gt;dataStoredIn(DataLocation::CallData))</span></a>
<a name="4153"><span class="lineNum">    4153 </span><span class="lineNoCov">          0 :                                         return { 6182_error, &quot;Calldata arrays are read-only.&quot; };</span></a>
<a name="4154"><span class="lineNum">    4154 </span>            :                 }</a>
<a name="4155"><span class="lineNum">    4155 </span>            : </a>
<a name="4156"><span class="lineNum">    4156 </span><span class="lineCov">         62 :                 if (auto memberAccess = dynamic_cast&lt;MemberAccess const*&gt;(&amp;_expression))</span></a>
<a name="4157"><span class="lineNum">    4157 </span>            :                 {</a>
<a name="4158"><span class="lineNum">    4158 </span><span class="lineCov">         23 :                         if (auto structType = dynamic_cast&lt;StructType const*&gt;(type(memberAccess-&gt;expression())))</span></a>
<a name="4159"><span class="lineNum">    4159 </span>            :                         {</a>
<a name="4160"><span class="lineNum">    4160 </span><span class="lineNoCov">          0 :                                 if (structType-&gt;dataStoredIn(DataLocation::CallData))</span></a>
<a name="4161"><span class="lineNum">    4161 </span><span class="lineNoCov">          0 :                                         return { 4156_error, &quot;Calldata structs are read-only.&quot; };</span></a>
<a name="4162"><span class="lineNum">    4162 </span>            :                         }</a>
<a name="4163"><span class="lineNum">    4163 </span><span class="lineCov">         23 :                         else if (dynamic_cast&lt;ArrayType const*&gt;(type(memberAccess-&gt;expression())))</span></a>
<a name="4164"><span class="lineNum">    4164 </span><span class="lineCov">          1 :                                 if (memberAccess-&gt;memberName() == &quot;length&quot;)</span></a>
<a name="4165"><span class="lineNum">    4165 </span><span class="lineCov">          2 :                                         return { 7567_error, &quot;Member \&quot;length\&quot; is read-only and cannot be used to resize arrays.&quot; };</span></a>
<a name="4166"><span class="lineNum">    4166 </span>            :                 }</a>
<a name="4167"><span class="lineNum">    4167 </span>            : </a>
<a name="4168"><span class="lineNum">    4168 </span><span class="lineCov">         61 :                 if (auto identifier = dynamic_cast&lt;Identifier const*&gt;(&amp;_expression))</span></a>
<a name="4169"><span class="lineNum">    4169 </span><span class="lineCov">         19 :                         if (auto varDecl = dynamic_cast&lt;VariableDeclaration const*&gt;(identifier-&gt;annotation().referencedDeclaration))</span></a>
<a name="4170"><span class="lineNum">    4170 </span><span class="lineNoCov">          0 :                                 if (varDecl-&gt;isExternalCallableParameter() &amp;&amp; dynamic_cast&lt;ReferenceType const*&gt;(identifier-&gt;annotation().type))</span></a>
<a name="4171"><span class="lineNum">    4171 </span><span class="lineNoCov">          0 :                                         return { 7128_error, &quot;External function arguments of reference type are read-only.&quot; };</span></a>
<a name="4172"><span class="lineNum">    4172 </span>            : </a>
<a name="4173"><span class="lineNum">    4173 </span><span class="lineCov">        122 :                 return { 4247_error, &quot;Expression has to be an lvalue.&quot; };</span></a>
<a name="4174"><span class="lineNum">    4174 </span><span class="lineCov">        198 :         }();</span></a>
<a name="4175"><span class="lineNum">    4175 </span>            : </a>
<a name="4176"><span class="lineNum">    4176 </span><span class="lineCov">         99 :         m_errorReporter.typeError(errorId, _expression.location(), description);</span></a>
<a name="4177"><span class="lineNum">    4177 </span>            : }</a>
<a name="4178"><span class="lineNum">    4178 </span>            : </a>
<a name="4179"><span class="lineNum">    4179 </span><span class="lineCov">      12249 : bool TypeChecker::useABICoderV2() const</span></a>
<a name="4180"><span class="lineNum">    4180 </span>            : {</a>
<a name="4181"><span class="lineNum">    4181 </span><span class="lineCov">      12249 :         solAssert(m_currentSourceUnit, &quot;&quot;);</span></a>
<a name="4182"><span class="lineNum">    4182 </span><span class="lineCov">      12249 :         if (m_currentContract)</span></a>
<a name="4183"><span class="lineNum">    4183 </span><span class="lineCov">      12235 :                 solAssert(m_currentSourceUnit == &amp;m_currentContract-&gt;sourceUnit(), &quot;&quot;);</span></a>
<a name="4184"><span class="lineNum">    4184 </span><span class="lineCov">      12249 :         return *m_currentSourceUnit-&gt;annotation().useABICoderV2;</span></a>
<a name="4185"><span class="lineNum">    4185 </span>            : </a>
<a name="4186"><span class="lineNum">    4186 </span>            : }</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
